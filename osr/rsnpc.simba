{$DEFINE WL_NPC_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TRSNPC = record
    Map: PRSWalker;
    Tile: TPoint;
    WanderRadius: Int32;
    Height: Int32;
    UpText: TStringArray;
    Finder: TRSObjectFinder;
  end;

  TRSNPCArray = array of TRSNPC;

{$I walker/worldnpc.simba}
{$I walker/zeahnpc.simba}

function TRSNPC.Find: T2DPointArray;
var
  MMTile: TPoint;
  Dot: TPoint;
  Dots: TPointArray;
  FilteredDots: TPointArray;
  Rect: TRectangle;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
begin
  MMTile := Map^.WorldToMM(Tile);
  if not Minimap.IsPointOn(MMTile, WanderRadius) then
    Exit;

  Dots := Minimap.GetDots(ERSMinimapDot.NPC);

  for Dot in Dots do
    if SRL.PointInCircle(Dot, MMTile, WanderRadius * 5) then
      FilteredDots += Dot;

  if FilteredDots = [] then
    Exit;

  for Dot in FilteredDots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    B := TPA.Bounds;

    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      TPA := MainScreen.FindObject(Finder, B).Merge;
      Result += Rect.Filter(TPA);
    end;
  end;

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

procedure TRSNPC.Debug;
var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  MMTile: TPoint;
  Dot: TPoint;
  Dots: TPointArray;
  FilteredDots: TPointArray;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
  NPC: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  //Debug tile
  Rect := Map^.GetTileMS(Tile);
  Bitmap.DrawRect(Rect, $ffffff);

  //Debug NPC
  MMTile := Map^.WorldToMM(Tile);
  if not Minimap.IsPointOn(MMTile, WanderRadius) then
  begin
    Bitmap.Free;
    Exit;
  end;

  Dots := Minimap.GetDots(ERSMinimapDot.NPC);

  for Dot in Dots do
    if SRL.PointInCircle(Dot, MMTile, WanderRadius * 5) then
      FilteredDots += Dot;

  if FilteredDots = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  for Dot in FilteredDots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;
    Bitmap.DrawRect(Rect, $ffffff);

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      Bitmap.DrawRect(Rect, $ffffff);
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    Bitmap.DrawRect(Rect, $0000ff);
    B := TPA.Bounds;

    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      TPA := MainScreen.FindObject(Finder, B).Merge;
      NPC += Rect.Filter(TPA);
    end;
  end;

  if NPC = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  NPC.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(NPC);
  Bitmap.DrawTPA(NPC[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;


procedure TRSNPC.SetupCommon(Walker: PRSWalker; Radius: Int32 = 1; NPCHeight: Int32 = 6);
begin
  Map := Walker;
  WanderRadius := Radius;
  Height := NPCHeight;
  Finder.ClusterDistance := 3;
  Finder.Erode := 2;
  Finder.Grow := 4;
end;


function TRSNPC.BlindFind: T2DPointArray;
var
  Dot: TPoint;
  Dots: TPointArray;
  Rect: TRectangle;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
begin
  Dots := Minimap.GetDots(ERSMinimapDot.NPC);
  if Dots = [] then
    Exit;

  for Dot in Dots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    B := TPA.Bounds;

    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      TPA := MainScreen.FindObject(Finder, B).Merge;
      Result += Rect.Filter(TPA);
    end;
  end;
end;

procedure TRSNPC.BlindDebug;
var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  Dot: TPoint;
  Dots: TPointArray;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
  NPC: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  //Debug NPC
  Dots := Minimap.GetDots(ERSMinimapDot.NPC);

  if Dots = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  for Dot in Dots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y, Height]);
    HighTPA := Rect.ToTPA;
    Bitmap.DrawRect(Rect, $ffffff);

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      Bitmap.DrawRect(Rect, $ffffff);
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    Bitmap.DrawRect(Rect, $0000ff);
    B := TPA.Bounds;

    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      TPA := MainScreen.FindObject(Finder, B).Merge;
      NPC += Rect.Filter(TPA);
    end;
  end;

  if NPC = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  NPC.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(NPC);
  Bitmap.DrawTPA(NPC[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;



// HoverHelper function used by all non moving npc's hovering functions.
function TRSNPC.HoverHelper(Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      Points := ATPA[Random(0, High(ATPA))];
      Mouse.Move(Points.MinAreaRect);
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if Attempt = (Attempts - 1) then
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// HoverHelper function used by all blind npc's hovering functions.
function TRSNPC.BlindHoverHelper(Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.BlindFind) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
        Mouse.Move(Points[Random(0, High(Points))]);;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if Attempt = (Attempts - 1) then
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// WalkHoverHelper function used by all moving npc's hovering functions.
function TRSNPC.WalkHoverHelper(Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      Points := ATPA[Random(0, High(ATPA))];
      Mouse.Move(Points.MinAreaRect);
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True)
    else if not Map^.AtTile(Tile, 50) or ((Attempt = (Attempts - 1)) and not Map^.AtTile(Tile, 30)) then
      Map^.WebWalk(Tile, 10, 0.2)
    else
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// ClickHelper function used by all npc's clicking functions.
function TRSNPC.ClickHelper(LeftClick: Boolean): Boolean;
begin
  if ChooseOption.IsOpen and ChooseOption.Select(UpText) then
    Exit(True);

  if LeftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and ChooseOption.Select(UpText));
end;

// SelectHelper function used by all npc's option selection functions.
function TRSNPC.SelectHelper(Action: TStringArray): Boolean;
begin
  if ChooseOption.IsOpen and
     ChooseOption.HasOption(UpText) and
     ChooseOption.Select(Action) then
    Exit(True);

  if not MainScreen.IsUpText(UpText) then
    Exit;

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;



// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSNPC.HoverRSNPC(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Map^.MakeTileVisible(Tile) then
    Exit(False);

  Result := Self.HoverHelper(Attempts);
end;

// Searches for an object with ObjectFinder and HoverRSNPC and clicks it if found.
function TRSNPC.ClickRSNPC(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSNPC(Attempts) and
            Self.ClickHelper(LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSNPC and selects the specified action if found.
function TRSNPC.SelectRSNPCOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSNPC(Attempts) and
            Self.SelectHelper(Action);
end;


// Searches for an object with ObjectFinder blindly and hovers it if found.
function TRSNPC.BlindHoverRSNPC(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Map^.MakeTileVisible(Tile) then
    Exit(False);

  Result := Self.BlindHoverHelper(Attempts);
end;

// Searches for an object with ObjectFinder and BlindHoverRSNPC and clicks it if found.
function TRSNPC.BlindClickRSNPC(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.BlindHoverRSNPC(Attempts) and
            Self.ClickHelper(LeftClick);
end;

// Searches for an object with ObjectFinder and BlindHoverRSNPC and selects the specified action if found.
function TRSNPC.BlindSelectRSNPCOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.BlindHoverRSNPC(Attempts) and
            Self.SelectHelper(Action);
end;



// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSNPC.WalkHoverRSNPC(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Map^.MakeTileVisible(Tile) then
    if not Map^.WebWalk(Tile, 30, 0.2) then
      Exit(False);

  Result := Self.WalkHoverHelper(Attempts);
end;

// Searches for an object with ObjectFinder and WalkHoverRSObject and clicks it if found.
function TRSNPC.WalkClickRSNPC(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSNPC(Attempts) and
            Self.ClickHelper(LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSNPC.WalkSelectRSNPCOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSNPC(Attempts) and
            Self.SelectHelper(Action);
end;








procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  if Name.Contains('world') then
    WorldNPCs.Load(@Self)
  else if Name.Contains('zeah') then
    ZeahNPCs.Load(@Self);
end;
