(*
ConsumableHandlers and Managers
===============================
*)

{$DEFINE WL_CONSUMABLEHANDLER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TConsumableHandler = record(TSRLBaseRecord)
    ConsumableType: ERSConsumable;
    ConsumableArray: TRSConsumableArray;

    Amount: Int32;
    MinInvPoints: Int32;

    Timer: TCountDown;

    IsSetup: Boolean;
  end;

  PConsumableHandler = ^TConsumableHandler;

function TConsumableHandler.Setup(Item: TRSItem): TRSConsumable;
begin
  Result.Item := Item;

  case Self.ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:    Result.SetupFood;
    ERSConsumable.PRAYER_CONSUMABLE:    Result.SetupPrayer;
    ERSConsumable.ENERGY_CONSUMABLE:    Result.SetupEnergy;
    ERSConsumable.POISON_CONSUMABLE:    Result.SetupAntiPoison;
    ERSConsumable.VENOM_CONSUMABLE:     Result.SetupAntiVenom;
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Result.SetupAntiFire;
    ERSConsumable.BOOST_CONSUMABLE:     Result.SetupBoost;
  end;
end;

function TConsumableHandler.FindInBank(): TRSConsumableArray;
var
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  Self.DebugLn('Setting up consumable of type: ' + ToStr(Self.ConsumableType));

  for Item in GetConsumableArray(Self.ConsumableType) do
  begin
    if Self.ConsumableArray.Contains(Item) then //avoid resetting items.
      Continue;

    if Bank.FindItem(Item.Reorder(False)) then
    begin
      Self.DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self.Setup(Item);
      Consumable.BankTab := Bank.GetCurrentTab(); //TODO: Search parent maybe?

      Result += Consumable;
    end;
  end;
end;

function TConsumableHandler.FindInInventory(): TRSConsumableArray;
var
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  Self.DebugLn('Setting up consumable of type: ' + ToStr(Self.ConsumableType));

  for Item in GetConsumableArray(Self.ConsumableType) do
  begin
    if Self.ConsumableArray.Contains(Item) then //avoid resetting leftover items.
      Continue;

    if Inventory.FindItem(Item) then
    begin
      Self.DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self.Setup(Item);

      Result += Consumable;
    end;
  end;
end;


function TConsumableHandler.NeedToConsume(): Boolean;
begin
  if not Self.IsSetup then
    Exit;

  Result := ((Self.Timer.Length > 0) and Self.Timer.IsFinished())
            or Self.Timer.IsPaused();
end;

procedure TConsumableHandler.Setup(ConsumableType: ERSConsumable); overload;
var
  C: TRSConsumable;
begin
  if Self.IsSetup then
    Exit;

  Self.ConsumableType := ConsumableType;

  case Self.ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Self.Name := 'FoodHandler';
    ERSConsumable.PRAYER_CONSUMABLE:    Self.Name := 'PrayerHandler';
    ERSConsumable.ENERGY_CONSUMABLE:    Self.Name := 'EnergyHandler';
    ERSConsumable.POISON_CONSUMABLE:    Self.Name := 'PoisonHandler';
    ERSConsumable.VENOM_CONSUMABLE:     Self.Name := 'VenomHandler';
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Self.Name := 'AntiFireHandler';
    ERSConsumable.BOOST_CONSUMABLE:     Self.Name := 'BoostHandler';
  end;

  if Inventory.Open() then
    Self.ConsumableArray := Self.FindInInventory();

  if (Self.ConsumableArray = []) and Bank.IsOpen() then
    Self.ConsumableArray := Self.FindInBank();

  Self.IsSetup := Self.ConsumableArray <> [];

  if Self.IsSetup and (C.Timer > 0) then
    Self.Timer.Setup(C.Timer);
end;

var
  FoodHandler: TConsumableHandler;
  PrayerHandler: TConsumableHandler;
  EnergyHandler: TConsumableHandler;
  PoisonHandler: TConsumableHandler;
  VenomHandler: TConsumableHandler;
  AntifireHandler: TConsumableHandler;
  BoostHandler: TConsumableHandler;

function GetHandler(ConsumableType: ERSConsumable): PConsumableHandler;
begin
  case ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:    Result := @FoodHandler;
    ERSConsumable.PRAYER_CONSUMABLE:    Result := @PrayerHandler;
    ERSConsumable.ENERGY_CONSUMABLE:    Result := @EnergyHandler;
    ERSConsumable.POISON_CONSUMABLE:    Result := @PoisonHandler;
    ERSConsumable.VENOM_CONSUMABLE:     Result := @VenomHandler;
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Result := @AntifireHandler;
    ERSConsumable.BOOST_CONSUMABLE:     Result := @BoostHandler;
  end;

  Result^.Setup(ConsumableType);
end;

function TRSInventory.FindItems(Items: TRSConsumableArray; out FoundItems: TRSConsumableArray; out Slots: TIntegerArray): Boolean; overload;
var
  SingleItem: TRSItem;
  Item: TRSConsumable;
  i: Int32;
  TBA, tmp: TBoxArray;
  UsedSlots, TempSlots, CurrentSearch: TIntegerArray;
begin
  if not Self.Open() then
    Exit;

  TBA := Self.GetSlotBoxes();
  for i:=0 to High(TBA) do
    if Self.IsSlotUsed(TBA[i]) then
    begin
      tmp += TBA[i];
      UsedSlots += i;
    end;

  for Item in Items do
  begin
    for SingleItem in Item.Item.GetArray() do
    begin
      CurrentSearch := ItemFinder.Find(SingleItem, tmp);
      if CurrentSearch <> [] then
      begin
        FoundItems += Item;
        TempSlots += CurrentSearch;
      end;
    end;
  end;

  for i in TempSlots do
    Slots += UsedSlots[i];

  Slots.ClearDuplicates();

  Result := Length(Slots) > 0;
end;

function TRSInventory.FindConsumable(ConsumableType: ERSConsumable; out FoundConsumables: TRSConsumableArray; out Slots: TIntegerArray): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindItems(ConsumableHandler^.ConsumableArray.Reversed, FoundConsumables, Slots);
end;

function TRSInventory.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;
var
  FoundItems: TRSConsumableArray;
  Slots: TIntegerArray;
begin
  Result := Self.FindConsumable(ConsumableType, FoundItems, Slots);
end;


function TRSInventory.Consume(ConsumableType: ERSConsumable; out Slots: TIntegerArray): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  FoundConsumables: TRSConsumableArray;
  StartingPoints: Int32;
  TrashSlots: TIntegerArray;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  case ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:
      StartingPoints := Minimap.GetHPLevel;

    ERSConsumable.PRAYER_CONSUMABLE:
      StartingPoints := Minimap.GetPrayerLevel;

    ERSConsumable.ENERGY_CONSUMABLE:
      StartingPoints := Minimap.GetRunEnergy;
  end;

  if not Self.FindConsumable(ConsumableType, FoundConsumables, Slots) then
    Exit;

  if not Antiban.BioDice(EBioBehavior.CONSUME_IN_BANK) and
     MainScreen.HasInterface then
     MainScreen.CloseInterface;

  Result := Self.ClickSlot(Slots[0], ['Eat', 'Drink']);

  if Result then
    case ConsumableType of
      ERSConsumable.FOOD_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetHPLevel, 100, 3000);

      ERSConsumable.PRAYER_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetPrayerLevel, 100, 3000);

      ERSConsumable.ENERGY_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetRunEnergy, 100, 3000);
      else
        Wait(400, 650);
    end;

  if Result then
  begin
    if FoundConsumables[0].Timer > 0 then
    begin
      if ConsumableType = ERSConsumable.ANTI_FIRE_CONSUMABLE then
        ConsumableHandler^.Timer.Restart(Random(-50000, -20000))
      else
        ConsumableHandler^.Timer.Restart(Random(-3000, 3000));
    end;

    TotalConsumableCost += FoundConsumables[0].Cost;

    if Inventory.FindItems(TRASH_ARRAY, TrashSlots) then
    begin
      if Bank.IsOpen then
        Bank.DepositSlot([TrashSlots[0], BANK_DEPOSIT_ALL], False)
      else
        Inventory.ShiftDrop(TrashSlots.Intersection(Inventory.RandomPattern()));

      Slots := Slots.Difference(TrashSlots); //Delete TrashSlots from Slots.
    end;
  end;
end;

function TRSInventory.Consume(ConsumableType: ERSConsumable): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.Consume(ConsumableType, Slots);
end;


function TRSInventory.CountConsumable(ConsumableType: ERSConsumable): Int32;
var
  FoundConsumables: TRSConsumableArray;
  Slots: TIntegerArray;
begin
  Self.FindConsumable(ConsumableType, FoundConsumables, Slots);

  Result := Length(Slots);
end;

function TRSInventory.CountEachConsumable(ConsumableType: ERSConsumable): T2DIntegerArray;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Item: TRSConsumable;
  IntArray: TIntegerArray;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  for Item in ConsumableHandler^.ConsumableArray do
    IntArray += Self.CountItem(Item.Item);
  Result += IntArray;
end;

function TRSInventory.CountPoints(Consumable: TRSConsumable): Int32;
var
  i: Int32;
  Items: TRSItemArray;
begin
  Items := Consumable.Item.GetArray();

  for i := 0 to High(Items) do
    Result += Inventory.CountItem(Items[i]) * Consumable.Points * (i + 1);
end;

function TRSInventory.CountPoints(ConsumableType: ERSConsumable): Int32; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Consumable: TRSConsumable;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  for Consumable in ConsumableHandler^.ConsumableArray do
    Result += Self.CountPoints(Consumable);
end;

function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  Result := Self.CountPoints(ConsumableType) >= ConsumableHandler^.MinInvPoints;
end;


function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray; out Consumable: TRSConsumable): Boolean;
begin
  for Consumable in ConsumableArray do
    if Self.FindItem(Consumable.Item) then
      Exit(True);
end;

function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray): Boolean; overload;
var
  Consumable: TRSConsumable;
begin
  Result := Self.FindConsumable(ConsumableArray, Consumable);
end;

function TRSBank.FindConsumable(ConsumableType: ERSConsumable; out Consumable: TRSConsumable): Boolean; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindConsumable(ConsumableHandler^.ConsumableArray, Consumable);
end;

function TRSBank.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindConsumable(ConsumableHandler^.ConsumableArray);
end;



function TRSBank.CountPoints(Consumable: TRSConsumable): Int32;
var
  i: Int32;
  Items: TRSItemArray;
begin
  Items := Consumable.Item.Reorder(False).GetArray();

  for i := 0 to High(Items) do
    if Self.FindItem(Items[i]) then
      Exit(Consumable.Points * Items[i].GetPortion());
end;


function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable): TIntegerArray;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Consumable: TRSConsumable;
begin
  for Consumable in ConsumableHandler^.ConsumableArray do
    case ConsumableHandler^.Amount of
      BANK_WITHDRAW_ALL: Result += BANK_WITHDRAW_ALL;
      BANK_WITHDRAW_ALL_BUT_ONE: Result += BANK_WITHDRAW_ALL_BUT_ONE;
      else
        Result += Ceil((ConsumableHandler^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / Self.CountPoints(Consumable));
    end;
end;

function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Consumable: TRSConsumable): Int32; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
    case ConsumableHandler^.Amount of
      BANK_WITHDRAW_ALL: Result := BANK_WITHDRAW_ALL;
      BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
      else
        Result := Ceil((ConsumableHandler^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / Self.CountPoints(Consumable));
    end;
end;

function TRSBank.WithdrawConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  WithdrawAmount: Int32;
  Consumable: TRSConsumable;
begin
  if not Self.FindConsumable(ConsumableType, Consumable) then
  begin
    if not ConsumableHandler^.IsSetup then
      Exit;

    if ConsumableHandler^.ConsumableArray[0].BankTab < 0 then
      ConsumableHandler^.ConsumableArray[0].BankTab := Self.FindItemTab(Consumable.Item)
    else
      Self.OpenTab(ConsumableHandler^.ConsumableArray[0].BankTab);

    if not Self.FindConsumable(ConsumableType, Consumable) then
      Exit;
  end;

  WithdrawAmount := Self.WithdrawConsumableAmount(ConsumableType, Consumable);

  if WithdrawAmount <= 0 then
    Exit;

  Self.WithdrawItem(Consumable.BankTab, [Consumable.Item, WithdrawAmount, False], False);

  Result := WaitUntil(Inventory.HasEnoughConsumable(ConsumableType), 100, 3000);
end;

//overrides
procedure TConsumablePanel.Init();
var
  i: Int32;
begin
  if not Self.IsSetup then
    Exit;

  i := Self.ConsumableSelector.GetItemIndex();

  if i > -1 then
    case Self.ConsumableType of
      FOOD_CONSUMABLE: FoodHandler.Setup(FOOD_ARRAY[i]);
      PRAYER_CONSUMABLE: PrayerHandler.Setup(PRAYER_ARRAY[i]);
      ENERGY_CONSUMABLE: EnergyHandler.Setup(ENERGY_ARRAY[i]);
      BOOST_CONSUMABLE:  BoostHandler.Setup(BOOST_ARRAY[i]);
    end;
end;

procedure TScriptForm.Init(Sender: TObject); override;
begin
  inherited;
  Self.WLPanel.FoodPanel.Init();
  Self.WLPanel.PrayerPanel.Init();

  //override me to add stuff!
end;

