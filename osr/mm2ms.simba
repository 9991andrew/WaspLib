{$DEFINE WL_MM2MS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

procedure TMM2MS.SetupZoom;
begin
  if (Self.ZoomLevel = -1) then
  begin
    Self.DebugLn('Unknown zoom level, reading from options...');
    Self.ZoomLevel := Options.GetZoomLevel();
    Self.DebugLn('Current zoom level: ' + ToString(Self.ZoomLevel));
  end;
end;

function Minimap.ZoomRadius: Int32;
begin
  if MM2MS.ZoomLevel = -1 then
    MM2MS.ZoomLevel := Options.GetZoomLevel;

  Result := Round(73 - (0.8 * (MM2MS.ZoomLevel + 25)));
end;

function Minimap.PointInZoomRadius(Pt: TPoint): Boolean;
var
  Radius: Int32;
begin
  Radius := Self.ZoomRadius;
  Result := Pt.InCircle([Minimap.Center.X, Minimap.Center.Y, Radius]);
end;

function Minimap.ZoomToPoint(Pt: TPoint): Int32;
var
  Distance: Int32;
begin
  Distance := Round(Pt.DistanceTo(Minimap.Center));

  //- Random(5, 10) to give it some margin
  Result := Round((73 - Distance) / 0.8) - Random(25, 30);
end;

//overloaded for multiple tiles. For one tile Expand should be 1.
function TRSMinimap.VecToMsRect(Vec: Vector3; Size: Double; Roll:Single): TRectangle; overload;
var
  Arr: TPointArray;
begin
  if Size = 0.0 then
    Size := 1.0;

  Size := 2 * Size;

  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);

  Arr := MM2MS.Run([Vec3(Vec.X-Size, Vec.Y-Size, Vec.z),
                    Vec3(Vec.X+Size, Vec.Y-Size, Vec.z),
                    Vec3(Vec.X+Size, Vec.Y+Size, Vec.z),
                    Vec3(Vec.X-Size, Vec.Y+Size, Vec.z)], Roll);

  Result := [Arr[0], Arr[1], Arr[2], Arr[3]];
end;

function TRSMinimap.VecToMsRect(Vec: Vector3; XMultiplier, YMultiplier: Double; Roll:Single): TRectangle; overload;
var
  Arr: TPointArray;
begin
  if XMultiplier = 0 then XMultiplier := 1;
  if YMultiplier = 0 then YMultiplier := 1;

  XMultiplier := 2 * XMultiplier;
  YMultiplier := 2 * YMultiplier;

  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);

  Arr := MM2MS.Run([Vec3(Vec.X-XMultiplier, Vec.Y-YMultiplier, Vec.z),
                    Vec3(Vec.X+XMultiplier, Vec.Y-YMultiplier, Vec.z),
                    Vec3(Vec.X+XMultiplier, Vec.Y+YMultiplier, Vec.z),
                    Vec3(Vec.X-XMultiplier, Vec.Y+YMultiplier, Vec.z)], Roll);

  Result := [Arr[0], Arr[1], Arr[2], Arr[3]];
end;



function TRSMinimap.GetTileMS(Loc: TPoint; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TRectangle;
begin
  if not Self.IsPointOn(Loc) then
    Exit;

  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  Result := Self.VecToMSRect(
                  Vec3(Loc.x - Offset.X, Loc.y - Offset.Y, TileVector.Z),
                  TileVector.X, TileVector.Y, Angle);
end;

function TRSMinimap.GetTileMS(Loc: TPoint; Z: Double = 0): TRectangle; overload;
begin
  Result := Self.GetTileMS(Loc, [1, 1, Z]);
end;



function TRSMinimap.GetTilePoly(Loc: TPoint; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TPoly;
var
  Rect: TRectangle;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  Rect := Self.GetTileMS(Loc, [TileVector.Y, TileVector.X, 0], Offset, Angle);

  if TileVector.Z = 0 then
    Result := Rect.ToTPA
  else
    Result := Rect.GetPoly(Self.GetTileMS(Loc, TileVector, Offset, Angle));
end;

function TRSMinimap.GetTilePoly(Loc: TPoint; Z: Double = 0): TPoly; overload;
begin
  Result := Self.GetTilePoly(Loc, [1, 1, Z]);
end;



function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TRectArray;
var
  Loc: TPoint;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  for Loc in LocArray.Sorted(Self.Center) do
    Result += Self.GetTileMS(Loc, TileVector, Offset, Angle);
end;

function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(LocArray, [1, 1, Z]);
end;



function TRSMinimap.GetTileArrayPolys(LocArray: TPointArray; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TPolyArray;
var
  Loc: TPoint;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  for Loc in LocArray do
    Result += Self.GetTilePoly(Loc, TileVector, Offset, Angle);
end;

function TRSMinimap.GetTileArrayPolys(LocArray: TPointArray; Z: Double = 0): TPolyArray; overload;
begin
  Result := Self.GetTileArrayPolys(LocArray, [1, 1, Z]);
end;



//Get a radius in the minimap
function TRSMinimap.GetRadius(Loc: TPoint; Offset: TPoint; Radius: Int32): TCircle;
begin
  if (Self.Center.DistanceTo((Loc - Offset)) - Radius) > 80 then
    Exit; //This means it's impossible the result will be in the minimap.

  Loc := Loc - Offset;
  Result := [Loc.X, Loc.Y, Radius * 4];
end;

function TRSMinimap.GetRadius(Loc: TPoint; Radius: Int32): TCircle; overload;
begin
  Result := Self.GetRadius(Loc, [0, 0], Radius);
end;

//Get several radius in the minimap
function TRSMinimap.GetRadiuses(Locs: TPointArray; Offset: TPoint; Radius: Int32): TCircleArray;
var
  Loc: TPoint;
begin
  for Loc in Locs do
    Result += Self.GetRadius(Loc, Offset, Radius);
end;

function TRSMinimap.GetRadiuses(Loc: TPointArray; Radius: Int32): TCircleArray; overload;
begin
  Result := Self.GetRadiuses(Loc, [0, 0], Radius);
end;



//Get the first dot within a radius.
function TRSMinimap.GetDotInRadius(Dot: ERSMinimapDot; Loc, Offset: TPoint; Radius: Int32): TPoint;
var
  i: Int32;
  Dots: TPointArray;
  Circle: TCircle;
begin
  Dots := Self.GetDots(Dot);

  Dots.Sort(Self.Center);

  Circle := Self.GetRadius(Loc, Offset, Radius);
  for i := 0 to High(Dots) do
    if SRL.PointInCircle(Dots[i], Circle.Mean, Circle.Radius) then
      Exit(Dots[i]);
end;

function TRSMinimap.GetDotInRadius(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32): TPoint; overload;
begin
  Result := Self.GetDotInRadius(Dot, Loc, [0, 0], Radius);
end;

//Get all first dots withing several radius.
function TRSMinimap.GetDotInRadius(Dot: ERSMinimapDot; Locs: TPointArray; Offset: TPoint; Radius: Int32): TPointArray; overload;
var
  Loc: TPoint;
begin
  for Loc in Locs do
    Result += Self.GetDotInRadius(Dot, Loc, Offset, Radius);
end;

function TRSMinimap.GetDotInRadius(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32): TPointArray; overload;
begin
  Result := Self.GetDotInRadius(Dot, Locs, [0, 0], Radius);
end;



//Get all dots within a radius.
function TRSMinimap.GetDotArrayInRadius(Dot: ERSMinimapDot; Loc, Offset: TPoint; Radius: Int32): TPointArray;
var
  i: Int32;
  Dots: TPointArray;
  Circle: TCircle;
begin
  Dots := Self.GetDots(Dot);

  Dots.Sort(Self.Center);

  Circle := Self.GetRadius(Loc, Offset, Radius);
  for i := 0 to High(Dots) do
    if SRL.PointInCircle(Dots[i], Circle.Mean, Circle.Radius) then
      Result += Dots[i];
end;

function TRSMinimap.GetDotArrayInRadius(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32): TPointArray; overload;
begin
  Result := Self.GetDotArrayInRadius(Dot, Loc, [0, 0], Radius);
end;

//Get all dots within several radius.
function TRSMinimap.GetDotArrayInRadiuses(Dot: ERSMinimapDot; Locs: TPointArray; Offset: TPoint; Radius: Int32): TPointArray;
var
  i: Int32;
  ATPA: T2DPointArray;
begin
  for i := 0 to High(Locs) do
    ATPA += Self.GetDotArrayInRadius(Dot, Locs[i], Offset, Radius);

  Result := ATPA.Merge;

  Result.Sort(Self.Center);
end;

function TRSMinimap.GetDotArrayInRadiuses(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32): TPointArray; overload;
begin
  Result := Self.GetDotArrayInRadiuses(Dot, Locs, [0, 0], Radius);
end;


//Get the closest dot tile within a radius
function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectangle;
begin
  Result := Self.GetTileMS(
              Self.GetDotInRadius(Dot, Loc, RadiusOffset, Radius),
              TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Z: Double = 0): TRectangle; overload;
begin
  Result := Self.GetDotTileMS(Dot, Loc, Radius, [1, 1, Z]);
end;


//Get the closest dot tile within several radius
function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetDotInRadius(Dot, Locs, RadiusOffset, Radius),
                                TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotTileMS(Dot, Locs, Radius, [1, 1, Z]);
end;


//Get all dot tiles within a radius
function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectArray;
begin
  Result := Self.GetTileArrayMS(
                  Self.GetDotArrayInRadius(Dot, Loc, RadiusOffset, Radius),
                  TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotArrayTilesMS(Dot, Loc, Radius, [1, 1, Z]);
end;


//Get all dot tiles within several radius
function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(
                  Self.GetDotArrayInRadiuses(Dot, Locs, RadiusOffset, Radius),
                  TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotArrayTilesMS(Dot, Locs, Radius, [1, 1, Z]);
end;


