{$DEFINE WL_NPC_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TRSNPC = record
    Map: TRSWalker;
    Tile: TPoint;
    WanderRadius: Int32;
    Height: Int32;
    UpText: TStringArray;
    Finder: TRSObjectFinder;
  end;

  TRSNPCArray = array of TRSNPC;

{$I walker/worldnpc.simba}
{$I walker/zeahnpc.simba}

function TRSNPC.Find: T2DPointArray;
var
  MMTile: TPoint;
  Dot: TPoint;
  Dots: TPointArray;
  FilteredDots: TPointArray;
  Rect: TRectangle;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
  i: Int32;
begin
  MMTile := Map.WorldToMM(Tile);
  if not Minimap.IsPointOn(MMTile, WanderRadius) then
    Exit;

  Dots := Minimap.GetDots(ERSMinimapDot.NPC);

  for Dot in Dots do
    if SRL.PointInCircle(Dot, MMTile, WanderRadius * 5) then
      FilteredDots += Dot;

  if FilteredDots = [] then
    Exit;

  for Dot in FilteredDots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    B := TPA.Bounds;
    if InterfaceArea.Bounds.Contains(Rect) then
      Result += MainScreen.FindObject(Finder, B);

    for i := 0 to High(Result) do
      Result[i] := Rect.Filter(Result[i]);
  end;

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

function TRSNPC.BlindFind(Height: Int32 = 6): T2DPointArray;
var
  Dot: TPoint;
  Dots: TPointArray;
  Rect: TRectangle;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  Points: TPointArray;
begin
  Dots := Minimap.GetDots(ERSMinimapDot.NPC);
  if Dots = [] then
    Exit;

  for Dot in Dots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      Points := Rect.ToTPA();
      Points.Fill;
      Result += Points;
    end;
  end;
end;

procedure TRSNPC.SetupCommon(Walker: TRSWalker; Radius: Int32 = 1; NPCHeight: Int32 = 6);
begin
  Map := Walker;
  WanderRadius := Radius;
  Height := NPCHeight;
  Finder.ClusterDistance := 3;
  Finder.Erode := 2;
  Finder.Grow := 4;
end;

procedure TRSNPC.Debug;
var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  MMTile: TPoint;
  Dot: TPoint;
  Dots: TPointArray;
  FilteredDots: TPointArray;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
  NPC: T2DPointArray;
  i: Int32;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  //Debug tile
  Rect := Map.GetTileMS(Tile);
  Bitmap.DrawRect(Rect, $ffffff);

  //Debug NPC
  MMTile := Map.WorldToMM(Tile);
  if not Minimap.IsPointOn(MMTile, WanderRadius) then
  begin
    Bitmap.Free;
    Exit;
  end;

  Dots := Minimap.GetDots(ERSMinimapDot.NPC);

  for Dot in Dots do
    if SRL.PointInCircle(Dot, MMTile, WanderRadius * 5) then
      FilteredDots += Dot;

  if FilteredDots = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  for Dot in FilteredDots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;
    Bitmap.DrawRect(Rect, $ffffff);

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      Bitmap.DrawRect(Rect, $ffffff);
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    Bitmap.DrawRect(Rect, $0000ff);
    B := TPA.Bounds;
    if InterfaceArea.Bounds.Contains(Rect) then
      NPC += MainScreen.FindObject(Finder, B);

    for i := 0 to High(NPC) do
      NPC[i] := Rect.Filter(NPC[i]);
  end;

  if NPC = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  NPC.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(NPC);
  Bitmap.DrawTPA(NPC[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;

procedure TRSNPC.DebugBlind(Height: Int32 = 6);
var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  Dot: TPoint;
  Dots: TPointArray;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  NPC: T2DPointArray;
  Points: TPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  //Debug tile
  Rect := Map.GetTileMS(Tile);
  Bitmap.DrawRect(Rect, $ffffff);

  //Debug NPC
  Dots := Minimap.GetDots(ERSMinimapDot.NPC);

  if Dots = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  for Dot in Dots do
  begin
    Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
    HighTPA := Rect.ToTPA;
    Bitmap.DrawRect(Rect, $ffffff);

    if Height > 0 then
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
      LowTPA := Rect.ToTPA;
      Bitmap.DrawRect(Rect, $ffffff);
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    Bitmap.DrawRect(Rect, $0000ff);
    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      Points := Rect.ToTPA();
      Points.Fill;
      NPC += Points;
    end;
  end;

  if NPC = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  NPC.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(NPC);
  Bitmap.DrawTPA(NPC[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;



// HoverHelper function used by all non moving npc's hovering functions.
function TRSWalker.HoverHelper(RSNPC: TRSNPC; Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if MainScreen.IsUpText(RSNPC.UpText) then
      Exit(True);

    if (ATPA := RSNPC.Find) <> [] then
    begin
      Points := ATPA[Random(0, High(ATPA))];
      Mouse.Move(Points.MinAreaRect);
    end;

    if MainScreen.IsUpText(RSNPC.UpText) then
      Exit(True);

    if Attempt = (Attempts - 1) then
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// WalkHoverHelper function used by all moving npc's hovering functions.
function TRSWalker.WalkHoverHelper(RSNPC: TRSNPC; Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if MainScreen.IsUpText(RSNPC.UpText) then
      Exit(True);

    if (ATPA := RSNPC.Find) <> [] then
    begin
      Points := ATPA[Random(0, High(ATPA))];
      Mouse.Move(Points.MinAreaRect);
    end;

    if MainScreen.IsUpText(RSNPC.UpText) then
      Exit(True)
    else if not Self.AtTile(RSNPC.Tile, 50) or ((Attempt = (Attempts - 1)) and not Self.AtTile(RSNPC.Tile, 30)) then
      Self.WebWalk(RSNPC.Tile, 10, 0.2)
    else
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;




// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSWalker.HoverRSNPC(RSNPC: TRSNPC; Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(RSNPC.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Self.MakeTileVisible(RSNPC.Tile) then
    Exit(False);

  Result := Self.HoverHelper(RSNPC, Attempts);
end;

// Searches for an object with ObjectFinder and HoverRSObject and clicks it if found.
function TRSWalker.ClickRSNPC(RSNPC: TRSNPC; LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSNPC(RSNPC, Attempts) and
            Self.ClickHelper(RSNPC.UpText, LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSWalker.SelectRSNPCOption(RSNPC: TRSNPC; Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSNPC(RSNPC, Attempts) and
            Self.SelectHelper(Action, RSNPC.UpText);
end;



// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSWalker.WalkHoverRSNPC(RSNPC: TRSNPC; Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(RSNPC.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Self.MakeTileVisible(RSNPC.Tile) then
    if not Self.WebWalk(RSNPC.Tile, 30, 0.2) then
      Exit(False);

  Result := Self.WalkHoverHelper(RSNPC, Attempts);
end;

// Searches for an object with ObjectFinder and WalkHoverRSObject and clicks it if found.
function TRSWalker.WalkClickRSNPC(RSNPC: TRSNPC; LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSNPC(RSNPC, Attempts) and
            Self.ClickHelper(RSNPC.UpText, LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSWalker.WalkSelectRSNPCOption(RSNPC: TRSNPC; Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSNPC(RSNPC, Attempts) and
            Self.SelectHelper(Action, RSNPC.UpText);
end;








procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  case Map.Lower() of
    'world': WorldNPCs.Load(Self);
    'zeah': ZeahNPCs.Load(Self);
  end;
end;

procedure TRSWalker.Setup(Map: String; Offset: TPoint; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  if Map.Contains('world') then
    WorldNPCs.Load(Self)
  else if Map.Contains('zeah') then
    ZeahNPCs.Load(Self);
end;
