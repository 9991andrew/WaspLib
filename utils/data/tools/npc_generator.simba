(*
NPC Generator
=============

This is tool used to generate npc.json and takes a few minutes to complete.
It has 3 phases, you can see the progress in Simba's output.

npc.json is a json of all publicly available non combat npcs.
This data has been provided by a JMod from what I was told. So it might be outdated and never updated again.
It could also disappear someday so if you want to make sure it doesn't consider hosting it yourself.
The **NPC_DATA_URL** const has the link to the original data I used. You can switch the link to another one but if the json has a
different structure you will need to update this file to work with it.
*)

(*
Phase1
~~~~~~

In this phase we will fetch the raw json file that contains all NPC data and with it we are going to clean the data up a little
for our use case generating a temporary file named npc-raw.json.

This file will contain an entry for every NPC even the ones with the same name.
*)
const
  NPC_DATA_URL = 'https://raw.githubusercontent.com/mejrs/data_osrs/682acd0ed9968c000a260a8f852e7bbe489f2f48/NPCList_OSRS.json';

procedure Phase1();
const
  PATH = IncludePath + 'WaspLib\utils\data\tools\';
var
  DataStr: String;
  Data, TempType, TempPos, TempPosSet: TJSONArray;
  CurrentNPC, TempNPC, FinalNPC: TJSONObject;
  id, combat, x, y, z, size, i, DataLength: int32;
  Str, CleanStr: String;
begin
  DataStr := GetPage(NPC_DATA_URL);
  Data.Init(DataStr);

  DataLength := Data.length - 1;
  DeleteFile(PATH + 'npc-raw.json');
  WriteFileContents(PATH + 'npc-raw.json', '[' + LineEnding, True);

  for i := 0 to DataLength do
  begin
    if (I mod 100 = 0) or (i=DataLength) then
      WriteLn('Phase1: ', i, ' of ', DataLength, ' done.');
    CurrentNPC := Data.getJSONObject(i);
    FinalNPC.Init();
    TempPosSet.Init();
    TempPos.Init();
    TempNPC.Init();
    TempType.Init();

    Str := '';
    combat := 0;

    if not CurrentNPC.isNull('name') then
    begin
      Str := CurrentNPC.getString('name').ToLower();
      combat := CurrentNPC.optInt('combatLevel', 0);
      if not CurrentNPC.isNull('isInteractable') and not CurrentNPC.getBoolean('isInteractable') then
        combat := 100; //just so we filter this one out lol.
    end;

    if (Str <> '') and (combat = 0) then
    begin
      FinalNPC.put('name', Str);

      id := CurrentNPC.getInt('id');

      size := CurrentNPC.optInt('size', 1);

      x := CurrentNPC.getInt('x') * 4 - 4608;   //The data provided has the X position offset by 4608.
      y := 50429 - CurrentNPC.getInt('y') * 4;  //The data provided Y position starts from the bottom of the map and it's also offset
      z := CurrentNPC.GetInt('p');              //so we subtract Y position from the map total height and the offset.

      TempPosSet.put(0, x);
      TempPosSet.put(1, y);
      TempPosSet.put(2, z);
      TempPos.put(0, TempPosSet);

      TempNPC.put('id', id);
      TempNPC.put('size', size);
      TempNPC.put('position', TempPos);
      TempType.put(0, TempNPC);

      FinalNPC.put('type', TempType);

      CleanStr := FinalNPC.toString(1).Replace('\u0020', ' ').Replace('\u003Ccol\u003Dff9040\u003E', '').Replace('\u003C\/col\u003E', '');
      CleanStr := CleanStr.Replace('\u003Ccol\u003D00ffff\u003E', '');
      if i < DataLength then
        CleanStr += ',' + LineEnding;

      WriteFileContents(PATH + 'npc-raw.json', CleanStr, True);
    end;
    FinalNPC.Free();
  end;

  WriteFileContents(PATH + 'npc-raw.json', ']', True);
  Data.Free();
end;

(*
Phase2
~~~~~~

In this phase we will load the previous generated npc-raw.json and join all NPCs with the same name into a single one
that contains an array of each "type" which is each npc "id". At this point you might still have several entries for the same "id".

This will also create another temporary file named npc-temp.json and when finished will delete npc-raw.json.
*)
procedure Phase2();
const
  PATH = IncludePath + 'WaspLib\utils\data\tools\';
var
  Data: TJSONArray;
  CurrentNPC, TempNPC: TJSONObject;
  KeysDone: TStringArray;
  i, j, DataLength: int32;
  Str, CleanStr: String;
begin
  Data.Init(ReadFileContents(PATH + 'npc-raw.json'));

  DataLength := Data.length - 1;
  DeleteFile(PATH + 'npc-temp.json');
  WriteFileContents(PATH + 'npc-temp.json', '[' + LineEnding, True);

  for i := 0 to DataLength do
  begin
    if (I mod 100 = 0) or (i=DataLength) then
      WriteLn('Phase2: ', i, ' of ', DataLength, ' done.');
    CurrentNPC := Data.getJSONObject(i);
    Str := CurrentNPC.getString("name");

    if KeysDone.Contains(Str) then //if we already done this object skip it.
      Continue;

    for j := (i+1) to DataLength do
    begin
      TempNPC := Data.getJSONObject(j);
      if Str = TempNPC.getString("name") then
        CurrentNPC.getJSONArray("type").put(TempNPC.getJSONArray("type").get(0));
    end;

    KeysDone += Str;

    CleanStr := CurrentNPC.toString(1).Replace('\u0020', ' ');

    if i < DataLength then
      CleanStr += ',' + LineEnding;

    WriteFileContents(PATH + 'npc-temp.json', CleanStr, True);
  end;

  WriteFileContents(PATH + 'npc-temp.json', ']', True);
  DeleteFile(PATH + 'npc-raw.json');
end;

(*
Phase3
~~~~~~

In this phase we will load the previous generated npc-temp.json and join all NPCs with the same "id" into a single one,
merging their positions into an array of positions.

This will create the final file named npc.json and when finished will delete npc-temp.json.
*)
procedure Phase3();
const
  PATH = IncludePath + 'WaspLib\utils\data\';
var
  Data, FinalData, InnerData: TJSONArray;
  OuterObj, CurrentObj, TempObj, TempOuterObj: TJSONObject;
  KeysDone: TIntegerArray;
  CurrentID, i, j, l, MainDataLength, InnerDataLength: int32;
  CleanStr: String;
begin
  Data.Init(ReadFileContents(PATH + 'tools\npc-temp.json'));
  TempOuterObj.Init();
  AddOnTerminate(@Data.Free);

  MainDataLength := Data.length - 1;
  DeleteFile(PATH + 'npcs.json');

  for i := 0 to MainDataLength do
  begin
    if (I mod 100 = 0) or (i=MainDataLength) then
      WriteLn('Phase3: ', i, ' of ', MainDataLength, ' done.');

    TempOuterObj.Init();
    FinalData.Init();
    OuterObj := Data.getJSONObject(i);
    InnerData := OuterObj.getJSONArray("type");
    InnerDataLength := InnerData.length - 1;

    for j := 0 to InnerDataLength do
    begin
      CurrentObj := InnerData.getJSONObject(j);
      CurrentID := CurrentObj.getInt("id");

      if KeysDone.Contains(CurrentID) then //if we already done this object skip it.
        Continue;

      for l := (j+1) to InnerDataLength do
      begin
        TempObj := InnerData.getJSONObject(l);
        if CurrentID = TempObj.getInt("id") then
          CurrentObj.getJSONArray("position").put(TempObj.getJSONArray("position").get(0));
      end;

      KeysDone += CurrentID;

      FinalData.put(CurrentObj);
    end;

    TempOuterObj.putOpt(OuterObj.getString('name'), FinalData);

    CleanStr := TempOuterObj.toString(1).Replace('\u0020', ' ');
    CleanStr := CleanStr.Replace(#10'  "','"').Replace(#10'   ','');
    CleanStr := CleanStr.Replace(', ',',').Replace(#10'  ','').Replace(#10' }', '}');
    CleanStr := CleanStr.Replace('[ ', '[');
    CleanStr := CleanStr.Replace('[{','['#10' {').Replace(#10' "','"').Replace(#10' ]',']');
    CleanStr := CleanStr.Replace(#10'}]}','}'#10']}');

    if i < MainDataLength then
      CleanStr += ',' + LineEnding;

    WriteFileContents(PATH + 'npcs.json', CleanStr, True);

    TempOuterObj.Remove(OuterObj.getString('name'));
    TempOuterObj.clean;
    FinalData.Free();
  end;

  TempOuterObj.Free();
  DeleteFile(PATH + 'tools\npc-temp.json');
end;

begin
  Phase1();
  Phase2();
  Phase3();
end;
