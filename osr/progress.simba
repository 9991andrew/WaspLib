{$DEFINE WL_PROGRESS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
var PadLength
~~~~~~~~~~~~~
Internal variable used to set control the PadLength in the progress report. This is usually set by `TBaseScript.BuildTextReport()`.

var PTimeRunning
~~~~~~~~~~~~~~~~
Internal StopWatch pointer to the TBaseScript.TimeRunning. This is required so antiban tasks/breaks/sleeps can modify TWaspProgressReport.

var ProgressArray
~~~~~~~~~~~~~~~~~
TODO: ADD INFO. Forgot what this was for exactly but something to do with antiban tasks same as above.
*)
var
  PadLength: Int32;
  PTimeRunning: ^TStopwatch;
  ProgressArray: TStringArray;

(*
type THoverButton
~~~~~~~~~~~~~~~~~

Type used to represent an "HoverButton". An HoverButton is drawn button that is enabled by hovering it and disabled by moving the mouse away from it.
*)
type
  THoverButton = record
    Bounds: TBox;

    Color: Integer;
    Border: Integer;

    Enabled: Boolean;
  end;

(*
HoverButton.Setup
~~~~~~~~~~~~~~~~~
.. pascal:: procedure THoverButton.Setup(Bounds: TBox; Color: Integer = $292929; Border: Integer = $178FEC);

Internal method used to setup the hover button.
*)
procedure THoverButton.Setup(Bounds: TBox; Color: Integer = $292929; Border: Integer = $178FEC);
begin
  Self.Bounds := Bounds;
  Self.Color := Color;
  Self.Border := Border;
end;

(*
HoverButton.IsHovered
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function THoverButton.IsHovered(P: TPoint): Boolean;

Method used to check if **P** is within the THoverButton.Bounds.
**P** usually would be your mouse position.
The mouse position is not checked within the function on purpose, that we can check multiple HoverButtons with a single MousePosition check.

Example
-------

  MousePos: Mouse.Position;

  HoverBtn1.IsHover(MousePos);
  HoverBtn2.IsHover(MousePos);
  HoverBtn3.IsHover(MousePos);
  HoverBtn4.IsHover(MousePos);
*)
function THoverButton.IsHovered(P: TPoint): Boolean;
begin
  Result := Self.Enabled := Self.Bounds.Contains(P);
end;

(*
HoverButton.Draw
~~~~~~~~~~~~~~~~
.. pascal:: procedure THoverButton.Draw(Bitmap: TMufasaBitmap; Str: String = '');

Draw the hover button on **Bitmap**. Optionally, text can be drawn on it too.
*)
procedure THoverButton.Draw(Bitmap: TMufasaBitmap; Str: String = '');
begin
  if Self.Color > -1 then
    Bitmap.DrawBoxFilled(Self.Bounds, Self.Color);
  if Self.Border > -1 then
    Bitmap.DrawBox(Self.Bounds, Self.Border);

  if Str <> '' then
    Bitmap.DrawTextShadow(Str, [Self.Bounds.X1 + Round(Self.Bounds.Width()/4), Self.Bounds.Y1 + Round(Self.Bounds.Height()/5)], $006CFF, False);
end;

(*
type TWaspProgressReport
~~~~~~~~~~~~~~~~~~~~~~~~

Type responsible for handling the HUDProgressReport, also commonly called as "Paint" or InGame/OnScreen Progress Report.
*)
type
  TWaspProgressReport = record
    BGImg: TMufasaBitmap;
    ClientImg: TMufasaBitmap;

    TextColor: Int32;
    PreviousStrArray: TStringArray;

    Timer: TTimer;
    UsernameBox: TBox;
    DisableButton: THoverButton;

    Terminated: Boolean;
    IsSetup: Boolean;
  end;

(*
ProgressReport.GetNextCycleColor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TWaspProgressReport.GetNextCycleColor(Color, Step: Int32): Int32;

Not currently used for anything, just a fun experiment. Can be used to give an RGB cycle effect.
You can see it in effect by uncommenting `Self.TextColor := Self.GetNextCycleColor(Self.TextColor, 10);` in **TWaspProgressReport.Update()**.
*)
function TWaspProgressReport.GetNextCycleColor(Color, Step: Int32): Int32;
var
  R, G, B: Int32;
begin
  ColorToRGB(Color, R, G, B);

  if (R = 255) and (G = 0) and (B < 255) then
    B += Step
  else if (R > 0)   and (G = 0)   and (B = 255) then
    R -= Step
  else if (R = 0)   and (G < 255) and (B = 255) then
    G += Step
  else if (R = 0)   and (G = 255) and (B > 0) then
    B -= Step
  else if (R < 255) and (G = 255) and (B = 0) then
    R += Step
  else if (R = 255) and (G > 0)   and (B = 0) then
    G -= Step;

  if R < 0    then R := 0;
  if R > 255 then R := 255;

  if G < 0    then G := 0;
  if G > 255 then G := 255;

  if B < 0    then B := 0;
  if B > 255 then B := 255;

  writeLn('R: ', R, ' G: ', G, ' B: ', B);
  Result := RGBtoColor(R, G, B);
end;

(*
ProgressReport.Terminate
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.Terminate();

Internal method called automatically on termination. This will do things such as free used assetsa and clear the progress report from the game screen.
*)
procedure TWaspProgressReport.Terminate();
begin
  if Self.Terminated then //avoids multiple terminations in case the script is chained.
    Exit;

  Self.BGImg.Clear();
  Self.BGImg.Free();

  Self.ClientImg.Clear();
  Self.ClientImg.Free(); //not sure if it needs to be freed?

  Self.Terminated := True; //avoids multiple terminations in case the script is chained.
end;

(*
ProgressReport.Setup
~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.Setup();

Internal method called when we need to setup TWaspProgressReport.
*)
procedure TWaspProgressReport.Setup();
var
  B: TBox;
begin
  Self.BGImg := TMufasaBitmap.Create();
  Self.BGImg.Clear();
  Self.BGImg.LoadFromFile({$MACRO CURRENT_DIRECTORY} + 'WaspProgress.png');
  Self.BGImg.setFontAntialiasing(True);

  Self.ClientImg := RSClient.Image;
  Self.ClientImg.Clear();
  Self.ClientImg.setFontAntialiasing(True);
  Self.ClientImg.setFontSize(13);

  {$IFDEF WINDOWS}
  Self.BGImg.setFontName('Courier New');      //It's hard to guess which fonts a Linux distro has available beforehand so I only set the font for windows.
  Self.ClientImg.setFontName('Courier New');
  {$ENDIF}

  Self.TextColor := $006CFF;

  Self.UsernameBox := Chat.GetDisplayNameBox();
  B := Chat.GetLineBoxes()[CHAT_INPUT_LINE];
  B.X1 := B.X2 - Round(B.Width()/8);
  B.X2 := Chat.Bounds.X2 - 5;

  Self.DisableButton.Setup(B);

  AddOnTerminate(@Self.Terminate);
end;

(*
ProgressReport.DrawBackground
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.Setup();

Method that handles drawing the background of our TWaspProgressReport.
Usually called internally by TWaspProgressReport.Update().
*)
procedure TWaspProgressReport.DrawBackground(StrArray: TStringArray; FontColor: Int32);
var
  P: TPoint;
begin
  if not Self.IsSetup then
  begin
    P := [10, 15];

    Self.BGImg.setFontSize(18);
    Self.BGImg.DrawTextShadow(StrArray[0], P, FontColor, False);

    Self.BGImg.setFontSize(14);
    P.Y += 105;
    FontColor -= $90A301 - $C8D100;
    Self.BGImg.DrawText(StrArray[4], P, FontColor);

    Self.IsSetup := True;
  end;

  Self.ClientImg.DrawBitmap(Self.BGImg, [Chat.Bounds.X1, Chat.Bounds.Y1]);
  Self.DisableButton.Draw(Self.ClientImg, 'Hide');
end;

(*
ProgressReport.DrawProgress
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.DrawProgress(StrArray: TStringArray; FontColor: Int32);

Method that handles drawing the text of our TWaspProgressReport.
Usually called internally by TWaspProgressReport.Update().
*)
procedure TWaspProgressReport.DrawProgress(StrArray: TStringArray; FontColor: Int32);
var
  P: TPoint;
  i: Int32;
begin
  P := [Chat.Bounds.X1 + 10, Chat.Bounds.Y1 + 50];

  FontColor -= $C8D100;

  for i := 1 to 3 do
  begin
    if i > High(StrArray) then
      Break;

    Self.ClientImg.DrawTextShadow(StrArray[i], P, FontColor, False);
    P.Y += 20;
  end;

  Self.PreviousStrArray := StrArray;
end;

(*
ProgressReport.HideProgress
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.HideProgress();

Used to hide TWaspProgressReport.
Usually called internally by TWaspProgressReport.Update().
*)
procedure TWaspProgressReport.HideProgress();
begin
  Self.IsSetup := False;

  Self.ClientImg.DrawBoxFilled(Self.UsernameBox, $819DAC); //Hide username by painting a box with similar color to the chatbox background.
  Self.DisableButton.Draw(Self.ClientImg, 'Show');
end;

(*
ProgressReport.Update
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.Update(StrArray: TStringArray);

Main method that should be called to used to start and update TWaspProgressReport.

To see TWaspProgressReport.GetNextCycleColor() in action, which was just a fun experiment,
uncomment `Self.TextColor := Self.GetNextCycleColor(Self.TextColor, 10);`
*)
procedure TWaspProgressReport.Update(StrArray: TStringArray);
begin
  Self.ClientImg.Clear();

  if Self.DisableButton.Enabled then
  begin
    if Self.IsSetup then
      Self.HideProgress();
    Exit;
  end;

  if StrArray = [] then
    Exit;

  //Self.TextColor := Self.GetNextCycleColor(Self.TextColor, 10);
  Self.DrawBackground(StrArray, Self.TextColor);
  Self.DrawProgress(StrArray, Self.TextColor);
end;

(*
ProgressReport.CheckButtons
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.CheckButtons(Sender: TObject);

Internal method run automatically with TWaspProgressReport.Timer.
This is used to check if the mouse is currently hovering any hover button.
*)
{$H-}
procedure TWaspProgressReport.CheckButtons(Sender: TObject);
var
  MousePos: TPoint;
begin
  try
    {$IFNDEF SRL_DISABLE_REMOTEINPUT}
    EIOS_GetRealMousePosition(RSClient.RemoteInput.EIOS, MousePos.X, MousePos.Y);
    {$ENDIF}
    Self.DisableButton.IsHovered(MousePos);

    if (Self.DisableButton.Enabled and Self.IsSetup) or (not Self.DisableButton.Enabled and not Self.IsSetup) then
      Self.Update(Self.PreviousStrArray);
  except
    WriteLn(GetExceptionMessage());
  end;
end;

{$H+}

(*
ProgressReport.StartTimer
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.StartTimer(Sender: TObject);

Required wrapper method so we can sync the timer.
*)
procedure TWaspProgressReport.StartTimer;
begin
  Self.Timer.Init(nil);
  Self.Timer.SetInterval(1000);
  Self.Timer.SetOnTimer(@Self.CheckButtons);
  Self.Timer.SetEnabled(True);
  AddOnTerminate(@Self.Timer.Free);
end;

(*
ProgressReport.Setup
~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspProgressReport.Setup(); override;

Overriden method to enable TWaspProgressReport.Timer.
This required to be overriden or we couldn't call already declared methods in ProgressReport.CheckButton().
*)
procedure TWaspProgressReport.Setup(); override;
begin
  inherited;

  {$IFNDEF SRL_DISABLE_REMOTEINPUT}
  if not OutputReportEnabled and not ProgressReportEnabled then
  {$ENDIF}
    Exit;

  Sync(@Self.StartTimer);
end;

(*
var ProgressReport
~~~~~~~~~~~~~~~~~~

Global TWaspProgressReport variable.
*)
var
  ProgressReport: TWaspProgressReport;
