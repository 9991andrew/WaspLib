(*
Minimap
=======
Methods to handle Minimap. Extends SRL's Minimap.
*)

{$DEFINE WL_MINIMAP_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
Minimap.WaitMoving
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMinimap.WaitMoving(DoAntiban: Boolean = True);

Gives **Minimap.WaitPlayerMoving** the ability to perform antiban tasks while moving.

Example
-------

  Minimap.WaitMoving;
*)
procedure TRSMinimap.WaitMoving(DoAntiban: Boolean = True);
var
  Timeout, Countdown: TCountDown;
  Moving: Boolean;
begin
  Timeout.Init(Round(SRL.TruncatedGauss(20000, 25000)));

  Countdown.Init(Round(SRL.TruncatedGauss(500, 1500)));
  Countdown.Timeout := GetTickCount + Round(SRL.TruncatedGauss(2500, 3500));

  repeat
    //Self.CheckRunEnergy();

    if DoAntiban then
      Antiban.WaitMovingTasks;

    Moving := Minimap.IsPlayerMoving;

    if Moving then Countdown.Restart;

  until Timeout.IsFinished or Countdown.IsFinished or not Minimap.HasFlag or not Moving;
end;

(*
Minimap.GetOrbLevel
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetOrbLevel(Orb: TCircle): Int32; override;

Override to fix SRL's **Minimap.GetOrbLevel**. Should add it to SRL in the future.

Example
-------

  WriteLn Minimap.GetOrbLevel(Minimap.GetHPCircle);
*)
function TRSMinimap.GetOrbLevel(Orb: TCircle): Int32; override;
begin
  Result := OCR.RecognizeNumber([Orb.X-35, Orb.Y-1, Orb.X-15, Orb.Y+9], TOCRShadowRule.Create(), RS_FONT_PLAIN_11);
end;

(*
Minimap.GetSpecLevel
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMinimap.GetSpecLevel: Int32;

**Minimap.GetSpecLevel** is used to retrieve the special attack level from the minimap orb.

Example
-------

  Writeln Minimap.GetSpecLevel;
*)
function TRSMinimap.GetSpecLevel: Int32;
begin
  Result := Self.GetOrbLevel(Self.GetSpecAttackCircle);
end;

(*
Minimap.IsSpecEnabled
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.IsSpecEnabled;

**Minimap.IsSpecEnabled** returns true if the special attack is enabled.

Example
-------

  Writeln Minimap.IsSpecEnabled;
*)
function TRSMinimap.IsSpecEnabled: Boolean;
begin
  Result := SRL.CountColor(CTS2(8682326, 16, 0.03, 1.15), Self.GetSpecAttackCircle.Bounds) > 1;
end;

(*
Minimap.IsSpecWeapon
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.IsSpecWeapon;

**Minimap.IsSpecWeapon** returns true if the current weapon has a special attack.
Returns false if the special attack level is at 0 or if the weapon doesn't have a special attack.

Example
-------

  Writeln Minimap.IsSpecWeapon;
*)
function TRSMinimap.IsSpecWeapon: Boolean;
begin
  Result := ((SRL.CountColor(CTS2(8480786, 19, 0.05, 1.36), Self.GetSpecAttackCircle.Bounds) > 0) or
            Self.IsSpecEnabled);
end;

(*
Minimap.EnableSpec
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.EnableSpec(MinSpec: Int32): Boolean;

**Minimap.EnableSpec** attempts to enable the special attack if we have at leas **MinSpec** special attack level.

Example
-------

  Minimap.EnableSpec(25);
*)
function TRSMinimap.EnableSpec(MinSpec: Int32): Boolean;
var
  T: UInt64;
begin
  if not Self.IsSpecWeapon or (Self.GetSpecLevel < MinSpec) then
    Exit(False);

  Result := Self.IsSpecEnabled;
  if not Result then
  begin
    Mouse.Click(Self.GetSpecAttackCircle, MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if Self.IsSpecEnabled() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;

(*
Minimap.DisableSpec
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.DisableSpec;

**Minimap.DisableSpec** attempts to disable the special attack.

Example
-------

  Minimap.DisableSpec;
*)
function TRSMinimap.DisableSpec: Boolean;
var
  T: UInt64;
begin
  Result := not Self.IsSpecEnabled;

  if Result then
  begin
    Mouse.Click(Self.GetSpecAttackCircle, MOUSE_LEFT);

    T := GetTickCount() + Round(SRL.TruncatedGauss(1000, 2000));
    while (T > GetTickCount()) do
    begin
      if not Self.IsSpecEnabled() then
        Exit(True);

      Wait(0, 1000, wdLeft);
    end;
  end;
end;

(*
Minimap.HasStamina
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.HasStamina;

**Minimap.HasStamina** returns true if we are stamina boosted.

Example
-------

  WriteLn Minimap.HasStamina;
*)
function TRSMinimap.HasStamina: Boolean;
begin
  Result := SRL.CountColor(CTS0(2709951, 38), Self.GetRunCircle.Bounds) > 0;
end;

(*
Minimap.OnGroundLevel
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.OnGroundLevel;

**Minimap.OnGroundLevel** returns true if we are likely to be on the ground level.
This works by counting the amount of black in the minimap and might give false positives/negatives if there's more than 3500 black pixels on the minimap.
Example
-------

  WriteLn Minimap.OnGroundLevel;
*)
function TRSMinimap.OnGroundLevel: Boolean;
begin
  Result := SRL.CountColor(0, Minimap.Bounds) > 3500;
end;


(*
Minimap.InPOH
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.InPOH;

**Minimap.InPOH** returns true if we are in a POH.
This might give false positives if you are upstairs or in a place with few colors on the minimap.
It might also give false negatives if the POH is crowded.

Example
-------

  WriteLn Minimap.InPOH;
*)
function TRSMinimap.InPOH: Boolean;
var
  TPA: TPointArray;
  ColorArray: TIntegerArray;
  BlackAmount: Int32;
  ColorAmount: Int32;
begin
  TPA := Self.GetPolygon.Connect;
  TPA.Fill;
  TPA := TPA.Erode(10);

  ColorArray := GetColors(TPA);
  BlackAmount := Length(ColorArray.FindAll(0));

  ClearSameIntegers(ColorArray);

  ColorAmount := Length(ColorArray);
  Result := (ColorAmount > 3) and (ColorAmount < 25) and (BlackAmount < 3500);
end;




















