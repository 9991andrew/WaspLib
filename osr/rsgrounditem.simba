{$DEFINE WL_RSGROUNDITEM_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  PRSGroundItem = ^TRSGroundItem;

  TRSGroundItem = record
    Map: PRSWalker;
    Tile: TPoint;
    RadiusCheck: Int32;
    Height: Int32; //Possibly always 0
    Finder: TRSObjectFinder;
    UpText: TStringArray;

    ItemArray: TRSItemArray; //Array because coins, arrows bolts, have multiple ids.
    GEValue: Int32;
    StoreValue: Int32;
    LowAlch: Int32;
    HighAlch: Int32;

    Filter: record
      Walker: Boolean;
      Finder: Boolean;
      UpText: Boolean;
    end;
  end;

  TRSGroundItemArray = array of TRSGroundItem;

procedure TRSGroundItem.SetupCommon(Radius: Int32 = 2; ItemHeight: Int32 = 0);
begin
  RadiusCheck := Radius;
  Height := ItemHeight;
  Finder.ClusterDistance := 3;
  Finder.Erode := 2;
  Finder.Grow := 4;

  Filter.Walker := True;
  Filter.Finder := True;
  Filter.UpText := True;
end;

{$I rsgrounditems.simba}

function TRSGroundItem.Find: T2DPointArray;
  function GetTilesRects: TRectArray;
  var
    MMTile: TPoint := Map^.WorldToMM(Tile);
    Dot: TPoint;
    Dots: TPointArray;
    FilteredDots: TPointArray;
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    if not Minimap.IsPointOn(MMTile, RadiusCheck) then
      Exit;

    Dots := Minimap.GetDots(ERSMinimapDot.ITEM);

    for Dot in Dots do
      if SRL.PointInCircle(Dot, MMTile, RadiusCheck * 5) then
        FilteredDots += Dot;

    if FilteredDots = [] then
      Exit;

    for Dot in FilteredDots do
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Result += Rect;
    end;
  end;

var
  Rect: TRectangle;
  Rects: TRectArray;
  B: TBox;
  TPA: TPointArray;
  NPCFinder: TRSObjectFinder;
begin

  if Filter.Walker then
  begin
    Rects := GetTilesRects;
    if Filter.Finder then
    begin
      NPCFinder := Finder;
      NPCFinder.MinLongSide := 0;
      NPCFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(NPCFinder, B).Merge;
          Result += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          Result += TPA;
        end;
      end;
    end;
  end

  else if Filter.Finder then
    Result := MainScreen.FindObject(Finder);

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

procedure TRSGroundItem.Debug;
  function GetTilesRects(out Bitmap: TMufasaBitmap): TRectArray;
  var
    MMTile: TPoint := Map^.WorldToMM(Tile);
    Dot: TPoint;
    Dots: TPointArray;
    FilteredDots: TPointArray;
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    if not Minimap.IsPointOn(MMTile, RadiusCheck) then
      Exit;

    Dots := Minimap.GetDots(ERSMinimapDot.ITEM);

    for Dot in Dots do
      if SRL.PointInCircle(Dot, MMTile, RadiusCheck * 5) then
        FilteredDots += Dot;

    if FilteredDots = [] then
      Exit;

    for Dot in FilteredDots do
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
      Bitmap.DrawRect(Rect, $ffffff);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
        Bitmap.DrawRect(Rect, $ffffff);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Bitmap.DrawRect(Rect, $ffffff);
      Result += Rect;
    end;
  end;

var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  Rects: TRectArray;
  B: TBox;
  TPA: TPointArray;
  NPCFinder: TRSObjectFinder;
  NPC: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  if Filter.Walker then
  begin
    Rects := GetTilesRects(Bitmap);
    if Filter.Finder then
    begin
      NPCFinder := Finder;
      NPCFinder.MinLongSide := 0;
      NPCFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(NPCFinder, B).Merge;
          NPC += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          NPC += TPA;
        end;
      end;
    end;
  end

  else if Filter.Finder then
    NPC := MainScreen.FindObject(Finder);

  if NPC = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  NPC.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(NPC);
  Bitmap.DrawTPA(NPC[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;

procedure TRSGroundItem.SetupValue;
begin
  GEValue := ItemInfo.GetAveragePrice(ItemArray[0]);
  StoreValue := ItemInfo.GetStoreCost(ItemArray[0]);
  LowAlch := Round(StoreValue * 0.4);
  HighAlch := Round(StoreValue * 0.6);
end;

// HoverHelper function used by non walking ground item hovering functions.
function TRSGroundItem._HoverHelper(Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  for Attempt := 0 to Attempts do
  begin
    if Filter.UpText and MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if Attempt = (Attempts - 1) then
    begin
      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// WalkHoverHelper function used by walking ground item hovering functions.
function TRSGroundItem._WalkHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  if not Filter.Walker then
    Exit;

  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if Filter.UpText and MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True)
    else if not Map^.AtTile(Tile, 50) then
      Map^.WebWalk(Tile, 10, 0.2)
    else if Attempt = (Attempts - 1) then
    begin
      if not Map^.AtTile(Tile, 30) and Map^.WebWalk(Tile, 10, 0.2) then
        Continue;

      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// ClickHelper function used by ground item clicking functions.
function TRSGroundItem._ClickHelper(LeftClick: Boolean): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.Select(UpText) then
      Exit(True)
    else
    begin
      ChooseOption.Close;
      Exit;
    end;
  end;

  if LeftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and Filter.UpText and ChooseOption.Select(UpText));
end;

// SelectHelper function used by ground item option selection functions.
function TRSGroundItem._SelectHelper(Action: TStringArray): Boolean;
begin
  if ChooseOption.IsOpen and ChooseOption.Select(Action) then
    Exit(True);

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;




// Searches for an NPC with TRSGroundItem.Find.
function TRSGroundItem.Hover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if Filter.Walker and not Map^.MakeTileVisible(Tile) then
    Exit(False);

  Result := Self._HoverHelper(Attempts);
end;

// Searches for an NPC with TRSGroundItem.Find, hovers and clicks it if found.
function TRSGroundItem.Click(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an NPC with TRSGroundItem.Find, hovers and selects the specified action if found.
function TRSGroundItem.SelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._SelectHelper(Action);
end;




// Searches for an NPC with TRSGroundItem.Find and walker.
function TRSGroundItem.WalkHover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Filter.Walker then
    Exit;

  if not Map^.MakeTileVisible(Tile) then
    if not Map^.WebWalk(Tile, 30, 0.2) then
      Exit(False);

  Result := Self._WalkHoverHelper(Attempts);
end;

// Searches for an NPC with TRSGroundItem.Find and walker, hovers and clicks it if found.
function TRSGroundItem.WalkClick(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an NPC with TRSGroundItem.Find and walker, hovers and selects the specified action if found.
function TRSGroundItem.WalkSelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._SelectHelper(Action);
end;
