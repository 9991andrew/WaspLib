//temporary simba1500 wrappers
//this will probably all be removed when simba1500 comes out.
{$DEFINE WL_COMPATIBILITY_INCLUDED}
{$IFNDEF WL_UTILS}
  {$I WaspLib/utils.simba}
{$ENDIF}

function WriteFileContents(const FileName: String; const Text: String): Boolean; overload;
begin
  Result := WriteFileContents(FileName, Text, False);
end;

//old TStringArray.Find()
function TStringArray.IndexOf(const Value: String): Integer; constref;
begin
  for Result := 0 to High(Self) do
    if (Value = Self[Result]) then
      Exit;

  Result := -1;
end;

//old String.Explode()
function String.Split(Delimiter: String): TStringArray; constref;
begin
  Result := System.Explode(Delimiter, Self);
end;

//old String.Strip()
function String.Trim(Chars:String = STR_WHITESPACE): String; constref;
var Lo,Hi: UInt32 = 1;
begin
  Hi:=Length(Self);
  while (Lo <= Hi) and (System.Pos(Self[Lo],Chars) <> 0) do Inc(Lo);
  while (Hi >= 1)  and (System.Pos(Self[Hi],Chars) <> 0) do Dec(Hi);
  Result := Copy(Self, Lo, Hi-Lo+1);
end;

//old String.ExtractNumber()
function String.ExtractInteger(DefaultValue: Int64 = -1): Int64; constref;
begin
  Result := StrToIntDef(ExtractFromStr(Self, Numbers), DefaultValue);
end;

//old String.Lower()
function String.ToLower(): String; constref;
begin
  Result := Lowercase(Self);
end;

//similar to TIntegerArray.ClearDuplicates()
function TIntegerArray.Unique(): TIntegerArray;
begin
  ClearSameIntegers(Self);
  Result := Self;
end;

//new simba1500 function for all arrays.
function TIntegerArray.Intersection(other: TIntegerArray): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(other) do
    if Self.Find(other[i]) > -1 then
      Result += other[i];
end;

//new simba1500 function for all arrays, returns an array with the elements that are the same in the 2 input arrays.
function TPointArray.Intersection(other: TPointArray): TPointArray; constref;
var
  i: Int32;
begin
  for i := 0 to High(other) do
    if Self.Find(other[i]) > -1 then
      Result += other[i];
end;

//new simba1500 function for all arrays.
function TPointArray.Contains(const Value: TPoint): Boolean;
var
  i: Int32;
begin
  for i := 0 to High(Self) do
    if (Value.X = Self[i].X) and (Value.Y = Self[i].Y) then
      Exit(True);

  Result := False;
end;

//similar to TPointArray.ClearDuplicates()
function TPointArray.Unique(): TPointArray; constref;
begin
  Result := Self;
  ClearDoubleTPA(Result);
end;


//similar to TPointArray.Sorted()
function TPointArray.SortFrom(From:TPoint=[0,0]): TPointArray; constref;
begin
  Result := Copy(Self);
  SortTPAFrom(Result, From);
end;

//similar to TBox.Middle()
function TBox.Center(): TPoint; constref;
begin
  Result := Point((Self.X2 + Self.X1+1) div 2, (Self.Y2 + Self.Y1+1) div 2);
end;


function T2DPointArray.ExcludeSize(MinLen:Int32; KeepIf:EComparator=__LT__): T2DPointArray; constref;
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    case KeepIf of
      __LT__: if Length(TPA) < MinLen then tmp += TPA;
      __GT__: if Length(TPA) > MinLen then tmp += TPA;
      __EQ__: if Length(TPA) = MinLen then tmp += TPA;
      __NE__: if Length(TPA)<> MinLen then tmp += TPA;
    end;
  Result := tmp;
end;

function T2DPointArray.ExcludeSize(MinLen,MaxLen:Int32): T2DPointArray; constref; overload;
var
  tmp:T2DPointArray;
  TPA:TPointArray;
begin
  for TPA in Self do
    if InRange(Length(TPA), MinLen, MaxLen) then
      tmp += TPA;
  Result := tmp;
end;


function TPointArray.ShapeFill(): TPointArray; constref;
begin
  Result := Self;
  FillEllipse(Result);
end;

