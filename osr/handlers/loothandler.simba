(*
CombatHandler
=============
CombatHandler is a record made to handle certain things related to combat.
*)

{$DEFINE WL_LOOTHANDLER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TRSLootHandler = record(TSRLBaseRecord)
    Loot: TRSGroundItem;
    Drops: array of TRSMonsterDrop;
    ValueThreshold: Int32;
    CheckedLoot: Boolean;
    IsSetup: Boolean;
  end;


function TRSLootHandler.IsGoodDrop(Drop: TRSMonsterDrop): Boolean;
const
  ItemArray: TStringArray = [
    'Clue scroll (easy)', 'Clue scroll (medium)',
    'Clue scroll (hard)', 'Clue scroll (elite)',
    'Clue scroll (master)',
    'Dark totem base', 'Dark totem middle', 'Dark totem top',
    'Dark totem', 'Ancient shard', 'Brimstone key',
    'Mist battlestaff', 'Dust battlestaff',
    'Eternal gem', 'Imbued heart', 'Crystal shard', 'Abyssal head',
    'Curved bone', 'Long bone',
    'Imp champion scroll', 'Goblin champion scroll', 'Skeleton champion scroll',
    'Zombie champion scroll', 'Giant champion scroll',
    'Hobgoblin champion scroll', 'Ghoul champion scroll',
    'Earth warrior champion scroll', 'Jogre champion scroll',
    'Lesser demon champion scroll',
    'Giant key', 'Mossy key'
  ];
var
  GEValue: Int32;
begin
  if ItemArray.Find(Drop.Item) > -1 then
    Exit(True);

  GEValue := ItemData.GetAverage(Drop.ID);

  Result := GEValue >= ValueThreshold;
  if Result then
    Exit;

  Result := Drop.Stackable and
            ((GEValue * Drop.Quantity) >= (ValueThreshold / 5));
  if Result then
    Exit;

  Result := ItemData.GetHighAlch(Drop.ID) > ValueThreshold;
  if Result then
    RSAction.AlchItemArray += Drop.Item;
end;

procedure TRSLootHandler.Setup(Monster: PRSMonster; Value: Int32 = 5000);
var
  i: Int32;
  TempDrops: array of TRSMonsterDrop;
begin
  if (Monster^.MonsterName = '') or (Value <= 0) then
    Exit;

  ValueThreshold := Value;

  Loot.SetupCommon;
  if Monster^.WalkerIndex > -1 then
    Loot.SetupCommon(Monster^.WalkerIndex, Monster^.DotFilter[0].Circle.Radius, 0, Monster^.TileArray);

  Loot.Filter.Finder := False;
  Loot.Filter.UpText := False;

  DebugGItemArray += @Loot;

  TempDrops := MonsterData.GetDrops(Monster^.MonsterName);

  for i := 0 to High(TempDrops) do
  begin
    if Self.IsGoodDrop(TempDrops[i]) then
    begin
      Drops += TempDrops[i];
      Loot.UpText += TempDrops[i].Item;
    end;
  end;

  IsSetup:= Loot <> [];
end;

function TRSLootHandler.HasSpace(Drop: TRSMonsterDrop): Boolean;
begin
  Result := not Inventory.IsFull or (Drop.Stackable and Inventory.FindItem(Drop.Item));
end;

function TRSLootHandler.HandleLooting: Boolean;
var
  Index: Int32;
  TempFilter: TRSDotFilterArray; //Used to reset filters.
begin
  if not MainScreen.IsUpText('Take') then
  begin
    ChooseOption.Open;
    if not ChooseOption.HasOption('Take') then
      Exit;
  end;

  CheckedLoot := True;
  TempFilter := Loot.DotFilter;
  Loot.DotFilter.Setup([Loot.ClosestDot.X, Loot.ClosestDot.Y, 3], True);

  if not ChooseOption.IsOpen and MainScreen.IsUpText(Loot.UpText, -1, Index) then
  begin
    if not Self.HasSpace(Drops[Index]) then
    begin
      if Inventory.Consume(ERSConsumable.HEALTH_CONSUMABLE) then
        Loot.Hover(5)
      else
      begin
        Loot.DotFilter := TempFilter;
        Exit;
      end;
    end;
    Mouse.Click(MOUSE_LEFT);
    Loot.DotFilter := TempFilter;
    Exit(True);
  end;

  if ChooseOption.Open then
  begin
    if not ChooseOption.HasOption(Loot.UpText, Index) then
    begin
      Loot.DotFilter := TempFilter;
      Exit;
    end;

    if not Self.HasSpace(Drops[Index]) then
    begin
      if Inventory.Consume(ERSConsumable.HEALTH_CONSUMABLE) then
        Loot.Hover(5)
      else
      begin
        Loot.DotFilter := TempFilter;
        Exit;
      end;
    end;

    Result := ChooseOption.Select(Loot.UpText[Index]);
  end;

  Loot.DotFilter := TempFilter;
end;

function TRSLootHandler.CheckLoot(P: TPoint): Boolean;
begin
  Mouse.Move(P);

  Result := Self.HandleLooting;
end;

function TRSLootHandler.CheckLoot(B: TBox): Boolean; overload;
begin
  Mouse.Move(B);

  Result := Self.HandleLooting;
end;

function TRSLootHandler.CheckLoot: Boolean; overload;
begin
  if not Loot.Hover(0) then
    Exit;

  Result := Self.HandleLooting;
  if Result then
    Minimap.WaitMoving;

  if CheckedLoot then
  begin
    Loot.DotFilter.Setup([Loot.ClosestDot.X, Loot.ClosestDot.Y, 2], False, 120 * ONE_SECOND);
    CheckedLoot := False;
  end;
end;
