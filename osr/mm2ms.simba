(*
MM2MS
=====
Methods to handle MM2MS (Minimap to MainScreen). Extends SRL's MM2MS.
*)

{$DEFINE WL_MM2MS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
MM2MS.SetupZoom
~~~~~~~~~~~~~~~
.. pascal:: procedure TMM2MS.SetupZoom;

Wrapper procedure to easily setup MM2MS.ZoomLevel.

Example
-------

  MM2MS.SetupZoom;
  WriteLn MM2MS.ZoomLevel;
*)
procedure TMM2MS.SetupZoom;
begin
  if (Self.ZoomLevel = -1) then
  begin
    Self.DebugLn('Unknown zoom level, reading from options...');
    Self.ZoomLevel := Options.GetZoomLevel;
    Self.DebugLn('Current zoom level: ' + ToString(Self.ZoomLevel));
  end;
end;


(*
Minimap.ZoomToPoint
~~~~~~~~~~~~~~~~~~~
.. pascal:: function Minimap.ZoomToPoint(P: TPoint): Int32;

This function gives us a zoom level where **P** would be visible in the MainScreen.

Example
-------

  P := Minimap.GetDots(ERSMinimapDot.ITEM)[0]; //find an item dot and returns it's coodinates.
  Options.SetZoomLevel(Minimap.ZoomToPoint(P));
*)
function Minimap.ZoomToPoint(P: TPoint): Int32;
var
  Distance: Int32;
begin
  Distance := Round(P.DistanceTo(Minimap.Center));

  //- Random(5, 10) to give it some margin
  Result := Round((73 - Distance) / 0.8) - Random(25, 30);
end;

(*
Minimap.GetPolygonMS
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]; Roll: Single = $FFFF): TPointArray;

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.

To put it simply, this will will first calculate a floor rectangle with **TileVector.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **TileVector.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon.

Example
-------

  P := Minimap.GetDots(ERSMinimapDot.PLAYER)[0];         //find a player dot and returns it's coodinates.
  Offset := [2 , 2];                                     //Minimap dots are actually returned with a slight offset of -2, -2 when converting them to the mainscreen.
  Debug(Minimap.GetPolygonMS(P, [1, 1, 7], Offset));     //This will draw a polygon around the nearest player.
*)
function TRSMinimap.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]; Roll: Single = $FFFF): TPoly;
var
  TPA: TPointArray;
begin
  if (Roll = $FFFF) then
    Roll := Self.GetCompassAngle(False);

  TPA := Self.GetTileMs(Loc, [TileVector.Y, TileVector.X, 0], Offset, Roll).ToTPA();

  if TileVector.Z = 0 then
    Exit(TPA);

  Result := TPA.Combine(Self.GetTileMS(Loc, TileVector, Offset, Roll).ToTPA()).ConvexHull();
end;

(*
Minimap.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TRectArray;
.. pascal:: function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; Z: Double = 0): TRectArray; overload;

Gives you an array of rectangles of several tiles and they can be multiple tiles each.
For an explanation of parameters check Minimap.GetTileMS.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.NPC);   //find all npc dots and returns their coodinates.
  Debug(Minimap.GetTileArrayMS(P, [2, 3, 0])); //This will draw a recangle that is 2 by 3 tiles in the mainscreen where each NPC is.
*)
function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TRectArray;
var
  Loc: TPoint;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  for Loc in LocArray.Sorted(Self.Center) do
    Result += Self.GetTileMS(Loc, TileVector, Offset, Angle);
end;

(*
Minimap.GetPolygonArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: Vector2 = [0, 0]; Angle: Single = $FFFF): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetPolygonMS** for more information.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetPolygonArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSMinimap.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: Vector2 = [0, 0]; Angle: Single = $FFFF): TPolyArray;
var
  Loc: TPoint;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  for Loc in LocArray do
    Result += Self.GetPolygonMS(Loc, TileVector, Offset, Angle);
end;






(*
type TRSDotFilter
~~~~~~~~~~~~~~~~~
  Used to filter mmdots
*)
type
  TRSDotFilter = record
    TPA: TPointArray;
    Circle: TCircle;
    Inside: Boolean;
    HasTimer: Boolean;
    Timer: TCountDown;
  end;

  TRSDotFilterArray = array of TRSDotFilter;


procedure TRSDotFilterArray.Setup(TPA: TPointArray; C: TCircle; Inside: Boolean; Time: Int32 = -1);
var
  Timer: TCountDown;
begin
  Timer.Init(Time);
  Self += [TPA, C, Inside, (Time > 0), Timer];
end;

procedure TRSDotFilterArray.Setup(TPA: TPointArray; Inside: Boolean; Time: Int32 = -1); overload;
var
  C: TCircle;
begin
  Self.Setup(TPA, C, Inside, Time);
end;

procedure TRSDotFilterArray.Setup(C: TCircle; Inside: Boolean; Time: Int32 = -1); overload;
var
  TPA: TPointArray;
begin
  Self.Setup(TPA, C, Inside, Time);
end;


procedure TRSDotFilterArray.ClearExpired;
var
  i, DelCount: Int32;
begin
  DelCount := 0;

  for i := 0 to High(Self) do
  begin
    if Self[i - DelCount].HasTimer and Self[i - DelCount].Timer.IsFinished then
    begin
      Delete(Self, i - DelCount, 1);
      DelCount += 1;
    end;
  end;
end;


//Filter circles circles within circles.
//There are times we only want the inner circles, other's we want the outter ones.
//not being used yet.
function TRSDotFilterArray.FilterCircles(Inside: Boolean): TRSDotFilterArray;
var
  i, j: Int32;
begin
  Result := Self;

  for i := 0 to High(Self) do
    for j := 0 to High(Self) do
      if j <> i then
        if SRL.PointInCircle(Self[j].Circle.Mean, Self[i].Circle.Mean, Self[i].Circle.Radius) then
          if Inside then
            Delete(Result, i)
          else
            Delete(Result, j);
end;



function TRSDotFilterArray._DotValidIn(P: TPoint): Boolean;
var
  i: Int32;
  InPoly: Boolean;
  InCircle: Boolean;
begin
  for i := 0 to High(Self) do
  begin
    if Self[i].TPA <> [] then
      InPoly := SRL.PointInPoly(P, Self[i].TPA);

    if Self[i].Circle <> [] then
      InCircle := SRL.PointInCircle(P, Self[i].Circle.Mean, Self[i].Circle.Radius);

    if InPoly or InCircle then
      Exit(True);
  end;

  Result := False;
end;

function TRSDotFilterArray._DotValidOut(P: TPoint): Boolean;
var
  i: Int32;
  InPoly: Boolean;
  InCircle: Boolean;
begin
  for i := 0 to High(Self) do
  begin
    if Self[i].TPA <> [] then
      InPoly := SRL.PointInPoly(P, Self[i].TPA);

    if Self[i].Circle <> [] then
      InCircle := SRL.PointInCircle(P, Self[i].Circle.Mean, Self[i].Circle.Radius);

    if InPoly or InCircle then
      Exit(False);
  end;

  Result := True;
end;


procedure Debug(DotFilterArray: TRSDotFilterArray); overload;
var
  Bitmap: TMufasaBitmap;
  I: Int32;
begin
  Bitmap := TMufasaBitmap.CreateFromClient;

  for I := 0 to High(DotFilterArray) do
  begin
    if DotFilterArray[I].TPA <> [] then
    begin
      if DotFilterArray[I].Inside then
        Bitmap.DrawTPA(DotFilterArray[I].TPA.Connect, clLime)
      else
        Bitmap.DrawTPA(DotFilterArray[I].TPA.Connect, clRed);
    end;

    if DotFilterArray[I].Circle <> [] then
    begin
      if DotFilterArray[I].Inside then
        Bitmap.DrawCircle(DotFilterArray[I].Circle.Mean, DotFilterArray[I].Circle.Radius, clLime)
      else
        Bitmap.DrawCircle(DotFilterArray[I].Circle.Mean, DotFilterArray[I].Circle.Radius, clRed);
    end;
  end;

  Bitmap.Show(True);
  Bitmap.Free();
end;


function TRSDotFilterArray.DotValid(P: TPoint; Clear: Boolean = True): Boolean;
var
  i: Int32;
  InDotFilter: TRSDotFilterArray;
  OutDotFilter: TRSDotFilterArray;
begin
  if Clear then
    Self.ClearExpired;

  for i := 0 to High(Self) do
    if Self[i].Inside then
      InDotFilter += Self[i]
    else
      OutDotFilter += Self[i];

  //InDotFilter := InDotFilter.FilterCircles(True);
  //OutDotFilter := OutDotFilter.FilterCircles(False);

  Result := InDotFilter._DotValidIn(P) and OutDotFilter._DotValidOut(P);
end;

//return filtered valid dots. To be added to MMDot.Find later.
function TRSDotFilterArray.FilterDots(TPA: TPointArray): TPointArray;
var
  P: TPoint;
begin
  Self.ClearExpired;

  for P in TPA do
    if Self.DotValid(P, False) then
      Result += P;
end;




(*
Minimap.GetCircle
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetCircle(Loc: TPoint; Radius: Int32; Offset: TPoint = [0, 0]): TCircle;
Returns a circle in the Minimap, **Loc** being the middle point of the circle.

Example
-------

  var
    P: TPoint;
    Bitmap: TMufasaBitmap;

  begin
    P := Minimap.GetDots(ERSMinimapDots.NPC)[0];

    Bitmap.FromClient;

    Bitmap.DrawCircle(P.X, P.Y, Minimap.GetCircle(P, 5)); //Draws a circle in the minimap around an NPC of 5 radius.

    ShowBitmap(Bitmap);
    FreeBitmap(Bitmap);
  end;
*)
function TRSMinimap.GetCircle(Loc: TPoint; Radius: Int32; Offset: TPoint = [0, 0]): TCircle;
begin
  if (Self.Center.DistanceTo((Loc - Offset)) - Radius) > 80 then
    Exit; //This means it's impossible the result will be in the minimap.

  Loc := Loc - Offset;
  Result := [Loc.X, Loc.Y, Radius * 4];
end;

(*
Minimap.GetCircleArray
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetCircleArray(Locs: TPointArray; Radius: Int32; Offset: TPoint = [0, 0]): TCircleArray;
Returns an array of circles in the minimap.

Example
-------

  var
    P: TPoint;
    TPA: TPointArray;
    Bitmap: TMufasaBitmap;

  begin
    TPA := Minimap.GetDots(ERSMinimapDots.NPC);

    Bitmap.FromClient;

    for P in TPA do
      Bitmap.DrawCircle(P.X, P.Y, Minimap.GetRadius(P, 5));

    ShowBitmap(Bitmap);
    FreeBitmap(Bitmap);
  end;
*)
function TRSMinimap.GetCircleArray(Locs: TPointArray; Radius: Int32; Offset: TPoint = [0, 0]): TCircleArray;
var
  Loc: TPoint;
begin
  for Loc in Locs do
    Result += Self.GetCircle(Loc, Radius, Offset);
end;

(*
Minimap.GetDotInCircle
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotInCircle(Dot: ERSMinimapDot; Loc, Radius: Int32; Offset: TPoint = [0, 0]): TPoint;

Functions to get the **ERSMinimapDots** in a circle. Returns only the first dot found.
This is useful to know if a minimap dot is within range for example.

Example
-------

  var
    Bitmap: TMufasaBitmap;

  begin
    Bitmap.FromClient;

    //Draws a white cross on the first NPC dot found within our 8 pixel radius of the minimap center.
    Bitmap.DrawCross(Minimap.GetDotInCircle(ERSMinimapDot.NPC, Minimap.Center, 8), 4, $FFFFFF);

    ShowBitmap(Bitmap);
    FreeBitmap(Bitmap);
  end;
*)
function TRSMinimap.GetDotInCircle(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Offset: TPoint = [0, 0]): TPoint;
var
  i: Int32;
  Dots: TPointArray;
  Circle: TCircle;
begin
  Dots := Self.GetDots(Dot);

  Dots.Sort(Self.Center);

  Circle := Self.GetCircle(Loc, Radius, Offset);
  for i := 0 to High(Dots) do
    if SRL.PointInCircle(Dots[i], Circle.Mean, Circle.Radius) then
      Exit(Dots[i]);
end;

(*
Minimap.GetDotInCircleArray
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotInCircleArray(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Offset: TPoint = [0, 0]): TPointArray;

Same as above but for an array of circles.
Returns only the first dot found in each circle in the array.
It's a bit hard to explain it's uses but I personally use it in RSMMDots to accurately find the Minimap Dots while filtering out the ones I do not want.
*)
function TRSMinimap.GetDotInCircleArray(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Offset: TPoint = [0, 0]): TPointArray;
var
  Loc: TPoint;
begin
  for Loc in Locs do
    Result += Self.GetDotInCircle(Dot, Loc, Radius, Offset);
end;

(*
Minimap.GetDotArrayInCircle
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotArrayInCircle(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Offset: TPoint = [0, 0]): TPointArray;

Functions to get the **ERSMinimapDots** in a circle. Returns all dots found.
This is useful to know if minimap dots are within range for example.

Example
-------

  var
    P: TPoint;
    TPA: TPointArray;
    Bitmap: TMufasaBitmap;

  begin
    Bitmap.FromClient;

    TPA := Minimap.GetDotArrayInCircle(ERSMinimapDot.NPC, Minimap.Center, 8); //Get all npc dots that are within 8 pixels of the minimap center;

    for P in TPA do
      Bitmap.DrawCross(P, 4, $FFFFFF); //Will draw a white cross in each npc dot

    ShowBitmap(Bitmap);
    FreeBitmap(Bitmap);
  end;
*)
function TRSMinimap.GetDotArrayInCircle(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Offset: TPoint = [0, 0]): TPointArray;
var
  i: Int32;
  Dots: TPointArray;
  Circle: TCircle;
begin
  Dots := Self.GetDots(Dot);

  Dots.Sort(Self.Center);

  Circle := Self.GetCircle(Loc, Radius, Offset);
  for i := 0 to High(Dots) do
    if SRL.PointInCircle(Dots[i], Circle.Mean, Circle.Radius) then
      Result += Dots[i];
end;

(*
Minimap.GetDotArrayInCircleArray
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotArrayInCircleArray(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Offset: TPoint = [0, 0]): TPointArray;

Same as above but for an array of circles.
Returns all dots found in each circle in the array.
It's a bit hard to explain it's uses but I personally use it in RSMMDots to accurately find the Minimap Dots while filtering out the ones I do not want.
*)
function TRSMinimap.GetDotArrayInCircleArray(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Offset: TPoint = [0, 0]): TPointArray;
var
  i: Int32;
  ATPA: T2DPointArray;
begin
  for i := 0 to High(Locs) do
    ATPA += Self.GetDotArrayInCircle(Dot, Locs[i], Radius, Offset);

  Result := ATPA.Merge;

  Result.Sort(Self.Center);
end;

function TRSMinimap.GetFilteredDotArray(Dot: ERSMinimapDot; DotFilters: TRSDotFilterArray): TPointArray;
begin
  Result := DotFilters.FilterDots(Self.GetDots(Dot));
end;

function TRSMinimap.GetFilteredDot(Dot: ERSMinimapDot; DotFilters: TRSDotFilterArray): TPoint;
var
  Dots: TPointArray;
begin
  Dots := Self.GetFilteredDotArray(Dot, DotFilters);
  if Dots <> [] then
    Result := Dots[0];
end;


(*
Minimap.GetDotTileMS
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectangle;
.. pascal:: function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Z: Double = 0): TRectangle; overload;
.. pascal:: function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectArray; overload;
.. pascal:: function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Z: Double = 0): TRectArray; overload;

I'm not going to be too detailed on this one, if you read the previous functions documentations you can understand what this does.
Depending on the function you use it either:
  Combines **Minimap.GetTileMS** with **Minimap.GetDotInCircle** to return a tile of a minimap dot within a circle.
  Combines **Minimap.GetTileArrayMS** with **Minimap.GetDotInCircleArray** to return a tile of one minimap dot in each circle array we have.
*)
function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; TileVector: Vector3; RadiusOffset, Offset: TPoint = [0, 0]): TRectangle;
begin
  Result := Self.GetTileMS(
              Self.GetDotInCircle(Dot, Loc, Radius, RadiusOffset),
              TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Z: Double = 0): TRectangle; overload;
begin
  Result := Self.GetDotTileMS(Dot, Loc, Radius, [1, 1, Z]);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; TileVector: Vector3; RadiusOffset, Offset: TPoint = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetDotInCircleArray(Dot, Locs, Radius, RadiusOffset),
                                TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotTileMS(Dot, Locs, Radius, [1, 1, Z]);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; DotFilters: TRSDotFilterArray; TileVector: Vector3; Offset: TPoint = [0, 0]): TRectangle; overload;
begin
  Result := Self.GetTileMS(
              Self.GetFilteredDot(Dot, DotFilters),
              TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotTileMS(Dot: ERSMinimapDot; DotFilters: TRSDotFilterArray; Z: Double = 0): TRectangle; overload;
begin
  Result := Self.GetDotTileMS(Dot, DotFilters, [1, 1, Z]);
end;


(*
Minimap.GetDotArrayTilesMS
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectArray;
.. pascal:: function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Z: Double = 0): TRectArray; overload;
.. pascal:: function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; TileVector: Vector3; Offset, RadiusOffset: TPoint = [0, 0]): TRectArray; overload;
.. pascal:: function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Z: Double = 0): TRectArray; overload;

I'm not going to be too detailed on this one, if you read the previous functions documentations you can understand what this does.
Depending on the function you use it either:
  Combines **Minimap.GetTileArrayMS** with **Minimap.GetDotArrayInCircle** to return the tiles of all minimap dots within a circle.
  Combines **Minimap.GetTileArrayMS** with **Minimap.GetDotArrayInCircleArray** to return the tiles of all minimap dots in each circle array we have.
*)
function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; TileVector: Vector3; RadiusOffset, Offset: TPoint = [0, 0]): TRectArray;
begin
  Result := Self.GetTileArrayMS(
                  Self.GetDotArrayInCircle(Dot, Loc, Radius, RadiusOffset),
                  TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Loc: TPoint; Radius: Int32; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotArrayTilesMS(Dot, Loc, Radius, [1, 1, Z]);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; TileVector: Vector3; RadiusOffset, Offset: TPoint = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(
                  Self.GetDotArrayInCircleArray(Dot, Locs, Radius, RadiusOffset),
                  TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; Locs: TPointArray; Radius: Int32; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotArrayTilesMS(Dot, Locs, Radius, [1, 1, Z]);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; DotFilters: TRSDotFilterArray; TileVector: Vector3; Offset: TPoint = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(
              Self.GetFilteredDotArray(Dot, DotFilters),
              TileVector, Offset, $FFFF);
end;

function TRSMinimap.GetDotArrayTilesMS(Dot: ERSMinimapDot; DotFilters: TRSDotFilterArray; Z: Double = 0): TRectArray; overload;
begin
  Result := Self.GetDotArrayTilesMS(Dot, DotFilters, [1, 1, Z]);
end;
