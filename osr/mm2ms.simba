(*
MM2MS
=====
Methods to handle MM2MS (Minimap to MainScreen). Extends SRL's MM2MS.
*)

{$DEFINE WL_MM2MS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
MM2MS.SetupZoom
~~~~~~~~~~~~~~~
.. pascal:: procedure TMM2MS.SetupZoom;

Wrapper procedure to easily setup MM2MS.ZoomLevel.

Example
-------

  MM2MS.SetupZoom;
  WriteLn MM2MS.ZoomLevel;
*)
procedure TMM2MS.SetupZoom;
begin
  if (Self.ZoomLevel = -1) then
  begin
    Self.DebugLn('Unknown zoom level, reading from options...');
    Self.ZoomLevel := Options.GetZoomLevel;
    Self.DebugLn('Current zoom level: ' + ToString(Self.ZoomLevel));
  end;
end;


(*
Minimap.PointWithinZoom
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.PointWithinZoom(P: TPoint; out Corner: TPoint): Boolean;
.. pascal:: function TRSMinimap.PointWithinZoom(P: TPoint): Boolean; overload;
.. pascal:: function TRSMinimap.PointWithinZoom(TPA: TPointArray): Boolean; overload;

Method used to know if a point is within reach of the Zoom rectangle without adjusting the zoom level.
Check TRSMinimap.GetZoomRectangle for information on the Zoom rectangle.

Example
-------

  WriteLn Minimap.PointWithinZoom([620, 100]);
*)
function TRSMinimap.PointWithinZoom(P: TPoint; out Corner: TPoint): Boolean;
var
  TPA: TPointArray;
begin
  if not Self.IsPointOn(P) then
    Exit;

  TPA := Self.GetZoomRectangle().ToTPA().Sorted(P);
  Corner := TPA[High(TPA)];

  Result := Self.Center().DistanceTo(P) <= Self.Center().DistanceTo(Corner);
end;

function TRSMinimap.PointWithinZoom(P: TPoint): Boolean; overload;
var
  Corner: TPoint;
begin
  Result := Self.PointWithinZoom(P, Corner);
end;

function TRSMinimap.PointWithinZoom(TPA: TPointArray): Boolean; overload;
begin
  TPA.Sort(Self.Center());

  Result := Self.PointWithinZoom(TPA[Low(TPA)]);
end;


(*
Minimap.FacePoint
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;

This method will rotate the camera so that **P** is within the zoom rectangle without adjusting the zoom level.

Example
-------

  WriteLn Minimap.FacePoint([620, 100]); //keep in mind this example uses a static point, you will probably never do this.
*)
function TRSMinimap.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean;
var
  TPA: TPointArray;
  d1: Double;
  i: Int32;
begin
  if not Self.IsPointOn(P) then
    Exit;

  TPA := Self.GetZoomRectangle().ToTPA();

  if SRL.PointInPoly(P, TPA) then
    Exit(True);

  TPA.Sort(P);

  d1 := Self.Center().DistanceTo(P);

  for i := 0 to High(TPA) do
  begin
    if Result := d1 <= Self.Center().DistanceTo(TPA[i]) then
      Break;

    if i = High(TPA) then //the point is outside of the zoom rectangle reach.
      Exit;
  end;

  Self.SetCompassAngle(Self.Center().AngleBetween(TPA[i]) - Self.Center().AngleBetween(P) + Randomness);
end;

(*
MainScreen.FacePoint
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean; override;

TODO: ADD THIS TO SRL.

Overriden for a more desirable functionality.
The original function simply makes the point be straight up of the mainscreen, without regard wether it's visible or not.
This version of the function instead just makes sure that the point is visible as long as it `Minimap.PointWithinZoom` is true.
*)
function TRSMainScreen.FacePoint(P: TPoint; Randomness: Int32 = 0): Boolean; override;
begin
  Result := Minimap.FacePoint(Self.PointToMM(P).ToPoint(), Randomness);
end;

(*
Minimap.ZoomToVisiblePoint
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.ZoomToVisiblePoint(P: TPoint): Int32;

TODO: THIS NEEDS TO BE REWORKED. IT'S NOT RELIABLE RIGHT NOW.

This function gives us a zoom level where **P** would be visible in the MainScreen.

Example
-------

  P := Minimap.GetDots(ERSMinimapDot.ITEM)[0]; //find an item dot and returns it's coodinates.
  Options.SetZoomLevel(Minimap.ZoomToVisiblePoint(P));
*)
function TRSMinimap.ZoomToVisiblePoint(P: TPoint): Int32;
var
  Distance: Int32;
begin
  Distance := Round(P.DistanceTo(Minimap.Center));

  //- Random(5, 10) to give it some margin
  Result := Round((73 - Distance) / 0.8) - Random(25, 30);
end;

(*
Minimap.AdjustZoomToPoint
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.AdjustZoomToPoint(P: TPoint; Randomness: Int32 = 0): Boolean;

TODO: ADD THIS TO SRL WHEN TRSMinimap.ZoomToVisiblePoint() WORKS PROPERLY.

This function adjusts the zoom level so **P** TRSMinimap.PointWithinZoom() is true.
*)
function TRSMinimap.AdjustZoomToPoint(P: TPoint; Randomness: Int32 = 0): Boolean;
var
  ZoomLevel: Int32;
  MaxZoomLevel: Int32;
begin
  if Self.PointWithinZoom(P) then
    Exit(True);

  ZoomLevel := Self.ZoomToVisiblePoint(P) + Randomness;

  if Antiban.MaxZoom > 0 then
    MaxZoomLevel := Antiban.MaxZoom
  else
    MaxZoomLevel := 100;

  if (ZoomLevel >= Antiban.MinZoom) and (ZoomLevel <= MaxZoomLevel) then
    Result := Options.SetZoomLevel(ZoomLevel);
end;


(*
Minimap.MakePointVisible
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.MakePointVisible(P: TPoint): Boolean;
.. pascal:: function TRSMinimap.MakePointVisible(TPA: TPointArray): Boolean; overload;

TODO: ADD THIS TO SRL WHEN TRSMinimap.ZoomToVisiblePoint() WORKS PROPERLY.

Uses both Minimap.ZoomToPoint() and Minimap.FacePoint() to make a point visible on the Mainscreen.
*)
function TRSMinimap.MakePointVisible(P: TPoint): Boolean;
begin
  Result := Self.AdjustZoomToPoint(P, Random(-5, 5)) and Self.FacePoint(P, Random(-5, 5));
end;

function TRSMinimap.MakePointVisible(TPA: TPointArray): Boolean; overload;
begin
  Result := Self.MakePointVisible(TPA.Sorted(Self.Center()));
end;



(*
Minimap.GetPolygonMS
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]; Roll: Single = $FFFF): TPointArray;

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.

To put it simply, this will will first calculate a floor rectangle with **TileVector.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **TileVector.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon.

Example
-------

  P := Minimap.GetDots(ERSMinimapDot.PLAYER)[0];         //find a player dot and returns it's coodinates.
  Offset := [2 , 2];                                     //Minimap dots are actually returned with a slight offset of -2, -2 when converting them to the mainscreen.
  Debug(Minimap.GetPolygonMS(P, [1, 1, 7], Offset));     //This will draw a polygon around the nearest player.
*)
function TRSMinimap.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]; Roll: Single = $FFFF): TPoly;
var
  TPA: TPointArray;
begin
  if (Roll = $FFFF) then
    Roll := Self.GetCompassAngle(False);

  TPA := Self.GetTileMs(Loc, [TileVector.Y, TileVector.X, 0], Offset, Roll).ToTPA();

  if TileVector.Z = 0 then
    Exit(TPA);

  TPA.Extend(Self.GetTileMS(Loc, TileVector, Offset, Roll).ToTPA());
  TPA.ClearDuplicates();
  Result := TPA.ConvexHull();
end;

(*
Minimap.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TRectArray;
.. pascal:: function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; Z: Double = 0): TRectArray; overload;

Gives you an array of rectangles of several tiles and they can be multiple tiles each.
For an explanation of parameters check Minimap.GetTileMS.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.NPC);   //find all npc dots and returns their coodinates.
  Debug(Minimap.GetTileArrayMS(P, [2, 3, 0])); //This will draw a recangle that is 2 by 3 tiles in the mainscreen where each NPC is.
*)
function TRSMinimap.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: TPoint = [0, 0]; Angle: Single = $FFFF): TRectArray;
var
  Loc: TPoint;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  for Loc in LocArray.Sorted(Self.Center()) do
    Result += Self.GetTileMS(Loc, TileVector, Offset, Angle);
end;

(*
Minimap.GetPolygonArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: Vector2 = [0, 0]; Angle: Single = $FFFF): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetPolygonMS** for more information.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetPolygonArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSMinimap.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3; Offset: Vector2 = [0, 0]; Angle: Single = $FFFF): TPolyArray;
var
  Loc: TPoint;
begin
  if (Angle = $FFFF) then Angle := Self.GetCompassAngle(False);

  for Loc in LocArray do
    Result += Self.GetPolygonMS(Loc, TileVector, Offset, Angle);
end;


