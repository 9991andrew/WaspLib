(*
MainScreen
====
Methods to interact with the MainScreen.
*)

{$DEFINE WL_MAINSCREEN_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
ObjectFinder.Unlimit
~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSObjectFinder.Unlimit;

Resets ObjectFinder size limits
*)
procedure TRSObjectFinder.Unlimit;
begin
  Self.MinLongSide := 0;
  Self.MaxLongSide := 0;
  Self.MinShortSide := 0;
  Self.MaxShortSide := 0;
end;

(*
ObjectFinder.Unlimited
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSObjectFinder.Unlimited: TRSObjectFinder;

Returns a copy of the ObjectFinder with the size limits removed.
*)
function TRSObjectFinder.Unlimited: TRSObjectFinder;
begin
  Result := Self;
  Result.MinShortSide := 0;
  Result.MaxShortSide := 0;
  Result.MinLongSide := 0;
  Result.MaxLongSide := 0;
end;


(*
MainScreen.IsVisible
~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TRSMainScreen.IsVisible(P: TPoint): Boolean; override;
  function TRSMainScreen.IsVisible(TPA: TPointArray): Boolean; overload;
  function TRSMainScreen.IsVisible(B: TBox): Boolean; overload;
  function TRSMainScreen.IsVisible(Rect: TQuad): Boolean; overload;

Checks if the given TPoint, TPointArray, TBox or TQuad is visible in the MainScreen.
It will return true if it's not behind an interface otherwise returns false.

Example
-------

  Writeln MainScreen.IsVisible(P);
*)
function TRSMainScreen.IsVisible(P: TPoint): Boolean; override;
var
  b: TBox;
begin
  if P = [] then
    Exit;

  Result := Self.Bounds.Expand(-2).Contains(P);

  if Result and (Self.Mode <> ERSClientMode.FIXED) then
  begin
    if Self.HasInterface() then
    begin
      if Bank.Bounds.Expand(5).Contains(P) and Bank.IsOpen() then
        Exit(False);
      //if Anvil.Bounds.Expand(5).Contains(P) and Anvil.IsOpen() then
      //  Exit(False);
    end;

    if Chat.IsOpen() then
    begin
      if Chat.Bounds.Expand(5).Contains(P) then
        Exit(False);
    end
    else
    begin
      b := Chat.Bounds();
      b.Y1 += 142;

      if  b.Expand(5).Contains(P) then
        Exit(False);
    end;

    if Minimap.Bounds().Expand(55).Contains(P) then
      Exit(False);

    if GameTabs.Bounds().Expand(5).Contains(P) then
      if (P.Y >= Inventory.Bounds().Y2) or Inventory.Bounds().Expand(5).Contains(P) then
        Exit(False);
  end;
end;

function TRSMainScreen.IsVisible(tpa: TPointArray): Boolean; overload;
var
  temp: TPointArray;
  b: TBox;
begin
  tpa := tpa.ExcludeBox(Self.Bounds());

  if tpa = [] then
    Exit;

  Result := Self.Bounds.Expand(-2).Contains(tpa);

  if Result and (Self.Mode <> ERSClientMode.FIXED) then
  begin
    if Self.HasInterface() then
    begin
      if Bank.Bounds.Expand(5).Contains(tpa) and Bank.IsOpen() then
        Exit(False);
      if Anvil.Bounds.Expand(5).Contains(tpa) and Anvil.IsOpen() then
        Exit(False);
    end;

    if Chat.IsOpen() then
    begin
      if Chat.Bounds.Expand(5).Contains(tpa) then
        Exit(False);
    end
    else
    begin
      b := Chat.Bounds();
      b.Y1 += 142;

      if  b.Expand(5).Contains(tpa) then
        Exit(False);
    end;

    if Minimap.Bounds.Expand(55).Contains(tpa) then
      Exit(False);

    if GameTabs.Bounds().Expand(5).Contains(tpa) then
    begin
      temp := tpa;
      temp.SortByY();
      if (temp[0].Y >= Inventory.Bounds().Y2) or Inventory.Bounds().Expand(5).Contains(tpa) then
        Exit(False);
    end;
  end;
end;

function TRSMainScreen.IsVisible(B: TBox): Boolean; overload;
begin
  Result := Self.IsVisible(B.ToQuad().ToTPA());
end;

function TRSMainScreen.IsVisible(Rect: TQuad): Boolean; overload;
begin
  Result := Self.IsVisible(Rect.ToTPA());
end;


(*
MainScreen.Filter
~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TRSMainScreen.Filter(TPA: TPointArray): TPointArray;
  function TRSMainScreen.Filter(BoxArray: TBoxArray): TBoxArray; overload;
  function TRSMainScreen.Filter(RectArray: TQuadArray): TQuadArray; overload;
  function TRSMainScreen.Filter(PolyArray: TCuboidArray): TCuboidArray; overload;

Filters the given TPointArray, TBoxArray, TQuadArray or TCuboidArray and returns only those that are visible in the MainScreen.
*)
function TRSMainScreen.Filter(tpa: TPointArray): TPointArray;
var
  b: TBox;
begin
  Result := tpa := tpa.ExcludeBox(Self.Bounds());

  if (Result <> []) and (Self.Mode <> ERSClientMode.FIXED) then
  begin
    if Self.HasInterface() then
      Result := Result.Difference(Result.ExcludeBox(InterfaceArea.Bounds()));

    b := Chat.Bounds();

    if not Chat.IsOpen() then
      b.Y1 += 142;

    Result := Result.Difference(Result.ExcludeBox(b));
    Result := Result.Difference(Result.ExcludeBox(Minimap.Bounds().Expand(54, 13)));
    Result := Result.Difference(Result.ExcludeBox(GameTabs.Bounds()));
  end;
end;

function TRSMainScreen.Filter(cuboidArray: TCuboidArray): TCuboidArray; overload;
var
  cuboid: TCuboid;
begin
  for cuboid in cuboidArray do
    Result += Self.Filter(cuboid);
end;


(*
MainScreen.GetAdjacentTiles
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.GetAdjacentTiles: TQuadArray;

Returns the 4 tiles adjacent to the player in form of a TQuadArray.
*)
function TRSMainScreen.GetAdjacentTiles: TQuadArray;
begin
  Result += Minimap.StaticToMsRect([Minimap.Center().X + 4, Minimap.Center().Y]);
  Result += Minimap.StaticToMsRect([Minimap.Center().X - 4, Minimap.Center().Y]);
  Result += Minimap.StaticToMsRect([Minimap.Center().X, Minimap.Center().Y + 4]);
  Result += Minimap.StaticToMsRect([Minimap.Center().X, Minimap.Center().Y - 4]);
end;

(*
MainScreen.DebugAdjacentTiles
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMainScreen.DebugAdjacentTiles;

Debugs MainScreen.GetAdjacentTiles.

Example
-------

  MainScreen.DebugAdjacentTiles;
*)
procedure TRSMainScreen.DebugAdjacentTiles();
var
  Bitmap: TMufasaBitmap;
  Rect: TQuad;
begin
  Bitmap := TMufasaBitmap.CreateFromClient();

  for Rect in Self.GetAdjacentTiles() do
    Bitmap.DrawTPA(Rect.ToTPA().Connect(), $ffffff);

  Bitmap.Show(True);
  Bitmap.Free();
end;

(*
MainScreen.InMultiCombat
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.InMultiCombat: Boolean;

Returns true if we are in multi combat false if not.

Example
-------

  Writeln MainScreen.InMultiCombat;
*)
function TRSMainScreen.InMultiCombat(): Boolean;
var
  B: TBox;
begin
  case Self.Mode of
    ERSClientMode.FIXED:
      begin
        B := InterfaceArea.Bounds;
        B.X1 := B.X2 - 30;
        B.Y1 := B.Y2 - 30;
      end;
    ERSClientMode.RESIZABLE_CLASSIC, ERSClientMode.RESIZABLE_MODERN:
      begin
        B := Minimap.Bounds;
        B.X1 := B.X2 - 30;
        B.Y1 := B.Y2 + 5;
        B.Y2 := B.Y1 + 30;
      end;
  end;

  Result := (SRL.CountColor(CTS0(4902655, 0), B) > 0) and (SRL.CountColor(CTS0(19109, 0), B) > 0);
end;

(*
MainScreen.FindGrave
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindGrave: Boolean;

Returns true if we died and there's a grave available somewhere, false otherwise.

Example
-------

  Writeln MainScreen.FindGrave;
*)
function TRSMainScreen.FindGrave(): Boolean;
var
  A: TPoint;
  B: TBox;
begin
  case Self.Mode of
    ERSClientMode.FIXED:
      begin
        B := InterfaceArea.Bounds;
        B.X1 := B.X2 - 90;
        B.Y1 := B.Y2 - 30;
      end;
    ERSClientMode.RESIZABLE_CLASSIC, ERSClientMode.RESIZABLE_MODERN:
      begin
        A := Minimap.Center;
        B.X1 := A.X - 50;
        B.X2 := A.X + 40;
        B.Y1 := A.Y + 82;
        B.Y2 := A.Y + 120;
      end;
  end;

  Result :=  SRL.CountColor(CTS0(11448498, 0), B) = 51;
end;

(*
MainScreen.LoadingPOH
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.LoadingPOH: Boolean;

Returns true if we are loading a poh.

Example
-------

  Writeln MainScreen.LoadingPOH;
*)
function TRSMainScreen.LoadingPOH: Boolean;
begin
  Result := (SRL.CountColor(CTS0(13127, 0), Self.Bounds) = 892) and
            (SRL.CountColor(CTS0(8247, 0), Self.Bounds) = 900);
end;

(*
MainScreen.WaitLoadingPOH
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.WaitLoadingPOH: Boolean;

Waits for the POH loading screen returns true if we find a loading screen and successfully wait for it to finish.

Example
-------

  Writeln MainScreen.WaitLoadingPOH;
*)
function TRSMainScreen.WaitLoadingPOH(WaitTime: Int32; Interval: Int32 = -1): Boolean;
var
  t: UInt64;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 1500);

  t := GetTickCount;
  if WaitUntil(Self.LoadingPOH, Interval, WaitTime) then
  begin
    WaitTime := WaitTime - (GetTickCount - t);
    Result := WaitUntil(not Self.LoadingPOH, Interval, WaitTime);
  end;
end;

(*
MainScreen.InCombat
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.InCombat: Boolean;

Returns true if we are currently in combat.
With slow attack speed between you and the enemy this might return false negatives.

Example
-------

  Writeln MainScreen.InCombat;
*)
function TRSMainScreen.InCombat(): Boolean;
begin
  Result := XPBar.EarnedXP or (Self.FindHitsplats <> []);
end;

(*
MainScreen.WaitInCombat
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.WaitInCombat(WaitTime: Int32; Interval: Int32 = -1): Boolean;

Waits the specified **WaitTime** until we are in combat.

Example
-------

  MainScreen.WaitInCombat(5000);
*)
function TRSMainScreen.WaitInCombat(WaitTime: Int32; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 1500);

  Result := WaitUntil(Self.InCombat, Interval, WaitTime);
end;

(*
MainScreen.FindArrow
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindArrow(out TPA: TPointArray): Boolean;
.. pascal:: function TRSMainScreen.FindArrow: Boolean; overload;

Returns true if there's a yellow arrow on screen.
If a TPointArray is passed as a parameter it will return with the location of the arrow tip.

Example
-------

  Writeln MainScreen.FindArrow;
*)
function TRSMainScreen.FindArrow(out TPA: TPointArray): Boolean;
var
  TempTPA: TPointArray;
begin
  Result := (SRL.FindColors(TempTPA, CTS0(2291706, 0), Self.Bounds) > 0) and
            (Length(TempTPA) <= 35);
  if Result then
    TPA := Self.Filter(TempTPA);
end;

function TRSMainScreen.FindArrow(): Boolean; overload;
var
  TPA: TPointArray;
begin
  Result := (SRL.FindColors(TPA, CTS0(2291706, 0), Self.Bounds) > 0) and
            (Length(TPA) <= 35);
end;

(*
MainScreen.WaitArrow
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.WaitArrow(TPA: TPointArray; WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;
.. pascal:: function TRSMainScreen.WaitArrow(WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;

Waits **WaitTime** for a yellow arrow to appear on MainScreen.
If a TPointArray is passed as a parameter it will return with the location of the arrow tip.

Example
-------

  Writeln MainScreen.WaitArrow;
*)
function TRSMainScreen.WaitArrow(out TPA: TPointArray; WaitTime: Int32 = 120; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindArrow(TPA), Interval, WaitTime);
end;

function TRSMainScreen.WaitArrow(WaitTime: Int32 = 120; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindArrow, Interval, WaitTime);
end;

function TRSMainScreen.IsUpText(text: TStringArray; timeout: Int32; out index: Int32): Boolean; overload;

  function IsUpText: Boolean;
  var
    upText: String;
  begin
    upText := Self.GetUpText;

    for index := 0 to High(text) do
      if (text[index] in upText) or (text[index] = upText) then
        Exit(True);
  end;

var
  t: UInt64;
begin
  if (timeout = -1) then
    t := GetTickCount() + RandomMode(100, 85, 250)
  else
    t := GetTickCount() + timeout;

  repeat
    if IsUpText then
    begin
      Wait(50); // Uptext is delayed at least a frame. wait 50ms for confirmation.
      if IsUpText then
        Exit(True);
    end;

    Wait(25);
  until (GetTickCount() >= t);
end;

