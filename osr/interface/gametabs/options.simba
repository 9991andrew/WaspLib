{$DEFINE WL_OPTIONS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  ERSOptionsDropDown = (
    PLAYER_ATTACK_OPTIONS,
    NPC_ATTACK_OPTIONS,
    CLIENT_MODE
  );

  ERSAttackOption = (
    DEPENDS_ON_COMBAT,
    ALWAYS_LEFT_CLICK,
    ALWAYS_RIGHT_CLICK,
    HIDDEN,
    RIGHT_CLICK_CLAN
  );

function TRSOptions.LeaveHouse: Boolean;
begin
  if not Self.OpenHouseOptions then
    Exit;

  Self.GetHouseOptionsButton(ERSHouseOptionsButton.LEAVE).Click;

  Result := WaitUntil(not Self.IsHouseOptionsOpen, SRL.TruncatedGauss(50, 1500), 5000);
end;

function TRSOptions.CallServant: Boolean;
var
  S: String;
begin
  if not Self.OpenHouseOptions then
    Exit;

  Self.GetHouseOptionsButton(ERSHouseOptionsButton.SERVANT).Click;

  Result := WaitUntil(((S := Chat.GetChatTitle) = 'Demon buttler') or
                       (S = 'Repeat last task?'), SRL.TruncatedGauss(50, 1500), 5000);
end;


function TRSOptions.GetBrightnessSliderBounds: TBox;
begin
  Result.X1 := Self.X1 + 50;
  Result.Y1 := Self.Y1 + 76;
  Result.X2 := Result.X1 + 110;
  Result.Y2 := Result.Y1 + 9;
end;


function TRSOptions.FindBrightnessSlider(var P: TPoint; B: TBox): Boolean;
var
  TPA: TPointArray;
begin
  Result := SRL.FindColors(TPA, CTS0(2040359), B.Expand(10)) > 0;
  if Result then
    P := TPA.Mean;
end;

function TRSOptions.FindBrightnessSlider(var P: TPoint): Boolean; overload;
begin
  Result := Self.FindBrightnessSlider(P, Self.GetBrightnessSliderBounds);
end;


function TRSOptions.GetBrightnessLevel(B: TBox): Int32;
var
  Slider: TPoint;
  SliderB: TBox;
begin
  Result := -1;
  SliderB := B;
  if Self.Open and Self.OpenTab(ERSOptionsTab.DISPLAY) then
  begin
    B.X1 += 7;
    B.X2 -= 7;
    if Self.FindBrightnessSlider(Slider, SliderB) then
      Result := Round((Slider.X - B.X1) * 100 / (B.Width - 1))
  end;
end;

function TRSOptions.GetBrightnessLevel: Int32; overload;
begin
  Result := Self.GetBrightnessLevel(Self.GetBrightnessSliderBounds);
end;


function TRSOptions.SetBrightnessLevel(Level: Int32): Boolean;
var
  CurrentLevel: Int32;
  Slider: TPoint;
  SliderB: TBox;
  Destination: TPoint;
begin
  SliderB := Self.GetBrightnessSliderBounds;
  CurrentLevel := Self.GetBrightnessLevel(SliderB);

  if (CurrentLevel = Level) then
    Exit(True);

  if Self.FindBrightnessSlider(Slider, SliderB) then
  begin
    Destination.X := SliderB.X1 + Round((Level * (SliderB.Width - 1) / 100)) + 1;
    Destination.Y := Random(SliderB.Y1, SliderB.Y2);

    // Move slider away so we can click on destination
    if Distance(Slider, Destination) <= 12 then
    begin
      if (CurrentLevel + 20) < 100 then
        Self.SetBrightnessLevel(CurrentLevel + Random(20,40))
      else
        Self.SetBrightnessLevel(CurrentLevel - Random(20,40));
    end;

    Mouse.Click(Destination, MOUSE_LEFT);
  end;

  Result := WaitUntil(Self.GetBrightnessLevel(SliderB) = Level, SRL.TruncatedGauss(50, 1500), 3000);
end;


function TRSOptions.GetDropDowns: TRSDropDownArray;
begin
  Result := Self.FindDropDown([[160, 18]]);
end;

function TRSOptions.GetDropDown(DropDown: ERSOptionsDropDown): TRSDropDown;
var
  CurrentTab: ERSOptionsTab := Self.GetCurrentTab;
  DropDowns: TRSDropDownArray;
begin
  if ((CurrentTab = ERSOptionsTab.CONTROLS) and
      (DropDown = ERSOptionsDropDown.CLIENT_MODE)) or
     ((CurrentTab = ERSOptionsTab.DISPLAY) and
      (DropDown <> ERSOptionsDropDown.CLIENT_MODE)) then
    Exit;

  DropDowns := Self.GetDropDowns;

  if DropDowns <> [] then
    case DropDown of
      ERSOptionsDropDown.PLAYER_ATTACK_OPTIONS:
        Result := DropDowns[Low(DropDowns)];
      ERSOptionsDropDown.NPC_ATTACK_OPTIONS:
        Result := DropDowns[High(DropDowns)];
      ERSOptionsDropDown.CLIENT_MODE:
        Result := DropDowns[Low(DropDowns)];
    end;
end;


function TRSOptions.GetAttackOption(DropDown: ERSOptionsDropDown): ERSAttackOption;
var
  AttOptionStr: String;
begin
  if not Self.Open and not Self.OpenTab(ERSOptionsTab.CONTROLS) then
    Exit;

  AttOptionStr := Self.GetDropDown(DropDown).GetText.Lower;

  if 'depends' in AttOptionStr then
    Exit(ERSAttackOption.DEPENDS_ON_COMBAT)
  else if 'left' in AttOptionStr then
    Exit(ERSAttackOption.ALWAYS_LEFT_CLICK)
  else if 'right' in AttOptionStr then
    Exit(ERSAttackOption.ALWAYS_RIGHT_CLICK)
  else if 'hidden' in AttOptionStr then
    Exit(ERSAttackOption.HIDDEN)
  else if 'clan' in AttOptionStr then
    Exit(ERSAttackOption.RIGHT_CLICK_CLAN);
end;

function TRSOptions.GetPlayerAttackOption: ERSAttackOption;
begin
  Result := Self.GetAttackOption(ERSOptionsDropDown.PLAYER_ATTACK_OPTIONS);
end;

function TRSOptions.GetNPCAttackOption: ERSAttackOption;
begin
  Result := Self.GetAttackOption(ERSOptionsDropDown.NPC_ATTACK_OPTIONS);
end;


function TRSOptions.SetAttackOption(DropDown: ERSOptionsDropDown; Option: ERSAttackOption): Boolean;
var
  Strs: TStringArray;
begin
  if not Self.Open and not Self.OpenTab(ERSOptionsTab.CONTROLS) then
    Exit;

  if Self.GetAttackOption(DropDown) = Option then
    Exit(True);

  Strs := ['depends', 'left', 'right', 'hidden', 'clan'];

  Result := Self.GetDropDown(DropDown).Select(Strs[Ord(Option)], MOUSE_LEFT, False);
end;

function TRSOptions.SetPlayerAttackOption(Option: ERSAttackOption): Boolean;
begin
  Result := Self.SetAttackOption(ERSOptionsDropDown.PLAYER_ATTACK_OPTIONS, Option);
end;

function TRSOptions.SetNPCAttackOption(Option: ERSAttackOption): Boolean;
begin
  Result := Self.SetAttackOption(ERSOptionsDropDown.NPC_ATTACK_OPTIONS, Option);
end;



procedure TRSOptions.RenderSelf;
begin
  if SRL.CountColor(CHAT_COLOR_BLUE, Chat.GetLineBoxes[CHAT_INPUT_LINE]) > 14 then
    Keyboard.PressKey(VK_ENTER);
  Keyboard.Send('::renderself', VK_ENTER);
end;

procedure TRSOptions.ToggleRoofs;
begin
  Keyboard.Send('::toggleroofs', VK_ENTER);
end;


procedure TRSOptions.Draw(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  Bitmap.DrawDropDowns(Self.GetDropDowns);
end;
