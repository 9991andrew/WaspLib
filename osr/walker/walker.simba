(*
WaspWalker and Walker extensions
================================
Methods to handle walking around OSRS.
This file expands on SRL's walker file.
*)

{$DEFINE WL_WALKER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{$I waspweb.graph}
{$I agility.graph}

const
  WALKER_MAPS_VERSION = '0'; // Inc if images have changed

type
(*
type ERSMap
~~~~~~~~~~~
  Enumerator used for auto-completion of map names since the same cannot be achieved with strings directly.
*)
  ERSMap = (
    WORLD_MAP,
    MAINLAND_MAP,
    ZEAH_MAP,

    ABYSS_MAP,
    AL_KHARID_MAP,
    ALTARS_MAP,
    ARDOUGNE_MAP,
    ASGARNIA_ICE_DUNGEON_MAP,
    BARBARIAN_VILLAGE_MAP,
    BLAST_FURNACE_MAP,
    BRIMHAVEN_DUNGEON_MAP,
    CASTLE_WARS_MAP,
    CATACOMBS_OF_KOUREND_MAP,
    CATHERBY_MAP,
    CHASM_OF_FIRE_MAP,
    CORSAIR_COVE_DUNGEON_MAP,
    CRAFTING_GUILD_MAP,
    CRAFTING_GUILD_UPSTAIRS_MAP,
    DEATH_PLATEU_MAP,
    DRAYNOR_VILLAGE_MAP,
    EAST_VARROCK_MAP,
    EDGEVILLE_AND_BARBARIAN_VILLAGE_MAP,
    FALADOR_MAP,
    FREMMENNIK_SLAYER_CAVE_MAP,
    GIANTS_DEN_MAP,
    GIANTS_FOUNDRY_MAP,
    GRAND_EXCHANGE_MAP,
    GUARDIANS_OF_THE_RIFT_MAP,
    HESPORI_MAP,
    HOSIDIUS_FRUIT_STALL_HOUSE_MAP,
    HOSIDIUS_KITCHEN_MAP,
    IORWERTH_DUNGEON_MAP,
    KALPHITE_CAVE_MAP,
    KALPHITE_LAIR_MAP,
    KARUULM_SLAYER_DUNGEON_MAP,
    KBD_AND_NMZ_MAP,
    KOUREND_RUNECRAFTING_MAP,
    KRAKEN_COVE_MAP,
    LUMBRIDGE_MAP,
    LUNAR_ISLAND_MAP,
    MINING_GUILD_MAP,
    MOSLE_HARMLESS_CAVE_MAP,
    MOTHERLOAD_MAP,
    MOURNER_TUNNELS_MAP,
    OTTOS_GROTTO_MAP,
    PISCARILIUS_MAP,
    PRIFDDINAS_MAP,
    RIMMINGTON_MAP,
    ROGUES_DEN_MAP,
    SEERS_VILLAGE_MAP,
    SLAYER_TOWER_BASEMENT_AND_UPPERLEVEL_MAP,
    SLAYER_TOWER_GROUNDFLOOR_MAP,
    SMOKE_DEVIL_DUNGEON_MAP,
    SMOKE_DUNGEON_MAP,
    STRONGHOLD_SLAYER_DUNGEON_MAP,
    TZHAAR_MAP,
    VARROCK_MAP,
    WC_GUILD_MAP,
    WEST_VARROCK_MAP,
    WINTERTODT_MAP,
    WOODCUTTING_GUILD_MAP,
    YANILLE_MAP,
    ZULANDRA_MAP
  );

(*
type TRSMap
~~~~~~~~~~~
Type that holds information of RS Map in pre-extracted or to be extracted from the main image file.

**TRSMap.Name** is simply an identifier for that TRSMap.
**TRSMap.Base** is the base map we use to build this TRSMap. Unless you specify otherwise on TRSMap.Setup it will be 'world' by default.
**TRSMap.Coordinates** are the coordinate to crop from base map we want to use.
*)
  TRSMap = record
    Name: String;
    Base: String;
    Coordinates: TBox;
  end;

  TRSMapArray = array of TRSMap;

(*
var WASP_MAP_ARRAY
~~~~~~~~~~~~~~~~~~
Global variable used to store pre-defines TRSMap's.

var LOADED_MAP_ARRAY
~~~~~~~~~~~~~~~~~~~~
Global variable used to store loaded TRSMaps.
*)
var
  WASP_MAP_ARRAY: TRSMapArray;
  LOADED_MAP_ARRAY: TRSMapArray;

(*
TRSMapArray.IndexOf
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMapArray.IndexOf(Name: String): Int32; overload;

Overload to search for a TRSMap in a TRSMapArray only by name.
*)
function TRSMapArray.IndexOf(Value: String): Int32; overload;
var
  i: Int32;
begin
  if not Value.EndsWith('_map', True) then
    Value += '_map';

  Result := -1;

  for i := 0 to High(Self) do
    if Self[i].Name = Value then
      Exit(i);
end;

(*
TRSMap.Setup
~~~~~~~~~~~~
.. pascal:: function TRSMap.Setup(Name: String; Coordinates: TBox; Base: String = 'world'): TRSMap; static;
.. pascal:: function TRSMap.Setup(Map: ERSMap; Coordinates: TBox; Base: String = 'world'): TRSMap; static; overload;

Method used to setup a TRSMap. This will setup critical information about the TRSMap.
*)
function TRSMap.Setup(Name: String; Coordinates: TBox; Base: String = 'world'): TRSMap; static;
begin
  Result.Name := Name.ToLower();

  Result.Name := Name.ToLower();

  if Coordinates.X2 = 0 then
    Coordinates.X2 := Coordinates.X1 + 1000; //Automatically give the map 1000px width if we only gave it X1

  if Coordinates.Y2 = 0 then
    Coordinates.Y2 := Coordinates.Y1 + 1000; //Automatically give the map 1000px height if we only gave it Y1

  Result.Coordinates := Coordinates;
  Result.Base := Base;
  WASP_MAP_ARRAY += Result;
end;

function TRSMap.Setup(Map: ERSMap; Coordinates: TBox; Base: String = 'world'): TRSMap; static; overload;
begin
  Result := TRSMap.Setup(ToStr(Map), Coordinates, Base);
end;

function TRSMap.GetHeightMap(): TRSMap;
var
  TempMap: TRSMap;
begin
  TempMap := Self;
  TempMap.Base += '-h';
  Result := TempMap;
end;

function TRSMap.GetBasePath(): String;
const
  MAPS = {$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator;
begin
  Result := MAPS + Self.Base + '.png';
end;


type
  TRSWalkerArray = array of TRSWalker;

var
(*
var WALKER_ARRAY
~~~~~~~~~~~~~~~~
Global array used to store all TRSWalkers being used at any given moment.
This is mostly used to avoid using too many pointers and have an easier time debugging issues.

In places you would use a PRSWalker you can instead just use a normal Walker and then reference it by pulling it from the array.

Example
-------

  var
    RSW: TRSWalker;

  procedure thisDoesNotWork(RSW: TRSWalker);
  begin
    RSW.ScreenWalk := not RSW.ScreenWalk;
  end;

  procedure toggleScreenWalkInPointer(PRSW: PRSWalker);
  begin
    PRSW^.ScreenWalk := not PRSW^.ScreenWalk;
  end;

  procedure toggleScreenWalkInARRAY(RSW: TRSWalker);
  var
    i: Int32;
  begin
    i := WALKER_ARRAY.IndexOf(RSW.Name); //you will want to use the string overloaded method for this or you will probably not find it's index.

    if i = -1 then
      Exit;

    WALKER_ARRAY[i].ScreenWalk := not WALKER_ARRAY[i].ScreenWalk;
  end;

  begin
    RSW.Setup('world');

    thisDoesNotWork(RSW); //RSW will be unafected outside of the function.

    toggleScreenWalkInPointer(@RSW); //RSW will have it's ScreenWalk toggled properly but we had to use pointers which can be hard to debug.

    toggleScreenWalkInARRAY(RSW); //RSW will have it's ScreenWalk toggled and we didn't require pointers.
  end;
*)
  WALKER_ARRAY: TRSWalkerArray;

  WALKER_HEIGHT_ARRAY: array of TMufasaBitmap;
(*
var WALKER_OFFSET_ARRAY
~~~~~~~~~~~~~~~~~~~~~~~
Global array used to store all TRSWalkers offsets.

This are used when we are using a **TRSMap**.
*)
  WALKER_OFFSET_ARRAY: TPointArray;

  MAX_WALKER_HEIGHT = 30;


(*
TRSWalkerArray.IndexOf
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalkerArray.IndexOf(Value: String): Int32; overload;

Simple overload to helps us find a walker by name in WALKER_ARRAY.

Example
-------

  WALKER_ARRAY[WALKER_ARRAY.IndexOf(RSW1)].AdaptiveWalk := True;
  WALKER_ARRAY[WALKER_ARRAY.IndexOf(RSW2)].AdaptiveWalk := False;
*)
function TRSWalkerArray.IndexOf(Value: String): Int32; overload;
var
  i: Int32;
begin
  Result := -1;

  for i := 0 to High(Self) do
    if Self[i].Name = Value then
      Exit(i);
end;

(*
TRSWalkerArray.Contains
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalkerArray.Contains(Value: String): Boolean; overload;

Simple overload to helps us check if WALKER_ARRAY contains a TRSWalker by name.
*)
function TRSWalkerArray.Contains(Value: String): Boolean; overload;
begin
  Result := Self.IndexOf(Value) > -1
end;

(*
TRSWalker.FindMap
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.FindMap(Map: String): String; static;
.. pascal:: function TRSWalker.FindMap(Map: TRSMap): String; static; overload;

Function used to return the path of the map we want to use.

If you pass in a **String**, it will attempt to find the map file in Simba/Includes/SRL/osr/walker/maps/
The map file has to be either a .png or a .bmp.

If you pass a **TRSMap** instead, it will return a fictional path to an unexistent file that TRSWalker
will know how to handle in **TRSWalker.LoadMap()** for more information read the docs in that function.
*)
function TRSWalker.FindMap(Map: String): String; static; override;
var
  Mask: String = '.png;.bmp;';
  Files: TStringArray;
begin
  if FileExists(Map) then
    Exit(ExpandFileName(Map));

  Mask := StringReplace(Mask, '.', Map + '.', [rfReplaceAll]);
  Files := FindFile(ExtractFileDir(Map), Mask, False, False) +
           FindFile({$MACRO CURRENT_DIRECTORY}, Mask, True, False);

  if Length(Files) > 0 then
    Result := Files[0];
end;

function TRSWalker.FindMap(Map: TRSMap): String; static; overload;
const
  MAPS = {$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator + 'cache' + DirectorySeparator + WALKER_MAPS_VERSION + DirectorySeparator;
begin
  //This file is never created but we add ".png" at the end so we don't need to rewrite much of TRSWalker.LoadMap().
  Result := {$MACRO CURRENT_DIRECTORY} + Map.Base + ToStr(Map.Coordinates) + '.png';

  if not FileExists(MAPS + SHA1String(Result) + '.bmp') and not FileExists(Map.GetBasePath()) then
    Result := '';
end;


(*
TRSWalker.LoadMap
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.LoadMap(Path: String): TMufasaBitmap; static;
.. pascal:: function TRSWalker.LoadMap(Path: String; Map: TRSMap): TMufasaBitmap; static; overload;

This method is responsible for returning our map as a **TMufasaBitmap** to be setup in **TRSWalker.World**.

If you only pass it a String, it will use that as the map image path.
When doing this it will also make a version of the image in .bmp if you passed in a .png because those are much faster to load.

If you also pass in a TRSMap it will assume that **Path** is a fictional file that doesn't exist,
if there's an already cached version of this map, it will use that, if not, it will load "plane.bmp" instead
(for more info on planes, read TRSMap documentation above) and then crop the coordinates that
the TRSMap holds from "plane.bmp" and save it as a cache file for future uses.
This process might be slow the first time you do it for a certain set of coordinates but once the cache maps are generated
future runs will be fast.
*)
function TRSWalker.LoadMap(Path: String): TMufasaBitmap; static; override;
const
  MAPS = {$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator + 'cache' + DirectorySeparator + WALKER_MAPS_VERSION + DirectorySeparator;
var
  Cache: String;
begin
  Result := TMufasaBitmap.Create();

  if ExtractFileExt(Path) <> '.bmp' then
  begin
    Cache := MAPS + SHA1File(Path) + '.bmp';

    // Save as bitmap for much faster loading next time.
    if not FileExists(Cache) then
    begin
      Result.LoadFromFile(Path);
      Result.SaveToFile(Cache);
    end;

    if FileExists(Cache) then
      Path := Cache;
  end;

  Result.LoadFromFile(Path);
end;

function TRSWalker.LoadMap(Path: String; Map: TRSMap): TMufasaBitmap; static; overload;
const
  MAPS = {$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator;
var
  Cache: String;
begin
  Result := TMufasaBitmap.Create();

  if ExtractFileExt(Path) <> '.bmp' then
  begin
    Cache := MAPS + 'cache' + DirectorySeparator + WALKER_MAPS_VERSION + DirectorySeparator + SHA1String(Path) + '.bmp';

    // Save as bitmap for much faster loading
    if not FileExists(Cache) then
    begin
      if Map = [] then
        Result.LoadFromFile(Path)
      else
        Result.LoadFromFile(MAPS + Map.Base + '.png', Map.Coordinates);

      if ForceDirectories(MAPS + 'cache' + DirectorySeparator + WALKER_MAPS_VERSION) then
        Result.SaveToFile(Cache);
    end;

    if FileExists(Cache) then
      Path := Cache;
  end;

  Result.LoadFromFile(Path);
end;

(*
TRSWalker.Setup
~~~~~~~~~~~~~~~
.. pascal:: procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
.. pascal:: procedure TRSWalker.Setup(Map: ERSMap, Manage: Boolean = True; Scaling: Int32 = 9); overload;

Overriden so TRSWalker can be setup with TRSMaps.
You can also optionally pass in a ERSMap variable directly.
*)
procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
var
  HPath: String;
  Path: String;
  WalkerMap: TRSMap;
  Bitmap, Mask, Sample, HSample: TMufasaBitmap;
  i: Int32;
  X, Y: Int32;
begin
  Map := Map.ToLower();
  Self.Name := Map;

  i := WASP_MAP_ARRAY.IndexOf(Map);

  if i > -1 then
    WalkerMap := WASP_MAP_ARRAY[i];

  Self.AdaptiveWalk := True; //Make AdaptiveWalking True by default.

  Self.Scaling := Scaling;
  Self.ClickRandomness := 4;

  if i = -1 then
  begin
    Path := Self.FindMap(Map);
    HPath := Self.FindMap(Map + '-h');
  end
  else
  begin
    Path := Self.FindMap(WalkerMap);
    HPath := Self.FindMap(WalkerMap.GetHeightMap());
  end;

  if (Path = '') then
    Self.Fatal('Unable to find map: ' + Map);

  if Map.Contains('agility') then
    Self.WebGraph := WaspAgility
  else
    Self.WebGraph := WaspWeb;

  Self.World := Self.LoadMap(Path, WalkerMap);

  if HPath <> '' then
    WALKER_HEIGHT_ARRAY += Self.LoadMap(HPath, WalkerMap.GetHeightMap())
  else
  begin
    WALKER_HEIGHT_ARRAY +=  Self.World.Copy();
    WALKER_HEIGHT_ARRAY[High(WALKER_HEIGHT_ARRAY)].Fill(0); //Create a blank heightmap where all height is the same.
  end;

  if Manage then
    AddOnTerminate(@Self.Free);

  //Self.HighlightFeatures(Self.World);

  // Fixed or resizable, doesn't matter.
  Sample := TMufasaBitmap.Create();
  HSample := TMufasaBitmap.Create();

  Self.World.Downsample(Sample, Self.Scaling);
  WALKER_HEIGHT_ARRAY[High(WALKER_HEIGHT_ARRAY)].Downsample(HSample, Self.Scaling);

  Bitmap := Self.GetCleanMinimap();
  Mask := Self.ScaleMinimap(Bitmap, Self.Scaling);

  for X := 0 to Mask.getWidth() - 1 do
    for Y := 0 to Mask.getHeight() - 1 do
      if (Mask.GetPixel(X, Y) <> 0) then
        Mask.SetPixel(X, Y, $FFFFFF);

  Self.Cache := TMatchTemplateCache.Create(Sample.ToMatrix(), Mask.ToMatrix());

  Sample.Free();
  Bitmap.Free();
  Mask.Free();

  WALKER_ARRAY += Self;

  if WalkerMap = [] then
    WALKER_OFFSET_ARRAY += [0, 0]
  else
    WALKER_OFFSET_ARRAY += [WalkerMap.Coordinates.X1, WalkerMap.Coordinates.Y1];

  LOADED_MAP_ARRAY += WalkerMap;
end;

procedure TRSWalker.Setup(Map: ERSMap; Manage: Boolean = True; Scaling: Int32 = 9); overload;
begin
  Self.Setup(ToStr(Map), Manage, Scaling);
end;

(*
TRSWalker.Free
~~~~~~~~~~~~~~
.. pascal:: procedure TRSWalker.Free(); override;

Method used to free the memory used by a TRSWalker.
This method is overriden so we can also remove the walker from **WALKER_ARRAY** and it's offset from **WALKER_OFFSET_ARRAY**.
*)
procedure TRSWalker.Free(); override;
var
  i: Int32;
begin
  i := WALKER_ARRAY.IndexOf(Self.Name);

  WALKER_ARRAY.Delete(i, 1);
  WALKER_OFFSET_ARRAY.Delete(i, 1);

  if WALKER_HEIGHT_ARRAY[i] <> nil then
  begin
    WALKER_HEIGHT_ARRAY[i].Free();
    WALKER_HEIGHT_ARRAY[i] := nil;
  end;

  WALKER_HEIGHT_ARRAY.Delete(i, 1);

  if Self.World <> nil then
  begin
    Self.World.Free();
    Self.World := nil;
  end;
end;


(*
TRSWalker.FullSearch
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.FullSearch(Templ, World: TMufasaBitmap; Position: TPoint; out Match: Single): TPoint; override;

Overriden method to properly offset the player position if we are using a TRSMap.
*)
function TRSWalker.FullSearch(Templ, World: TMufasaBitmap; Position: TPoint; out Match: Single): TPoint; override;
const
  TEMPL_SIZE = 25;
  SLICE_SIZE = TEMPL_SIZE + 45;
  SCALING = 2;
var
  Slice, SliceScaled, TemplScaled: TMufasaBitmap;
  Matrix: TSingleMatrix;
  Area: TBox;
begin
  Area := [
    Max(0, Position.X - SLICE_SIZE),
    Max(0, Position.Y - SLICE_SIZE),
    Min(World.GetWidth()  - 1, Position.X + SLICE_SIZE),
    Min(World.GetHeight() - 1, Position.Y + SLICE_SIZE)
  ];

  Slice := World.Copy(Area.X1, Area.Y1, Area.X2, Area.Y2);
  SliceScaled := Slice.Copy();
  SliceScaled.Downsample(SCALING);

  TemplScaled := Templ.Copy();
  TemplScaled.Downsample(SCALING);
  with TemplScaled.GetCenter() do
    TemplScaled.Crop(X - TEMPL_SIZE, Y - TEMPL_SIZE, X + TEMPL_SIZE, Y + TEMPL_SIZE);

  Matrix := SliceScaled.MatchTemplate(TemplScaled, TM_CCOEFF_NORMED);

  with Matrix.ArgMax() do
  begin
    Match := Matrix[Y, X];

    Result.X := Area.X1 + (X + TEMPL_SIZE) * SCALING;
    Result.Y := Area.Y1 + (Y + TEMPL_SIZE) * SCALING;

    if WALKER_ARRAY.Contains(Self.Name) then
      Result += WALKER_OFFSET_ARRAY[WALKER_ARRAY.IndexOf(Self.Name)];
  end;

  TemplScaled.Free();
  SliceScaled.Free();
  Slice.Free();
end;

(*
TRSWalker.DebugPosition
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSWalker.DebugPosition(EnsureVisible: Boolean = True);

Overriden method to properly offset the player position if we are using a TRSMap.
*)
procedure TRSWalker.DebugPosition(EnsureVisible: Boolean = True); override;
var
  X1, Y1, X2, Y2, X, Y: Int32;
  P: TPoint;
  Bitmap, WorldBitmap, MinimapBitmap: TMufasaBitmap;
  Time: Double;
  Position, RemovedOffset: TPoint;
  Lines: TStringArray;
begin
  Freeze();

  Time := PerformanceTimer();
  Position := Self.GetMyPos();
  //because Self.GetMyPos() returns the position offset, we need to remove it for certain things.
  RemovedOffset := Position - WALKER_OFFSET_ARRAY[WALKER_ARRAY.IndexOf(Self.Name)];

  Time := PerformanceTimer() - Time;

  X1 := Max(0, RemovedOffset.X - 200);
  Y1 := Max(0, RemovedOffset.Y - 200);
  X2 := Min(X1 + 400, Self.World.GetWidth()  - 1);
  Y2 := Min(Y1 + 400, Self.World.GetHeight() - 1);

  X := RemovedOffset.X - X1;
  Y := RemovedOffset.Y - Y1;

  WorldBitmap := Self.World.Copy(X1, Y1, X2, Y2);
  WorldBitmap.DrawLine(Point(0, Y), Point(X2 - X1, Y), $00FF00);
  WorldBitmap.DrawLine(Point(X, 0), Point(X, Y2 - Y1), $00FF00);
  WorldBitmap.DrawBox([X - 2, Y - 2, X + 2, Y + 2], $FFFFFF);

  MinimapBitmap := Self.ScaleMinimap(Self.GetCleanMinimap(), 1);

  P := MinimapBitmap.GetCenter();
  if RSClient.Mode = ERSClientMode.FIXED then
    P := P.Offset(0, 8).Rotate(-Minimap.GetCompassAngle(False), P);

  MinimapBitmap.DrawBoxFilled([P.X - 1, P.Y - 1, P.X + 1, P.Y + 1], $FFFFFF);

  Bitmap := TMufasaBitmap.Create();
  Bitmap.SetSize(400 + MinimapBitmap.GetWidth() + 30, 420);
  Bitmap.Fill($403027);

  Lines := [
    '('      + ToStr(Position.X, ', ', Position.Y) + ')',
    'Acc: '  + ToStr(Round(Self.Similarity, 3)),
    'Time: ' + ToStr(Round(Time)) + ' ms'
  ];

  Bitmap.SetFontName('Consolas');
  Bitmap.SetFontSize(18);
  Bitmap.SetFontAntialiasing(True);

  Bitmap.DrawText(Lines[0], [420, 20 + MinimapBitmap.GetHeight()], $FFFFFF);
  Bitmap.DrawText(Lines[1] + LineEnding + Lines[2], [420, 370], $FFFFFF);

  Bitmap.DrawBitmap(WorldBitmap, [10, 10]);
  WorldBitmap.Free();

  Bitmap.DrawBitmap(MinimapBitmap, [420, 10]);
  MinimapBitmap.Free();

  Bitmap.Show(EnsureVisible);
  Bitmap.Free();

  UnFreeze();
end;


function TRSWalker.GetHeight(P: TPoint = []): Double;
var
  i: Int32;
  Color: Int64;
  HeightMap: TMufasaBitmap;
begin
  if P = [] then
    P := Self.GetMyPos();

  i := WALKER_ARRAY.IndexOf(Self.Name);
  HeightMap := WALKER_HEIGHT_ARRAY[i];

  P -= WALKER_OFFSET_ARRAY[i];

  Color := HeightMap.GetPixel(P.X, P.Y);

  Result := Color * MAX_WALKER_HEIGHT / $FFFFFF;
end;


function TRSWalker.GetHeightDiff(P1, P2: TPoint): Double;
begin
  Result := Self.GetHeight(P1)-Self.GetHeight(P2);
end;

function TRSWalker.GetHeightColor(P: TPoint = []): Int64;
var
  i: Int32;
  HeightMap: TMufasaBitmap;
begin
  if P = [] then
    P := Self.GetMyPos();

  i := WALKER_ARRAY.IndexOf(Self.Name);
  HeightMap := WALKER_HEIGHT_ARRAY[i];

  P -= WALKER_OFFSET_ARRAY[i];

  Result := HeightMap.GetPixel(P.X, P.Y);
end;

procedure TRSWalker.DebugHeightPosition();
var
  P: TPoint;
  i: Int32;
  Color: Int64;
  HeightMap: TMufasaBitmap;
begin
  i := WALKER_ARRAY.IndexOf(Self.Name);

  HeightMap := TMufasaBitmap.Create();
  HeightMap.LoadFromBitmap(WALKER_HEIGHT_ARRAY[i]);

  P := (Self.GetMyPos() - WALKER_OFFSET_ARRAY[i]);

  Color := HeightMap.GetPixel(P.X, P.Y);
  WriteLn Color * MAX_WALKER_HEIGHT / $FFFFFF;

  HeightMap.DrawCross(P, 4, 1, $00FFFF);
  HeightMap.Show();

  HeightMap.Free();
end;

procedure TRSWalker.DebugHeightTiles(Angle: Double = -1);
var
  Position: TPoint;
  TempTile: TPoint;
  CurrentHeight, TileHeight, HeightDiff: Double;

  BMP: TMufasaBitmap;
  X, Y: Int32;
  Tile: Vector3;
  TPA: TPointArray;
begin
  if Angle = -1 then
    Angle := Minimap.GetCompassAngle(False);

  Position := Self.GetMyPos();
  CurrentHeight := Self.GetHeight(Position);

  BMP := TMufasaBitmap.CreateFromClient();

  for X := Minimap.Center.X - 25 * 4 to Minimap.Center.X + 25 * 4 with 4 do
    for Y := Minimap.Center.Y - 25 * 4 to Minimap.Center.Y + 25 * 4 with 4 do
    begin

      TempTile := Position + ([X, Y] - Minimap.Center);
      TempTile := TempTile.Rotate(-Angle, Position);
      TileHeight := Self.GetHeight(TempTile);
      HeightDiff := CurrentHeight-TileHeight;

      Tile := Vec3(X, Y, HeightDiff).RotateXY(Angle, Minimap.Center.X, Minimap.Center.Y);
      TPA := Minimap.VecToMsRect(Tile, 1, 1, Angle).ToTPA().Connect();

      if MainScreen.IsVisible(TPA) then
        BMP.DrawTPA(TPA, Round(TileHeight * ($00ff00 + $00ff00)/ MAX_WALKER_HEIGHT));
    end;

  BMP.Show();
  BMP.Free();
end;


(*
TRSWalker.IsWalkable
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;

Overriden to change the default behavior of TRSWalker.IsWalkable(), specifically for ScreenWalking since I don't like the default behaviour.
I find that minimap limits is extremely close to the render distance in the mainscreen, so personally I rather not
have the function bother any further if **WorldPoint** is not on the minimap.

This override will affect both TRSWalker and TRSWalker.
*)
function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;
var
  MinimapPoint: TPoint;
  R: TRectangle;
begin
  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Angle);

  Result := Minimap.IsPointOn(MinimapPoint, -1);

  if Result and Self.ScreenWalk then
  begin
    R := Minimap.PointToMSRect(MinimapPoint, Angle);
    Result := MainScreen.IsVisible(R.Mean()) and (CountColor($000000, R.Bounds.Expand(0, MainScreen.Bounds)) = 0);
  end;
end;


(*
TRSWalker.AtTile
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.AtTile(WorldPoint: TPoint; Distance: Int32 = 4): Boolean;
.. pascal:: function TRSWalker.AtTile(WorldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;

Method used to quickly check if we are within distance of a certain **WorldPoint**. This distance is measure in pixels and in a radial way.
You can optionally pass in a TPA to check if the closest point is within distance.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.AtTile(WorldPoint: TPoint; Distance: Int32 = 4): Boolean;
begin
  Result := Self.GetMyPos().WithinDistance(WorldPoint, Distance);
end;

function TRSWalker.AtTile(WorldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;
begin
  Result := Self.GetMyPos().WithinDistance(WorldPointArray, Distance);
end;



(*
TRSWalker.GetClosestPoint
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetClosestPoint(WorldPointArray: TPointArray): TPoint;

Method used to get the closest Point to the Player out of a TPA.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.GetClosestPoint(WorldPointArray: TPointArray): TPoint;
begin
  if WorldPointArray <> [] then
    Result := WorldPointArray.Sorted(Self.GetMyPos())[0];
end;

(*
TRSWalker.WebWalk
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;

Method used to webwalk to the closest Point to the player.
An example use case is for example, if you have sevel bank booths you can use, those would be your **Destination** TPA.
You will likely want to use the closest bank booth to you, so you use this.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestPoint(Destination), WaitUntilDistance, PathRandomness);
end;


(*
TRSWalker.WorldToMM
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;

Overloaded methods required for TRSDotFilter. For more information on TRSDotFilter check their documentation.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
var
  P: TPoint;
begin
  for P in WorldPoints do
    Result += Self.WorldToMM(PlayerPoint, P, Radians);
end;

function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), WorldPoints, Minimap.GetCompassAngle(False));
end;

function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
var
  P: TPoint;
begin
  if DotFilter.Circle <> [] then
  begin
    P := Self.WorldToMM(DotFilter.Circle.Mean());
    Result.Circle := [P.X, P.Y, DotFilter.Circle.Radius];
  end;

  Result.TPA      := Self.WorldToMM(DotFilter.TPA);
  Result.Inside   := DotFilter.Inside;
  Result.HasTimer := DotFilter.HasTimer;
  Result.Timer    := DotFilter.Timer;
end;

function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;
var
  DotFilter: TRSDotFilter;
begin
  for DotFilter in DotFilterArray do
    Result += Self.WorldToMM(DotFilter);
end;


(*
TRSWalker.MakePointVisible
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.MakePointVisible(P: TPoint): Boolean;
.. pascal:: function TRSWalker.MakePointVisible(TPA: TPointArray): Boolean; overload;

Wrapper function used to attempt to make a Point visible on the MainScreen.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.MakePointVisible(P: TPoint): Boolean;
begin
  Result := Minimap.MakePointVisible(Self.WorldToMM(P));
end;

function TRSWalker.MakePointVisible(TPA: TPointArray): Boolean; overload;
begin
  Result := Minimap.MakePointVisible(Self.WorldToMM(Self.GetClosestPoint(TPA)));
end;

(*
TRSWalker.GetPolygonMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray;
.. pascal:: function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray; overload;

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.
This calls **TRSMinimap.GetPolygonMS()** internally which in turn will use both methods above.

To put it simply, this will will first calculate a floor rectangle with **TileVector.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **TileVector.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon:

Example
-------
  Debug(RSW.GetPolygonMS([100, 100], [1, 1, 4], Offset));     //This will draw a polygon around the coordinate [100, 100].
*)
function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly;
var
  Angle: Double;
begin
  Angle := Minimap.GetCompassAngle(False);
  Loc   := Self.WorldToMM(Me, Loc, Angle);

  Result := Minimap.GetPolygonMS(Loc, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly; overload;
begin
  Result := Self.GetPolygonMS(Self.GetMyPos(), Loc, TileVector, Offset);
end;


(*
TRSWalker.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
.. pascal:: function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;

This are wrapper functions to retrieve multiple tiles. Refer to SRL's TRSWalker.GetTileMSEx() and TRSWalker.GetTileMS() for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
var
  Loc: TPoint;
begin
  for Loc in LocArray.Sorted(Me) do
    Result += Self.GetTileMSEx(Me, Loc, TileVector, Offset);
end;

function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos(), LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetPolygonArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;
.. pascal:: function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetPolygonMS** for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetPolygonArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray;
var
  Angle: Double;
  i: Int32;
  tmpArray: TPointArray;
begin
  Angle := Minimap.GetCompassAngle(False);
  tmpArray := Copy(LocArray);

  for i := 0 to High(tmpArray) do
    tmpArray[i] := Self.WorldToMM(Me, LocArray[i], Angle);

  Result := Minimap.GetPolygonArrayMS(tmpArray, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray; overload;
begin
  Result := Self.GetPolygonArrayMS(Self.GetMyPos(), LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetMMPoly
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;

This function converts a list of points to their respective points in the minimap.
This is extremely useful if you want to be sure you are within an area.
To make a polygon or a polygon array easily you can use Simba/Includes/WaspLib/tools/walkerpolygon.simba.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

Example
-------
  Debug(RSW.GetMMPoly(TPA).Connect());    //This will draw your TPA on the minimap.
*)
function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;
begin
  Result := Self.WorldToMM(LocArray);
end;

(*
TRSWalker.InPoly
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.InPoly(LocArray: TPointArray): Boolean;

Checks if you are inside a polygon. If you need to debug the polygon check the example in TRSWalker.GetMMPoly.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

*)
function TRSWalker.InPoly(LocArray: TPointArray): Boolean;
begin
  Result := SRL.PointInPoly(Self.GetMyPos(), LocArray);
end;

begin
  TRSMap.Setup(ZEAH_MAP, [0, 0, 3661, 3612]);
  TRSMap.Setup(MAINLAND_MAP, [3661, 33960, 10560, 5534]);

  TRSMap.Setup(SLAYER_TOWER_BASEMENT_AND_UPPERLEVEL_MAP, [4702, 0, 902+4702, 357]);
  TRSMap.Setup(SLAYER_TOWER_GROUNDFLOOR_MAP, [8931, 2044, 8931+354, 2044+358]);
  TRSMap.Setup(CHASM_OF_FIRE_MAP, [0, 0, 397, 906]);
  TRSMap.Setup(CATACOMBS_OF_KOUREND_MAP, [0, 2721, 966, 688+2721]);
  TRSMap.Setup(KARUULM_SLAYER_DUNGEON_MAP, [313, 0, 1119+313, 814]);
  TRSMap.Setup(FREMMENNIK_SLAYER_CAVE_MAP, [2348, 2903, 2348+654, 2903+530]);

  TRSMap.Setup(LUNAR_ISLAND_MAP, [4127, 1027, 4127+620, 1027+622]);
  TRSMap.Setup(ASGARNIA_ICE_DUNGEON_MAP, [5374, 1144, 6000, 1600]);
  TRSMap.Setup(SMOKE_DUNGEON_MAP, [212, 3352, 1100, 4600]);
  TRSMap.Setup(IORWERTH_DUNGEON_MAP, [3002, 2756, 3610, 2756+664]);
  TRSMap.Setup(MOURNER_TUNNELS_MAP, [7090, 5135, 7500, 5550]);

  TRSMap.Setup(CORSAIR_COVE_DUNGEON_MAP, [8923, 5104, 9500, 5550]);
  TRSMap.Setup(MOSLE_HARMLESS_CAVE_MAP, [0, 3332, 652, 648+3332]);
  TRSMap.Setup(GIANTS_DEN_MAP, [2560, 3229, 2560+388, 3229+394]);
  TRSMap.Setup(STRONGHOLD_SLAYER_DUNGEON_MAP, [3066, 5085, 3700, 5650]);
  TRSMap.Setup(KALPHITE_CAVE_MAP, [573, 3356, 1044, 3800]);
  TRSMap.Setup(KALPHITE_LAIR_MAP, [996, 3340, 996+385, 3340+351]);
  TRSMap.Setup(KRAKEN_COVE_MAP, [10147, 1006, 10560, 1414]);
  TRSMap.Setup(GRAND_EXCHANGE_MAP, [7789, 2306, 7789+557, 2306+605]);
  TRSMap.Setup(WEST_VARROCK_MAP, [7789, 2306, 7789+557, 2306+605]);
  TRSMap.Setup(WINTERTODT_MAP, [1750, 270, 2080, 830]);

  TRSMap.Setup(LUMBRIDGE_MAP, [7850, 2950, 8700, 4000]);
  TRSMap.Setup(BARBARIAN_VILLAGE_MAP, [7580, 2516, 8100, 3050]);
  TRSMap.Setup(OTTOS_GROTTO_MAP, [5201, 2030, 5810, 2700]);
  TRSMap.Setup(ZULANDRA_MAP, [3960, 4030, 4500, 4400]);
  TRSMap.Setup(PISCARILIUS_MAP, [2444, 1122, 2950, 1500]);
  TRSMap.Setup(SMOKE_DEVIL_DUNGEON_MAP, [5346, 5184, 5800, 5510]);
  TRSMap.Setup(WC_GUILD_MAP, [1564, 2293, 1564+541, 2293+349]);

  TRSMap.Setup(BRIMHAVEN_DUNGEON_MAP, [1272, 4048, 1930, 4960]);
  TRSMap.Setup(VARROCK_MAP, [7536, 2363, 8702, 3166]);
  TRSMap.Setup(ABYSS_MAP, [9670, 4424, 9670+889, 4424+914]);
  TRSMap.Setup(FALADOR_MAP, [7051, 2796, 7051+661, 2796+445]);
  TRSMap.Setup(CRAFTING_GUILD_MAP, [6990, 3206, 7261, 3465]);
  TRSMap.Setup(CRAFTING_GUILD_UPSTAIRS_MAP, [10298, 5441, 10484, 5631]);

  TRSMap.Setup(GUARDIANS_OF_THE_RIFT_MAP, [7484, 5232, 7878, 5640]);
  TRSMap.Setup(ALTARS_MAP, [6937, 0, 10559, 376]);
  TRSMap.Setup(MOTHERLOAD_MAP, [7423, 4735, 7827, 5133]);
  TRSMap.Setup(KOUREND_RUNECRAFTING_MAP, [1860, 737, 2818, 1259]);
  TRSMap.Setup(ARDOUGNE_MAP, [5608, 3032, 6184, 3476]);
  TRSMap.Setup(PRIFDDINAS_MAP, [3590, 1897, 4238, 2546]);
  TRSMap.Setup(EDGEVILLE_AND_BARBARIAN_VILLAGE_MAP, [7500, 2263, 8058, 2960]);
  TRSMap.Setup(EAST_VARROCK_MAP, [8235, 2362, 8723, 3119]);
  TRSMap.Setup(GIANTS_FOUNDRY_MAP, [4231, 3009, 4473, 3262]);
  TRSMap.Setup(HOSIDIUS_FRUIT_STALL_HOUSE_MAP, [2467, 1907, 2713, 2143]);
  TRSMap.Setup(HOSIDIUS_KITCHEN_MAP, [1988, 1873, 2251, 2118]);
  TRSMap.Setup(ROGUES_DEN_MAP, [10262, 799, 10557, 1079]);
  TRSMap.Setup(BLAST_FURNACE_MAP, [10296, 1404, 10560, 1648]);
  TRSMap.Setup(CASTLE_WARS_MAP, [4676, 3838, 5312, 4342]);
  TRSMap.Setup(AL_KHARID_MAP, [8356, 3096, 9171, 4090]);
  TRSMap.Setup(HESPORI_MAP, [412, 3702, 657, 3946]);
  TRSMap.Setup(CATHERBY_MAP, [6495, 2463, 6910, 2846]);
  TRSMap.Setup(SEERS_VILLAGE_MAP, [6050, 2360, 6536, 2754]);
  TRSMap.Setup(DRAYNOR_VILLAGE_MAP, [7596, 3267, 7976, 3654]);
  TRSMap.Setup(MINING_GUILD_MAP, [6243, 384, 6699, 792]);
  TRSMap.Setup(RIMMINGTON_MAP, [6988, 3362, 7386, 3705]);
  TRSMap.Setup(TZHAAR_MAP, [4349, 332, 5201, 980]);
  TRSMap.Setup(KBD_AND_NMZ_MAP, [5270, 264, 5623, 599]);
  TRSMap.Setup(YANILLE_MAP, [5509, 3879, 5955, 4193]);
  TRSMap.Setup(WOODCUTTING_GUILD_MAP, [1588, 2321, 2093, 2617]);
end;
