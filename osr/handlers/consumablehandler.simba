(*
ConsumableHandlers and Managers
===============================
*)

{$DEFINE WL_CONSUMABLEHANDLER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
(*
type TConsumableHandler
~~~~~~~~~~~~~~~~~~~~~~~

Consumable handler is the record responsible to handle `TRSConsumables <https://torwent.github.io/WaspLib/consumables.html>`_.
This will handle caching all found consumables to this point, bank withdraw amounts, timer if the last consumable had a timer, etc.
*)
  TConsumableHandler = record(TSRLBaseRecord)
    ConsumableType: ERSConsumable;
    ConsumableArray: TRSConsumableArray;

    Amount: Int32;
    MinInvPoints: Int32;

    Timer: TCountDown;

    IsSetup: Boolean;
  end;

(*
type PConsumableHandler
~~~~~~~~~~~~~~~~~~~~~~~

Wrapper type of a TConsumableHandler pointer.
*)
  PConsumableHandler = ^TConsumableHandler;

(*
ConsumableHandler.Setup()
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.Setup(Item: TRSItem): TRSConsumable;

Used internally to add a TRSConumable to TConsumableHandler.ConsumableArray.

Example
-------

  FoodHandler.Setup('Shark');
*)
function TConsumableHandler.Setup(Item: TRSItem): TRSConsumable;
begin
  Result.Item := Item;

  case Self.ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Result.SetupFood;
    ERSConsumable.PRAYER_CONSUMABLE:    Result.SetupPrayer;
    ERSConsumable.ENERGY_CONSUMABLE:    Result.SetupEnergy;
    ERSConsumable.POISON_CONSUMABLE:    Result.SetupAntiPoison;
    ERSConsumable.VENOM_CONSUMABLE:     Result.SetupAntiVenom;
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Result.SetupAntiFire;
    ERSConsumable.BOOST_CONSUMABLE:     Result.SetupBoost;
  end;
end;

(*
ConsumableHandler.FindInBank()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.FindInBank(): TRSConsumableArray;

Returns an TRSConsumableArray of all TRSConsumables of **TConsumableHandler.ConsumableType** found in the bank window.
*)
function TConsumableHandler.FindInBank(): TRSConsumableArray;
var
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  Self.DebugLn('Setting up consumable of type: ' + ToStr(Self.ConsumableType));

  for Item in GetConsumableArray(Self.ConsumableType) do
  begin
    if Self.ConsumableArray.Contains(Item) then //avoid resetting items.
      Continue;

    if Bank.FindItem(Item.Reorder(False)) then
    begin
      Self.DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self.Setup(Item);
      Consumable.BankTab := Bank.GetCurrentTab(); //TODO: Search parent maybe?

      Result += Consumable;
    end;
  end;
end;

(*
ConsumableHandler.FindInInventory()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.FindInInventory(): TRSConsumableArray;

Returns an TRSConsumableArray of all TRSConsumables of **TConsumableHandler.ConsumableType** found in the inventory.
*)
function TConsumableHandler.FindInInventory(): TRSConsumableArray;
var
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  Self.DebugLn('Setting up consumable of type: ' + ToStr(Self.ConsumableType));

  for Item in GetConsumableArray(Self.ConsumableType) do
  begin
    if Self.ConsumableArray.Contains(Item) then //avoid resetting leftover items.
      Continue;

    if Inventory.FindItem(Item) then
    begin
      Self.DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self.Setup(Item);

      Result += Consumable;
    end;
  end;
end;

(*
ConsumableHandler.NeedToConsume()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.NeedToConsume(): Boolean;

Returns an **True** if there's a timer setup and it has ran out.
*)
function TConsumableHandler.NeedToConsume(): Boolean;
begin
  if not Self.IsSetup then
    Exit;

  Result := ((Self.Timer.Length > 0) and Self.Timer.IsFinished())
            or Self.Timer.IsPaused();
end;

(*
ConsumableHandler.Setup()
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TConsumableHandler.Setup(ConsumableType: ERSConsumable); overload;

Overloaded function used to setup TConsumableHandler.ConsumableArray by TConsumableHandler.ConsumableType.
This will use TConsumableHandler.FindInInventory() or TConsumableHandler.FindInBank() by that order to setup
found TRSConsumables.
*)
procedure TConsumableHandler.Setup(ConsumableType: ERSConsumable); overload;
var
  C: TRSConsumable;
begin
  if Self.IsSetup then
    Exit;

  Self.ConsumableType := ConsumableType;

  case Self.ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Self.Name := 'FoodHandler';
    ERSConsumable.PRAYER_CONSUMABLE:    Self.Name := 'PrayerHandler';
    ERSConsumable.ENERGY_CONSUMABLE:    Self.Name := 'EnergyHandler';
    ERSConsumable.POISON_CONSUMABLE:    Self.Name := 'PoisonHandler';
    ERSConsumable.VENOM_CONSUMABLE:     Self.Name := 'VenomHandler';
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Self.Name := 'AntiFireHandler';
    ERSConsumable.BOOST_CONSUMABLE:     Self.Name := 'BoostHandler';
  end;

  if Inventory.Open() then
    Self.ConsumableArray := Self.FindInInventory();

  if (Self.ConsumableArray = []) and Bank.IsOpen() then
    Self.ConsumableArray := Self.FindInBank();

  Self.IsSetup := Self.ConsumableArray <> [];

  if Self.IsSetup and (C.Timer > 0) then
    Self.Timer.Setup(C.Timer);
end;

var
(*
var FoodHandler
~~~~~~~~~~~~~~~

Global FoodHandler variable. This handler is the one responsible for handling FOOD_CONSUMABLE.

var PrayerHandler
~~~~~~~~~~~~~~~~~

Global PrayerHandler variable. This handler is the one responsible for handling PRAYER_CONSUMABLE.

var EnergyHandler
~~~~~~~~~~~~~~~~~

Global EnergyHandler variable. This handler is the one responsible for handling ENERGY_CONSUMABLE.

var PoisonHandler
~~~~~~~~~~~~~~~~~

Global PoisonHandler variable. This handler is the one responsible for handling POISON_CONSUMABLE.

var VenomHandler
~~~~~~~~~~~~~~~~

Global VenomHandler variable. This handler is the one responsible for handling VENOM_CONSUMABLE.

var AntifireHandler
~~~~~~~~~~~~~~~~~~~

Global AntifireHandler variable. This handler is the one responsible for handling ANTI_FIRE_CONSUMABLE.

var BoostHandler
~~~~~~~~~~~~~~~~

Global BoostHandler variable. This handler is the one responsible for handling BOOST_CONSUMABLE.
*)
  FoodHandler: TConsumableHandler;
  PrayerHandler: TConsumableHandler;
  EnergyHandler: TConsumableHandler;
  PoisonHandler: TConsumableHandler;
  VenomHandler: TConsumableHandler;
  AntifireHandler: TConsumableHandler;
  BoostHandler: TConsumableHandler;

(*
GetHandler()
~~~~~~~~~~~~
.. pascal:: function GetHandler(ConsumableType: ERSConsumable): PConsumableHandler;

Method to return a pointer to the right handler for each ConsumableType passed in.
*)
function GetHandler(ConsumableType: ERSConsumable): PConsumableHandler;
begin
  case ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Result := @FoodHandler;
    ERSConsumable.PRAYER_CONSUMABLE:    Result := @PrayerHandler;
    ERSConsumable.ENERGY_CONSUMABLE:    Result := @EnergyHandler;
    ERSConsumable.POISON_CONSUMABLE:    Result := @PoisonHandler;
    ERSConsumable.VENOM_CONSUMABLE:     Result := @VenomHandler;
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Result := @AntifireHandler;
    ERSConsumable.BOOST_CONSUMABLE:     Result := @BoostHandler;
  end;

  Result^.Setup(ConsumableType);
end;

(*
Inventory.FindItems()
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.FindItems(Items: TRSConsumableArray; out FoundItems: TRSConsumableArray; out Slots: TIntegerArray): Boolean; overload;

Overloaded method used to find consumables in the inventory. Can be used directly but in most cases is used internally.
*)
function TRSInventory.FindItems(Items: TRSConsumableArray; out FoundItems: TRSConsumableArray; out Slots: TIntegerArray): Boolean; overload;
var
  SingleItem: TRSItem;
  Item: TRSConsumable;
  i: Int32;
  TBA, tmp: TBoxArray;
  UsedSlots, TempSlots, CurrentSearch: TIntegerArray;
begin
  if not Self.Open() then
    Exit;

  TBA := Self.GetSlotBoxes();
  for i:=0 to High(TBA) do
    if Self.IsSlotUsed(TBA[i]) then
    begin
      tmp += TBA[i];
      UsedSlots += i;
    end;

  for Item in Items do
  begin
    for SingleItem in Item.Item.GetArray() do
    begin
      CurrentSearch := ItemFinder.Find(SingleItem, tmp);
      if CurrentSearch <> [] then
      begin
        FoundItems += Item;
        TempSlots += CurrentSearch;
      end;
    end;
  end;

  for i in TempSlots do
    Slots += UsedSlots[i];

  Slots.ClearDuplicates();

  Result := Length(Slots) > 0;
end;

(*
Inventory.FindConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.FindConsumable(ConsumableType: ERSConsumable; out FoundConsumables: TRSConsumableArray; out Slots: TIntegerArray): Boolean;
.. pascal:: function TRSInventory.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;

Method used to find already setup consumables in the inventory. Can be used directly but in most cases is used internally.
*)
function TRSInventory.FindConsumable(ConsumableType: ERSConsumable; out FoundConsumables: TRSConsumableArray; out Slots: TIntegerArray): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindItems(ConsumableHandler^.ConsumableArray.Reversed, FoundConsumables, Slots);
end;

function TRSInventory.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;
var
  FoundItems: TRSConsumableArray;
  Slots: TIntegerArray;
begin
  Result := Self.FindConsumable(ConsumableType, FoundItems, Slots);
end;

(*
Inventory.Consume()
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.Consume(ConsumableType: ERSConsumable; out Slots: TIntegerArray): Boolean;
.. pascal:: function TRSInventory.Consume(ConsumableType: ERSConsumable): Boolean; overload;

Methods used to consume consumables.

Example
-------

  Inventory.Consume(FOOD_CONSUMABLE);
*)
function TRSInventory.Consume(ConsumableType: ERSConsumable; out Slots: TIntegerArray): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  FoundConsumables: TRSConsumableArray;
  StartingPoints: Int32;
  TrashSlots: TIntegerArray;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  case ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:
      StartingPoints := Minimap.GetHPLevel;

    ERSConsumable.PRAYER_CONSUMABLE:
      StartingPoints := Minimap.GetPrayerLevel;

    ERSConsumable.ENERGY_CONSUMABLE:
      StartingPoints := Minimap.GetRunEnergy;
  end;

  if not Self.FindConsumable(ConsumableType, FoundConsumables, Slots) then
    Exit;

  if not Antiban.BioDice(EBioBehavior.CONSUME_IN_BANK) and
     MainScreen.HasInterface then
     MainScreen.CloseInterface;

  Result := Self.ClickSlot(Slots[0], ['Eat', 'Drink']);

  if Result then
    case ConsumableType of
      ERSConsumable.FOOD_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetHPLevel, 100, 3000);

      ERSConsumable.PRAYER_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetPrayerLevel, 100, 3000);

      ERSConsumable.ENERGY_CONSUMABLE:
        Result := WaitUntil(StartingPoints < Minimap.GetRunEnergy, 100, 3000);
      else
        Wait(400, 650);
    end;

  if Result then
  begin
    if FoundConsumables[0].Timer > 0 then
    begin
      if ConsumableType = ERSConsumable.ANTI_FIRE_CONSUMABLE then
        ConsumableHandler^.Timer.Restart(Random(-50000, -20000))
      else
        ConsumableHandler^.Timer.Restart(Random(-3000, 3000));
    end;

    TotalConsumableCost += FoundConsumables[0].Cost;

    if Inventory.FindItems(TRASH_ARRAY, TrashSlots) then
    begin
      if Bank.IsOpen then
        Bank.DepositSlot([TrashSlots[0], BANK_DEPOSIT_ALL], False)
      else
        Inventory.ShiftDrop(TrashSlots.Intersection(Inventory.RandomPattern()));

      Slots := Slots.Difference(TrashSlots); //Delete TrashSlots from Slots.
    end;
  end;
end;

function TRSInventory.Consume(ConsumableType: ERSConsumable): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.Consume(ConsumableType, Slots);
end;


(*
Inventory.CountConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.CountConsumable(ConsumableType: ERSConsumable): Int32;

Method used to count each slot that has a consumable of **ConsumableType**.

Example
-------

  WriteLn Inventory.CountConsumable(FOOD_CONSUMABLE);
*)
function TRSInventory.CountConsumable(ConsumableType: ERSConsumable): Int32;
var
  FoundConsumables: TRSConsumableArray;
  Slots: TIntegerArray;
begin
  Self.FindConsumable(ConsumableType, FoundConsumables, Slots);

  Result := Length(Slots);
end;

(*
Inventory.CountEachConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.CountEachConsumable(ConsumableType: ERSConsumable): TIntegerArray;

Method used to count each type of consumable of **ConsumableType**.

Example
-------

  WriteLn Inventory.CountEachConsumable(FOOD_CONSUMABLE);
*)
function TRSInventory.CountEachConsumable(ConsumableType: ERSConsumable): TIntegerArray;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Item: TRSConsumable;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  for Item in ConsumableHandler^.ConsumableArray do
    Result += Self.CountItem(Item.Item);
end;

(*
Inventory.CountPoints()
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.CountPoints(Consumable: TRSConsumable): Int32;
.. pascal:: function TRSInventory.CountPoints(ConsumableType: ERSConsumable): Int32; overload;

Method used to count the total points value of a **Consumable** or **ConsumableType**.

Example
-------

  WriteLn Inventory.CountPoints(FOOD_CONSUMABLE); //Assumind you have 3 sharks in your inventory, 60 will be printed.
*)
function TRSInventory.CountPoints(Consumable: TRSConsumable): Int32;
var
  i: Int32;
  Items: TRSItemArray;
begin
  Items := Consumable.Item.GetArray();

  for i := 0 to High(Items) do
    Result += Inventory.CountItem(Items[i]) * Consumable.Points * (i + 1);
end;

function TRSInventory.CountPoints(ConsumableType: ERSConsumable): Int32; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Consumable: TRSConsumable;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  for Consumable in ConsumableHandler^.ConsumableArray do
    Result += Self.CountPoints(Consumable);
end;

(*
Inventory.HasEnoughConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean;

Method used to figure out if we are low on a type of consumable.

Example
-------

  if not Inventory.HasEnoughConsumable(FOOD_CONSUMABLE) then
    Bank.WithdrawItem(['Shark', 5, False], False);
*)
function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  Result := Self.CountPoints(ConsumableType) >= ConsumableHandler^.MinInvPoints;
end;


(*
Bank.FindConsumable()
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray; out Consumable: TRSConsumable): Boolean;
.. pascal:: function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray): Boolean; overload;
.. pascal:: function TRSBank.FindConsumable(ConsumableType: ERSConsumable; out Consumable: TRSConsumable): Boolean; overload;
.. pascal:: function TRSBank.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;

Method used to find already setup consumables in the bank. Can be used directly but in most cases is used internally.

Example
-------

  WriteLn Bank.FindConsumable(FOOD_CONSUMABLE);
*)
function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray; out Consumable: TRSConsumable): Boolean;
begin
  for Consumable in ConsumableArray do
    if Self.FindItem(Consumable.Item) then
      Exit(True);
end;

function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray): Boolean; overload;
var
  Consumable: TRSConsumable;
begin
  Result := Self.FindConsumable(ConsumableArray, Consumable);
end;

function TRSBank.FindConsumable(ConsumableType: ERSConsumable; out Consumable: TRSConsumable): Boolean; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindConsumable(ConsumableHandler^.ConsumableArray, Consumable);
end;

function TRSBank.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindConsumable(ConsumableHandler^.ConsumableArray);
end;


(*
Bank.CountPoints()
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.CountPoints(Consumable: TRSConsumable): Int32;

Method used to count the points of the first dose/portion of a consumable found in bank.
This prioritizes higher dosage visible ones first and returns only just that one.
*)
function TRSBank.CountPoints(Consumable: TRSConsumable): Int32;
var
  i: Int32;
  Items: TRSItemArray;
begin
  Items := Consumable.Item.Reorder(False).GetArray();

  for i := 0 to High(Items) do
    if Self.FindItem(Items[i]) then
      Exit(Consumable.Points * Items[i].GetPortion());
end;

(*
Bank.WithdrawConsumableAmount()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable): Int32;
.. pascal:: function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Consumable: TRSConsumable): Int32; overload;

Method used to return the amount we need to withdraw to meet the TRSConsumable.MinInvPoints.
*)
function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable): Int32;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Consumable: TRSConsumable;
begin
  for Consumable in ConsumableHandler^.ConsumableArray do
  begin
    case ConsumableHandler^.Amount of
      BANK_WITHDRAW_ALL:         Result := BANK_WITHDRAW_ALL;
      BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
      else
        Result := Ceil((ConsumableHandler^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / Self.CountPoints(Consumable));
    end;

    if Result > 0 then
      Exit;
  end;
end;

function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Consumable: TRSConsumable): Int32; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
    case ConsumableHandler^.Amount of
      BANK_WITHDRAW_ALL: Result := BANK_WITHDRAW_ALL;
      BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
      else
        Result := Ceil((ConsumableHandler^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / Self.CountPoints(Consumable));
    end;
end;

(*
Bank.WithdrawConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.WithdrawConsumable(ConsumableType: ERSConsumable): Boolean;

Method used to withdraw a consumable type.

Example
-------

  FoodHandler.MinInvPoints := 100;

  Bank.WithdrawConsumable(FOOD_CONSUMABLE); //This will withdraw FOOD_CONSUMABLEs until we have 100 points value of food in our inventory.
*)
function TRSBank.WithdrawConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  WithdrawAmount: Int32;
  Consumable: TRSConsumable;
begin
  if not Self.FindConsumable(ConsumableType, Consumable) then
  begin
    if not ConsumableHandler^.IsSetup then
      Exit;

    if ConsumableHandler^.ConsumableArray[0].BankTab < 0 then
      ConsumableHandler^.ConsumableArray[0].BankTab := Self.FindItemTab(Consumable.Item)
    else
      Self.OpenTab(ConsumableHandler^.ConsumableArray[0].BankTab);

    if not Self.FindConsumable(ConsumableType, Consumable) then
      Exit;
  end;

  WithdrawAmount := Self.WithdrawConsumableAmount(ConsumableType, Consumable);

  if WithdrawAmount <= 0 then
    Exit(True); //We have enough food.

  Self.WithdrawItem(Consumable.BankTab, [Consumable.Item, WithdrawAmount, False], False);

  Result := WaitUntil(Inventory.HasEnoughConsumable(ConsumableType), 100, 3000);
end;

//overrides
procedure TConsumablePanel.Init();
var
  i: Int32;
begin
  if not Self.IsSetup then
    Exit;

  i := Self.ConsumableSelector.GetItemIndex();

  if i > -1 then
    case Self.ConsumableType of
      FOOD_CONSUMABLE: FoodHandler.Setup(FOOD_ARRAY[i]);
      PRAYER_CONSUMABLE: PrayerHandler.Setup(PRAYER_ARRAY[i]);
      ENERGY_CONSUMABLE: EnergyHandler.Setup(ENERGY_ARRAY[i]);
      BOOST_CONSUMABLE:  BoostHandler.Setup(BOOST_ARRAY[i]);
    end;
end;

procedure TScriptForm.Init(Sender: TObject); override;
begin
  inherited;
  Self.WLPanel.FoodPanel.Init();
  Self.WLPanel.PrayerPanel.Init();

  //override me to add stuff!
end;

