{$DEFINE WL_PIXELSHIFT_INCLUDED}
{$IFNDEF WL_UTILS}
  {$I WaspLib/utils.simba}
{$ENDIF}

// Should add all this to SRL
// This are color specific GetPixelShift. Will only take into account pixelshifts involving the specified color.
// This is super useful for certain things and cab be used to pretty accurately decide if we are performing certain animations
// like swinging an axe or a pickaxe.
function TSRL.GetColorPixelShift(color: TCTS0Color; area: TBox; waitTime: UInt32): Int32; overload;
var
  before, after: TMufasaBitmap;
  tpa: TPointArray;
  atpa: T2DPointArray;
  maxTime: UInt64;
begin
  maxTime := GetTickCount() + waitTime;

  if WaitUntil(SRL.FindColors(tpa, color, area) > 0, 100, waitTime) then
  begin
    atpa := tpa.Cluster(2);
    tpa := atpa.Largest();
    area := tpa.Bounds();
  end else
    Exit;

  before := TMufasaBitmap.CreateFromClient(area);
  Wait(maxTime - GetTickCount());
  after := TMufasaBitmap.CreateFromClient(area);
  Result := before.PixelDifference(after);

  before.Free();
  after.Free();
end;

function TSRL.IsColorAnimating(Color: TCTS0Color; area:TBox; Shift, waitTime:UInt32; Iter:UInt32=1): Boolean; overload;
var
  i:Int32;
begin
  for i:=1 to Iter do
    if (Self.GetColorPixelShift(Color, area, waitTime) > shift) then
      Exit(True);
end;


function TSRL.GetColorPixelShift(color: TCTS1Color; area: TBox; waitTime: UInt32): Int32; overload;
var
  before, after: TMufasaBitmap;
  tpa: TPointArray;
  atpa: T2DPointArray;
  maxTime: UInt64;
begin
  maxTime := GetTickCount + waitTime;

  if WaitUntil(SRL.FindColors(tpa, color, area) > 0, 100, waitTime) then
  begin
    atpa := tpa.Cluster(2);
    tpa := atpa.Largest();
    area := tpa.Bounds();
  end
  else
    Exit;

  before := TMufasaBitmap.CreateFromClient(area);
  Wait(waitTime);
  after := TMufasaBitmap.CreateFromClient(area);

  Result := before.PixelDifference(after);

  before.Free();
  after.Free();
end;

function TSRL.IsColorAnimating(Color: TCTS1Color; area:TBox; Shift, waitTime:UInt32; Iter:UInt32=1): Boolean; overload;
var
  i:Int32;
begin
  for i:=1 to Iter do
    if (Self.GetColorPixelShift(Color, area, waitTime) > shift) then
      Exit(True);
end;


function TSRL.GetColorPixelShift(Color: TCTS2Color; area: TBox; waitTime: UInt32): Int32; overload;
var
  before, after: TMufasaBitmap;
  tpa: TPointArray;
  atpa: T2DPointArray;
  maxTime: UInt64;
begin
  maxTime := GetTickCount + waitTime;

  if WaitUntil(SRL.FindColors(tpa, Color, area) > 0, 100, waitTime) then
  begin
    atpa := tpa.Cluster(2);
    tpa := atpa.Largest();
    area := tpa.Bounds();
  end
  else
    Exit;

  before := TMufasaBitmap.CreateFromClient(area);
  Wait(waitTime);
  after := TMufasaBitmap.CreateFromClient(area);

  Result := before.PixelDifference(after);

  before.Free();
  after.Free();
end;

function TSRL.IsColorAnimating(color: TCTS2Color; area:TBox; Shift, waitTime:UInt32; Iter:UInt32=1): Boolean; overload;
var
  i:Int32;
begin
  for i:=1 to Iter do
    if (Self.GetColorPixelShift(color, area, waitTime) > shift) then
      Exit(True);
end;

function TSRL.PercentShift(area: TBox; waitTime: Int32): Int32;
var
  tLen,sLen: Int32;
begin
  tLen := length(TPointArray.CreateFromBox(area, True));
  sLen := SRL.GetPixelShift(area, waitTime);
  Result := Round((sLen/tLen)*100);
end;

