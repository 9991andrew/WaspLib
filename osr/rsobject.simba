{$DEFINE WL_RSOBJECT_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  PRSObject = ^TRSObject;

  TRSObject = record
    Map: PRSWalker;
    Tiles: TPointArray;
    Height: Int32;
    Finder: TRSObjectFinder;
    UpText: TStringArray;
    Filter: record
      Walker: Boolean;
      Finder: Boolean;
      UpText: Boolean;
    end;
  end;

  TRSObjectArray = array of TRSObject;

var
  CurrentBank: PRSObject;

procedure TRSObject.SetupCommon(ObjHeight: Int32 = 4);
begin
  Height := ObjHeight;
  Finder.ClusterDistance := 2;
  Finder.Erode := 2;
  Finder.Grow := 4;

  Filter.Finder := True;
  Filter.UpText := True;
end;


{$I rsobjects.simba}

// Searches for an object with ObjectFinder in the MainScreen with the
// help of RSWalker. Good when objects don't move and precision is needed.
function TRSObject.Find: T2DPointArray;
  function GetTilesRects: TRectArray;
  var
    Me: TPoint := Map^.GetMyPos();
    Tile: TPoint;
    TileArray: TPointArray := Copy(Tiles);
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    TileArray.Sorted(Me);

    for Tile in TileArray do
    begin
      Rect := Map^.GetTileMSEx(Me, Tile, Height);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Map^.GetTileMSEx(Me, Tile, 0);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Result += Rect;
    end;
  end;

var
  Rect: TRectangle;
  Rects: TRectArray;
  B: TBox;
  TPA: TPointArray;
  ObjFinder: TRSObjectFinder;
begin
  if Filter.Walker then
  begin
    Rects := GetTilesRects;
    if Filter.Finder then
    begin
      ObjFinder := Finder;
      ObjFinder.MinLongSide := 0;
      ObjFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(ObjFinder, B).Merge;
          Result += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          Result += TPA;
        end;
      end;
    end;
  end

  else if Filter.Finder then
    Result := MainScreen.FindObject(Finder);

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

//unified debug function
procedure TRSObject.Debug;
  function GetTilesRects(out Bitmap: TMufasaBitmap): TRectArray;
  var
    Me: TPoint := Map^.GetMyPos();
    Tile: TPoint;
    TileArray: TPointArray := Copy(Tiles);
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    TileArray.Sorted(Me);

    for Tile in TileArray do
    begin
      Rect := Map^.GetTileMSEx(Me, Tile, Height);
      Bitmap.DrawRect(Rect, $ffffff);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Map^.GetTileMSEx(Me, Tile, 0);
        Bitmap.DrawRect(Rect, $ffffff);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Bitmap.DrawRect(Rect, $0000ff);

      Result += Rect;
    end;
  end;

var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  Rects: TRectArray;
  B: TBox;
  TPA: TPointArray;
  ObjFinder: TRSObjectFinder;
  Obj: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  if Filter.Walker then
  begin
    Rects := GetTilesRects(Bitmap);
    if Filter.Finder then
    begin
      ObjFinder := Finder;
      ObjFinder.MinLongSide := 0;
      ObjFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(ObjFinder, B).Merge;
          Obj += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          Obj += TPA;
        end;
      end;
    end;
  end
  else if Filter.Finder then
    Obj := MainScreen.FindObject(Finder);

  if Obj = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  Obj.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(Obj);
  Bitmap.DrawTPA(Obj[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;

procedure TRSObject.SetCurrentBank;
begin
  CurrentBank := @Self;
end;




// HoverHelper function used by non walking object hovering functions.
function TRSObject._HoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  for Attempt := 0 to Attempts do
  begin
    if Filter.UpText and MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if Attempt = (Attempts - 1) then
    begin
      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// WalkHoverHelper function used by walking object hovering functions.
function TRSObject._WalkHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  if not Filter.Walker then
    Exit;

  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if Filter.UpText and MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True)
    else if not Map^.AtTile(Tiles, 50) then
      Map^.WebWalk(Map^.GetClosestTile(Tiles), 10, 0.2)
    else if Attempt = (Attempts - 1) then
    begin
      if not Map^.AtTile(Tiles, 30) and Map^.WebWalk(Map^.GetClosestTile(Tiles), 10, 0.2) then
        Continue;

      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// ClickHelper function used by object clicking functions.
function TRSObject._ClickHelper(LeftClick: Boolean): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.Select(UpText) then
      Exit(True)
    else
    begin
      ChooseOption.Close;
      Exit;
    end;
  end;

  if LeftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and Filter.UpText and ChooseOption.Select(UpText));
end;

// SelectHelper function used by object option selection functions.
function TRSObject._SelectHelper(Action: TStringArray): Boolean;
begin
  if ChooseOption.IsOpen and ChooseOption.Select(Action) then
    Exit(True);

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;




// Searches for an object with TRSObject.Find.
function TRSObject.Hover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if Filter.Walker and not Map^.MakeTileVisible(Tiles) then
    Exit(False);

  Result := Self._HoverHelper(Attempts);
end;

// Searches for an object with TRSObject.Find, hovers and clicks it if found.
function TRSObject.Click(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an object with TRSObject.Find, hovers and selects the specified action if found.
function TRSObject.SelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._SelectHelper(Action);
end;


// Searches for an object with TRSObject.Find and walker.
function TRSObject.WalkHover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Filter.Walker then
    Exit;

  if not Map^.MakeTileVisible(Tiles) then
    if not Map^.WebWalk(Map^.GetClosestTile(Tiles), 30, 0.2) then
      Exit(False);

  Result := Self._WalkHoverHelper(Attempts);
end;

// Searches for an object with TRSObject.Find and walker, hovers and clicks it if found.
function TRSObject.WalkClick(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an object with TRSObject.Find and walker, hovers and selects the specified action if found.
function TRSObject.WalkSelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._SelectHelper(Action);
end;
