{$DEFINE WL_BANK_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TWaspBankItem = record(TRSBankWithdrawItem)
    BankTab: Int32;
    ScrollLevel: UInt32;
  end;

function TRSBank.FindItem(Item: TRSItem; out Bounds: TBox): Boolean; override;
var
  Boxes: TBoxArray;
  TempItem: TRSItem;
  Indices: TIntegerArray;
begin
  if not Self.IsOpen() then
    Exit;

  Boxes := Self.FindItemBoundaries();

  for TempItem in GetMultiItem(Item) do
  begin
    Indices := ItemFinder.Find(TempItem, Boxes, 1);
    if Indices <> [] then
    begin
      Bounds := Boxes[Indices[0]];
      Exit(True);
    end;
  end;
end;

function TRSBank.FindItem(Item: TRSBankWithdrawItem): Boolean; overload;
begin
  Result := Self.FindItem(Item.Item);
end;

function TRSBank.FindItem(BankTab: Int32; Item: TRSItem; out Bounds: TBox): Boolean; overload;
begin
  if Self.OpenTab(BankTab) then
    Result := Self.FindItem(Item, Bounds);
end;

function TRSBank.FindItem(BankTab: Int32; Item: TRSItem): Boolean; overload;
begin
  if Self.OpenTab(BankTab) then
    Result := Self.FindItem(Item);
end;

function TRSBank.FindItem(BankTab: Int32; Item: TRSBankWithdrawItem): Boolean; overload;
begin
  if Self.OpenTab(BankTab) then
    Result := Self.FindItem(Item);
end;


function TRSBank.FindItems(Items: TRSItemArray): Boolean;
var
  Item: TRSItem;
begin
  for Item in Items do
    if Self.FindItem(Item) then
      Exit(True);
end;

function TRSBank.FindItems(Items: TRSItemArray; out Bounds: TBox): Boolean; overload
var
  Item: TRSItem;
begin
  for Item in Items do
    if Self.FindItem(Item, Bounds) then
      Exit(True);
end;



function TRSBank.CountSlotStack(Slot: Int32): Int32;
begin
  Result := -1;
  Result := SRL.GetItemAmount(Self.GetSlotBoxes[Slot]);
end;


(*
Bank._SimplifyItemName
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank._SimplifyItemName(Item: TRSItem): String;

Internal function to get a human like search term for an item.
This could be improved for better antiban but I decided to keep it simple since it's not used very frequently.
This basically strips the item name from things humans won't usually type when searching, like brackets. It also makes the string lower case because people searching don't usually care about casing.
Once that's done wee crop some characters from the final string, because humans don't usually search the full item name, but just enough until it's seen on screen.

.. note:: Could be improved to in the future for only using the relevant part of the string. For example, an human searching for 'Amulet of glory(6)' would probably search for 'glory' instead of 'amulet of gl'.

Example
-------
  
  WriteLn Bank._SimplifyItemName('Amulet of glory(6)');
*)
function TRSBank._SimplifyItemName(Item: TRSItem): String;
var
  ItemStr: String := ToStr(Item);
  MaxLength, MinLength: Int32;
begin
  ItemStr := ItemStr.Before('(');
  ItemStr := ItemStr.Lower;
  MaxLength := ItemStr.Len;
  MinLength := MaxLength - Round(MaxLength/3);

  Result := Copy(ItemStr, 0, Random(MinLength, MaxLength));
end;

(*
Bank.FindItemTab
~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.FindItemTab(Item: TRSItem; OpenTab: Boolean = True): Int32;

Find the bank tab of an item just by knowing it's name.
This is very useful when you want to support people having items in any tab they want without much hassle for people to setup.
By default it will open the banktab if the item is found. This can be changed by setting **OpenTab** to false.
The result will be the BankTab of the item. **-1** means we didn't find a BankTab.

.. note:: A known limitation of this is that if several items match the sprite of the item (for example multiple charged jewlry) the tab retrieved will be the first one found. If you have 'Games necklace(1)' in tab 1 and 'Games necklace(8)' in tab 5 and search for the latter, you will get tab 1.

Example
-------
  
  WriteLn Bank.FindItemTab('Molten glass');
*)
function TRSBank.FindItemTab(Item: TRSItem; OpenTab: Boolean = True): Int32;
var
  Box, SearchBox: TBox;
  TPA: TPointArray;
  ATPA: T2DPointArray;
  TabsText: T2DPointArray;
begin
  if Self.FindItem(Item, Box) then
  begin
    if not Self.GetButton(ERSBankButton.SEARCH).Enabled then //if we found the item and we are not searching anything return the current tab.
      Exit(Self.GetCurrentTab())
    else
    begin
      Self.OpenSearch(600); //if we found the item and we are searching something, it's better to clear the search and start from scratch.
      Self.CloseSearch;
    end;
  end;

  //Attempt to search the "simplified item name" with Bank._SimplifyItemName(). Then try to find the item again. 
  if not Self.Search(Self._SimplifyItemName(Item)) or not Self.FindItem(Item, Box) then 
    Exit(-1); //If either of this things fails we exit with -1.
  //This is because if either fails something is wrong bank is not open or we don't have the item.  
    
    
  //Here is where the interesting stuff starts. We are going to look for the BankTab text on the left side that shows up when you search for an item.
  //In particular, we are interested in the BankTab text that is right above the item we found.  
    
  SearchBox := [Self.X1 + 56, Self.Y1 + 77, Self.X1 + 84, Box.Y1]; //First we restrict the search box. SearchBox.Y2 will be Box.Y1 because we are not interested in anything below the item.
                                                                   //We also set X1, Y1, X2 to known values that will make the search box smaller based on the Bank.Bounds.
  
  //Now we search for both tab text colors. The tab text is light yellow and whiteish when you hover it. 
  if SRL.FindColors(TPA, CTS0(10672356, 0), SearchBox) > 0 then 
    TabsText += TPA;
  if SRL.FindColors(TPA, CTS0(16777215, 0), SearchBox) > 0 then 
    TabsText += TPA;

  if TabsText = [] then //if we can see the item at this point and there's no tab text, it's in tab0
  begin                 //this is because tab0 is the only tab that doesn't have text.
    if OpenTab then     
      Self.OpenTab(0);
    Exit(0);
  end;

  TPA := TabsText.Merge;  //we merge the tab text.
  ATPA := TPA.Cluster(6); //and then we cluster it so we have a TPA of each tab text separated from each other.
  
  //filter out anything that does not fit the size of the tab text.
  ATPA.FilterDimensions(24, 8, 26, 8);

  if ATPA = [] then Exit(-1); //At this point, if everything got filtered something must have gone wrong and we didn't find a tab. I don't think this ever happens.

  ATPA.SortByY(False); //Sort the tabs text from bottom to top. This is because we are only interested in the very first above the item.

  
  ATPA := ATPA[0].Cluster(1); //Now we make clusters of that single tab text. This will separate the text from the number.
  ATPA.SortByX(False);        //Sort the tab text from right to left because now we are only interested in the number which is to the right.
  TPA := ATPA[0];
  
  //Now we run OCR on the number TPA to find out what number is it and set our result
  Result := OCR.RecognizeNumber(TPA.Bounds, TOCRColorRule.Create([10672356]), RS_FONT_PLAIN_11);
  if Result = 0 then
    Result := OCR.RecognizeNumber(TPA.Bounds, TOCRColorRule.Create([16777215]), RS_FONT_PLAIN_11);

  if (Result > 0) and OpenTab then
    Self.OpenTab(Result);
end;





var
  WithdrawXCache: Int32;

function TRSBank.WithdrawHelper(B: TBox; Amount: Int32; Noted: Boolean; UseQuantityButtons: Boolean): Boolean; override;
var
  Button: TRSButton;
begin
  if Noted then
    Button := Self.GetButton(ERSBankButton.NOTE)
  else
    Button := Self.GetButton(ERSBankButton.ITEM);

  if not Button.Enable() then
    Exit;

  if UseQuantityButtons then
  begin
    if Self.IsCustomQuantity(Amount) then
    begin
      Button := Self.GetButton(ERSBankButton.QUANTITY_CUSTOM);

      if Button.Enable then
      begin
        Mouse.Move(B);

        if (WithdrawXCache = Amount) or MainScreen.IsUpText('Withdraw-' + ToString(Amount)) then
        begin
          Mouse.Click(MOUSE_LEFT);

          Result := True;
        end else
        begin
          Result := ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000));
          if Result then
            WithdrawXCache := Amount;
        end;
      end;
    end else
    begin
      case Amount of
        1:  Button := Self.GetButton(ERSBankButton.QUANTITY_1);
        5:  Button := Self.GetButton(ERSBankButton.QUANTITY_5);
        10: Button := Self.GetButton(ERSBankButton.QUANTITY_10);
        else
            Button := Self.GetButton(ERSBankButton.QUANTITY_ALL)
      end;

      if Button.Enable() then
      begin
        Result := True;

        Mouse.Click(B, MOUSE_LEFT);
      end;
    end;
  end else
  begin
    Mouse.Move(B);

    case Amount of
      BANK_WITHDRAW_ALL:
        Result := ChooseOption.Select('Withdraw-All');
      BANK_WITHDRAW_ALL_BUT_ONE:
        Result := ChooseOption.Select('Withdraw-All-but-1');
      else
        Result := ChooseOption.Select('Withdraw-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False) or
                  ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500));
    end;
  end;
end;




function TRSBank.WithdrawSlot(Tab: Int32; Item: TRSBankWithdrawSlot; UseQuantityButtons: Boolean): Boolean; overload;
var
  ItemCount: Int32;
begin
  if not Self.IsOpen or (Tab = -1) then
    Exit;

  Self.OpenTab(Tab);

  ItemCount := Self.CountSlotStack(Item.Slot);
  if Self.WithdrawSlot(Item, UseQuantityButtons) then
    Result := WaitUntil(Self.CountSlotStack(Item.Slot) < ItemCount, 100, 2000);
end;


function TRSBank.WithdrawItem(out Tab: Int32; Item: TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean; overload;
var
  B: TBox;
  ItemCount: Int32;
begin
  if not Self.IsOpen then
    Exit;

  if Inventory.IsFull and not Inventory.ItemIsStackable(Item.Item) then
    Exit;

  if not Self.FindItem(Item.Item, B) then
  begin
    if Tab = -1 then
      Tab := Self.FindItemTab(Item.Item)
    else
      Self.OpenTab(Tab);

    if not Self.FindItem(Item.Item, B) then
      Exit(False);
  end;

  ItemCount := SRL.GetItemAmount(B);
  if Self.WithdrawHelper(B, Item.Quantity, Item.Noted, UseQuantityButtons) then
    Result := WaitUntil(SRL.GetItemAmount(B) < ItemCount, 100, 2000);
end;

function TRSBank.WithdrawItems(Tab: Int32; Items: array of TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean;
var
  Item: TRSBankWithdrawItem;
begin
  for Item in Items do
    if not Self.WithdrawItem(Tab, Item, UseQuantityButtons) then
      Exit(False);

  Result := True;
end;



function TRSBank.DepositItem(Tab: Int32; Item: TRSBankDepositItem; UseQuantityButtons: Boolean): Boolean; overload;
var
  IsStackable: Boolean;
  ItemCount: Int32;
begin
  if not Self.IsOpen then
    Exit;

  if IsStackable := Inventory.ItemIsStackable(Item.Item) then
    ItemCount := Inventory.CountItemStack(Item.Item)
  else
    ItemCount := Inventory.CountItem(Item.Item);

  if Tab > -1 then
    Self.OpenTab(Tab);

  if Self.DepositItem(Item, UseQuantityButtons) then
  begin
    if IsStackable then
      Result := WaitUntil((Inventory.CountItemStack(Item.Item) <> ItemCount), 50, 2000)
    else
      Result := WaitUntil((Inventory.CountItem(Item.Item) <> ItemCount), 50, 2000);
  end;
end;

function TRSBank.DepositItem(Tab: Int32; Item: TRSItem; UseQuantityButtons: Boolean): Boolean; overload;
begin
  Result := Self.DepositItem(Tab, [Item, BANK_DEPOSIT_ALL], UseQuantityButtons);
end;

function TRSBank.DepositItemArray(Tab: Int32; ItemArray: array of TRSBankDepositItem; UseQuantityButtons: Boolean): Boolean;
var
  Item: TRSBankDepositItem;
  ItemList: array of TRSBankDepositItem;
begin
  for Item in ItemArray do
    if Inventory.FindItem(Item.Item) then
      ItemList += Item;

  for Item in Itemlist do
    if not Self.DepositItem(Tab, Item, UseQuantityButtons) then
      Exit(False);

  Result := True;
end;

function TRSBank.DepositItemArray(Tab: Int32; ItemArray: TRSItemArray; UseQuantityButtons: Boolean): Boolean; overload;
var
  Item: TRSItem;
  ItemList: TRSItemArray;
begin
  for Item in ItemArray do
    if Inventory.FindItem(Item) then
      ItemList += Item;

  for Item in ItemList do
    Self.DepositItem(Tab, Item, UseQuantityButtons);

  Result := not Inventory.FindItems(ItemList);
end;

function TRSBank.DepositAllBut(Tab: Int32; Items: TRSItemArray): Boolean;
var
  Item: TRSItem;
  Slots: TIntegerArray;
  DepositSlots: TIntegerArray;
begin
  if not Self.IsOpen() then
    Exit;

  if Tab > -1 then
    Self.OpenTab(Tab);

  for Item in Items do
    Inventory.FindItem(Item, Slots);

  DepositSlots := Slots.SymmetricDifference(Inventory.GetUsedSlots);

  if DepositSlots <> [] then
  repeat
    if not Self.IsOpen then //Exit in case the bank somehow closed.
      Exit;

    if Self.DepositSlot([DepositSlots[0], BANK_DEPOSIT_ALL], True) then
      WaitUntil(not Inventory.IsSlotUsed(DepositSlots[0]), 100, 2000);

    DepositSlots := Slots.SymmetricDifference(Inventory.GetUsedSlots);
  until Result := (DepositSlots = []);
end;

function TRSBank.Close(PressEscape: Boolean = False): Boolean; override;
begin
  if not Self.IsOpen(False) then
    Exit(True);

  Result := MainScreen.CloseInterface(PressEscape);
end;

function TRSBank.Close(Chance: Double): Boolean; overload;
var
  PressEscape: Boolean;
begin
  if Chance = BioHash then
    PressEscape := Antiban.BioDice
  else
    PressEscape := SRL.Dice(Chance);

  Result := MainScreen.CloseInterface(PressEscape);
end;

//Temporarily here.
function TRSDepositBox.Close(PressEscape: Boolean = False): Boolean; override;
begin
  if not Self.IsOpen then
    Exit(True);

  Result := MainScreen.CloseInterface(PressEscape);
end;

//Temporarily here.
function TRSGrandExchange.Close(PressEscape: Boolean = False): Boolean; override;
begin
  if not Self.IsOpen then
    Exit(True);

  Result := MainScreen.CloseInterface(PressEscape);
end;
