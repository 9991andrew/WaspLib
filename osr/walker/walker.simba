{$DEFINE WL_WALKER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{$I waspweb.graph}
{$I agility.graph}

type
  TRSWalkerArray = array of TRSWalker;

  ERSMap = (
    WORLD_MAP,
    MAINLAND_MAP,
    ZEAH_MAP,
    AGILITY_MAP,

    ABYSS_MAP,
    ASGARNIA_ICE_DUNGEON_MAP,
    BARBARIAN_VILLAGE_MAP,
    BRIMHAVEN_DUNGEON_MAP,
    CATACOMBS_OF_KOUREND_MAP,
    CHASM_OF_FIRE_MAP,
    CORSAIR_COVE_DUNGEON_MAP,
    CRAFTING_GUILD_MAP,
    DEATH_PLATEU_MAP,
    FALADOR_MAP,
    FREMMENNIK_SLAYER_CAVE_MAP,
    GIANTS_DEN_MAP,
    GRAND_EXCHANGE_MAP,
    IORWERTH_DUNGEON_MAP,
    KALPHITE_CAVE_MAP,
    KALPHITE_LAIR_MAP,
    KARUULM_SLAYER_DUNGEON_MAP,
    KRAKEN_COVE_MAP,
    LUMBRIDGE_MAP,
    LUNAR_ISLAND_MAP,
    MOSLE_HARMLESS_CAVE_MAP,
    MOURNER_TUNNELS_MAP,
    OTTOS_GROTTO_MAP,
    PISCARILIUS_MAP,
    SLAYER_TOWER_BASEMENT_AND_UPPERLEVEL_MAP,
    SLAYER_TOWER_GROUNDFLOOR_MAP,
    SMOKE_DEVIL_DUNGEON_MAP,
    SMOKE_DUNGEON_MAP,
    STRONGHOLD_SLAYER_DUNGEON_MAP,
    VARROCK_MAP,
    WC_GUILD_MAP,
    WEST_VARROCK_MAP,
    WINTERTODT_MAP,
    ZULANDRA_MAP
  );

  ERSMapArray = array of ERSMap;

function TRSWalkerArray.Find(const Walker: TRSWalker): Integer;
begin
  for Result := 0 to High(Self) do
    if (Walker.Name = Self[Result].Name) then
      Exit;

  Result := -1;
end;

var
  WalkerArray: TRSWalkerArray;
  WalkerOffsetArray: TPointArray;

function GetMap(MAP: ERSMap): String;
begin
  case Map of
    WORLD_MAP:    Exit('world');
    MAINLAND_MAP: Exit('mainland');
    ZEAH_MAP:     Exit('zeah');
    AGILITY_MAP:  Exit('agility');

    ABYSS_MAP: Exit('x9670y4424');
    ASGARNIA_ICE_DUNGEON_MAP: Exit('x1771y1144');
    BARBARIAN_VILLAGE_MAP: Exit('x7580y2516');
    BRIMHAVEN_DUNGEON_MAP: Exit('x1272y4048');
    CATACOMBS_OF_KOUREND_MAP: Exit('x0y2721');
    CHASM_OF_FIRE_MAP: Exit('x0y0');
    CORSAIR_COVE_DUNGEON_MAP: Exit('x8923y5104');
    CRAFTING_GUILD_MAP: Exit('x6953y3166');
    DEATH_PLATEU_MAP: Exit('x6736y2008');
    FALADOR_MAP: Exit('x7051y2796');
    FREMMENNIK_SLAYER_CAVE_MAP: Exit('x2348y2903');
    GIANTS_DEN_MAP: Exit('x2560y3229');
    GRAND_EXCHANGE_MAP, WEST_VARROCK_MAP: Exit('x7789y2306');
    IORWERTH_DUNGEON_MAP: Exit('x3002y2756');
    KALPHITE_CAVE_MAP: Exit('x212y3352');
    KALPHITE_LAIR_MAP: Exit('x996y3340');
    KARUULM_SLAYER_DUNGEON_MAP: Exit('x313y0');
    KRAKEN_COVE_MAP: Exit('x10158y1010');
    LUMBRIDGE_MAP: Exit('x7856y2972');
    LUNAR_ISLAND_MAP: Exit('x4127y1027');
    MOSLE_HARMLESS_CAVE_MAP: Exit('x0y3332');
    MOURNER_TUNNELS_MAP: Exit('x7090y5135');
    OTTOS_GROTTO_MAP: Exit('x5201y2030');
    PISCARILIUS_MAP: Exit('x2444y1122');
    SLAYER_TOWER_BASEMENT_AND_UPPERLEVEL_MAP: Exit('x4702y0');
    SLAYER_TOWER_GROUNDFLOOR_MAP: Exit('x8931y2044');
    SMOKE_DEVIL_DUNGEON_MAP: Exit('x5346y5184');
    SMOKE_DUNGEON_MAP: Exit('x212y3352');
    STRONGHOLD_SLAYER_DUNGEON_MAP: Exit('x3066y5085');
    VARROCK_MAP: Exit('x7536y2363');
    WC_GUILD_MAP: Exit('x1564y2293');
    WINTERTODT_MAP: Exit('x1756y274');
    ZULANDRA_MAP: Exit('x3969y4031');
  end;
end;

// overriden just so I can load maps from WaspLib maps folder
function TRSWalker.FindMap(Map: String): String; static; override;
var
  Mask: String = '.png;.bmp;';
  Files: TStringArray;
begin
  if FileExists(Map) then
    Exit(ExpandFileName(Map));

  Mask := StringReplace(Mask, '.', Map + '.', [rfReplaceAll]);

  Files := FindFile(ExtractFileDir(Map), Mask, False, False) +
           FindFile({$MACRO CURRENT_DIRECTORY}, Mask, True, False);

  if Length(Files) > 0 then
    Result := Files[0];
end;

// overriden to provide the ability to offset the map
procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
var
  Path: String;
  Bitmap, Mask, Sample: TMufasaBitmap;
  X, Y: Int32;
begin
  Self.Name := Map.ToLower();
  Self.ScreenWalk := True;

  Path := Self.FindMap(Map);
  if (Path = '') then
    Self.Fatal('Unable to find map: ' + Map);

  Self.Scaling := Scaling;
  Self.ClickRandomness := 4;

  if Self.Name.Contains('agility') then
    Self.WebGraph := WaspAgility
  else
    Self.WebGraph := WaspWeb;

  Self.World := Self.LoadMap(Path);
  if Manage then
    AddOnTerminate(@Self.Free);

  //Self.HighlightFeatures(Self.World);

  // Fixed or resizable, doesn't matter.
  Sample := TMufasaBitmap.Create();
  Self.World.Downsample(Sample, Self.Scaling);
  Bitmap := Self.GetCleanMinimap();
  Mask := Self.ScaleMinimap(Bitmap, Self.Scaling);

  for X := 0 to Mask.getWidth() - 1 do
    for Y := 0 to Mask.getHeight() - 1 do
      if (Mask.GetPixel(X, Y) <> 0) then
        Mask.SetPixel(X, Y, $FFFFFF);

  Self.Cache := TMatchTemplateCache.Create(Sample.ToMatrix(), Mask.ToMatrix());

  Sample.Free;
  Bitmap.Free;
  Mask.Free;

  WalkerArray += Self;
  if Self.Name.Contains('mainland') then
    WalkerOffsetArray += [3583, 0]
  else if Self.Name.ContainsAll(['x', 'y']) then
  begin
    X := StrToInt(Self.Name.After('x').Before('y'));
    Y := StrToInt(Self.Name.After('y'));
    WalkerOffsetArray += [X, Y];
  end
  else
    WalkerOffsetArray += [0, 0];
end;


// overriden to take into account map offset on debug
procedure TRSWalker.DebugPosition(EnsureVisible: Boolean = True); override;
var
  X1, Y1, X2, Y2, X, Y: Int32;
  P: TPoint;
  Bitmap, WorldBitmap, MinimapBitmap: TMufasaBitmap;
  Time: Double;
  Position: TPoint;
  Lines: TStringArray;
  WalkerOffset: TPoint;
begin
  WalkerOffset := WalkerOffsetArray[WalkerArray.Find(Self)];

  Freeze();

  Time := PerformanceTimer();
  Position := Self.GetMyPos();
  Time := PerformanceTimer() - Time;

  X1 := Max(0, (Position.X - WalkerOffset.X) - 200);
  Y1 := Max(0, (Position.Y - WalkerOffset.Y) - 200);
  X2 := Min(X1 + 400, Self.World.GetWidth()  - 1);
  Y2 := Min(Y1 + 400, Self.World.GetHeight() - 1);

  X := (Position.X - WalkerOffset.X) - X1;
  Y := (Position.Y - WalkerOffset.Y) - Y1;

  WorldBitmap := Self.World.Copy(X1, Y1, X2, Y2);
  WorldBitmap.DrawLine(Point(0, Y), Point(X2 - X1, Y), $00FF00);
  WorldBitmap.DrawLine(Point(X, 0), Point(X, Y2 - Y1), $00FF00);
  WorldBitmap.DrawBox([X - 2, Y - 2, X + 2, Y + 2], $FFFFFF);

  MinimapBitmap := Self.ScaleMinimap(Self.GetCleanMinimap(), 1);

  P := MinimapBitmap.GetCenter();
  if RSClient.Mode = ERSClientMode.FIXED then
    P := P.Offset(0, 8).Rotate(-Minimap.GetCompassAngle(False), P);

  MinimapBitmap.DrawBoxFilled([P.X - 1, P.Y - 1, P.X + 1, P.Y + 1], $FFFFFF);

  Bitmap := TMufasaBitmap.Create();
  Bitmap.SetSize(400 + MinimapBitmap.GetWidth() + 30, 420);
  Bitmap.Fill($403027);

  Lines := [
    '('      + ToStr(Position.X, ', ', Position.Y) + ')',
    'Acc: '  + ToStr(Round(Self.Similarity, 3)),
    'Time: ' + ToStr(Round(Time)) + ' ms'
  ];

  Bitmap.SetFontName('Consolas');
  Bitmap.SetFontSize(18);
  Bitmap.SetFontAntialiasing(True);

  Bitmap.DrawText(Lines[0], [420, 20 + MinimapBitmap.GetHeight()], $FFFFFF);
  Bitmap.DrawText(Lines[1] + LineEnding + Lines[2], [420, 370], $FFFFFF);

  Bitmap.DrawBitmap(WorldBitmap, [10, 10]);
  WorldBitmap.Free();

  Bitmap.DrawBitmap(MinimapBitmap, [420, 10]);
  MinimapBitmap.Free();

  Bitmap.Show(EnsureVisible);
  Bitmap.Free();

  UnFreeze();
end;

// overriden to take into account map offset
function TRSWalker.FullSearch(Templ, World: TMufasaBitmap; Position: TPoint; out Match: Single): TPoint; override;
const
  TEMPL_SIZE = 25;
  SLICE_SIZE = TEMPL_SIZE + 45;
  SCALING = 2;
var
  Slice, SliceScaled, TemplScaled: TMufasaBitmap;
  Matrix: TSingleMatrix;
  Area: TBox;
  WalkerOffset: TPoint;
begin
  WalkerOffset := WalkerOffsetArray[WalkerArray.Find(Self)];

  Area := [
    Max(0, Position.X - SLICE_SIZE),
    Max(0, Position.Y - SLICE_SIZE),
    Min(World.GetWidth()  - 1, Position.X + SLICE_SIZE),
    Min(World.GetHeight() - 1, Position.Y + SLICE_SIZE)
  ];

  Slice := World.Copy(Area.X1, Area.Y1, Area.X2, Area.Y2);
  SliceScaled := Slice.Copy();
  SliceScaled.Downsample(SCALING);

  TemplScaled := Templ.Copy();
  TemplScaled.Downsample(SCALING);
  with TemplScaled.GetCenter() do
    TemplScaled.Crop(X - TEMPL_SIZE, Y - TEMPL_SIZE, X + TEMPL_SIZE, Y + TEMPL_SIZE);

  Matrix := SliceScaled.MatchTemplate(TemplScaled, TM_CCOEFF_NORMED);

  with Matrix.ArgMax() do
  begin
    Match := Matrix[Y, X];

    Result.X := Area.X1 + (X + TEMPL_SIZE) * SCALING;
    Result.Y := Area.Y1 + (Y + TEMPL_SIZE) * SCALING;
    Result := Result.Offset(WalkerOffset);
  end;

  TemplScaled.Free;
  SliceScaled.Free;
  Slice.Free;
end;

// overriden to properly screenwalk
function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;
var
  MinimapPoint: TPoint;
  R: TRectangle;
begin
  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Angle);

  Result := Minimap.IsPointOn(MinimapPoint, -1);

  if Result and Self.ScreenWalk then
  begin
    R := Minimap.PointToMSRect(MinimapPoint, Angle);
    Result := MainScreen.IsVisible(R.Mean) and (CountColor($000000, R.Bounds.Expand(0, MainScreen.Bounds)) = 0);
  end;
end;




// Checks if we are within Distance of Tile
function TRSWalker.AtTile(Tile: TPoint; Distance: Int32 = 15): Boolean;
begin
  Result := Self.GetMyPos.DistanceTo(Tile) <= Distance;
end;

function TRSWalker.AtTile(TileArray: TPointArray; Distance: Int32 = 15): Boolean; overload;
var
  Tile: TPoint;
begin
  for Tile in TileArray do
    if Self.AtTile(Tile, Distance) then
      Exit(True);
end;

function TRSWalker.AtTile(T2DTileArray: T2DPointArray; Distance: Int32 = 15): Boolean; overload;
var
  TileArray: TPointArray;
begin
  for TileArray in T2DTileArray do
    if Self.AtTile(TileArray, Distance) then
      Exit(True);
end;


// Returns the closest tile to the player
// If the Distance is the same for more than one, a random one will be returned
function TRSWalker.GetClosestTile(Tiles: TPointArray): TPoint;
var
  Tile: TPoint;
  ClosestDistances: TIntegerArray;
  Distances: TExtendedArray;
begin
  if Tiles = [] then
    Exit
  else if Length(Tiles) = 1 then
    Exit(Tiles[0]);

  for Tile in Tiles do
    Distances += Self.GetMyPos.DistanceTo(Tile);

   ClosestDistances := Distances.IndicesOf(Distances.Min);

  Result := Tiles[ClosestDistances[Random(0, High(ClosestDistances))]];
end;

function TRSWalker.GetClosestTile(TilesArray: T2DPointArray): TPoint; overload;
var
  Tiles, ClosesTiles: TPointArray;
begin
  if TilesArray = [] then
    Exit;

  for Tiles in TilesArray do
    ClosesTiles += Self.GetClosestTile(Tiles);

  Result := Self.GetClosestTile(ClosesTiles);
end;


function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestTile(Destination), WaitUntilDistance, PathRandomness);
end;


// Returns all the an array of tiles that have the closest distance to the player
function TRSWalker.GetClosestTileCluster(TilesArray: T2DPointArray): TPointArray;
var
  Tiles: TPointArray;
begin
  if TilesArray = [] then
    Exit;

  for Tiles in TilesArray do
    Result += Self.GetClosestTile(Tiles);
end;

// Checks if the tile is currently visible
function TRSWalker.TileVisible(Tile: TPoint): Boolean; overload;
begin
  Result := MainScreen.IsVisible(Self.GetTileMS(Tile));
end;

function TRSWalker.TileVisible(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.TileVisible(Tile);
end;

// Checks if we can make the tile visible by zooming out
function TRSWalker.TileWithinZoom(Tile: TPoint): Boolean;
begin
  Result := Minimap.PointInZoomRectangle(Self.WorldToMM(Tile));
end;

function TRSWalker.TileWithinZoom(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.TileWithinZoom(Tile);
end;



function TRSWalker.FacingTile(Tile: TPoint; Randomness: Int32 = 20): Boolean;
var
  Angle: Double;
begin
  Angle := MainScreen.PointToMM(Self.GetTileMS(Tile).Mean).ToPoint.AngleBetween(Minimap.Center);
  Result := (Angle <= (0 + Randomness)) or (Angle >= (360 - Randomness));
end;

// Attempts to rotate the screen in order to make Tile visible.
function TRSWalker.FaceTile(Tile: TPoint): Boolean;
begin
  if not Self.TileWithinZoom(Tile) then
    Exit;

  if not Self.FacingTile(Tile, 10) then
  begin
    MainScreen.FacePoint(Self.GetTileMS(Tile).Mean, 10);
    Result := Self.FacingTile(Tile, 10);
  end;
end;

function TRSWalker.FaceTile(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.FaceTile(Tile);
end;

// Attempts to zoom out enough so Tile is visible.
function TRSWalker.ZoomToTile(Tile: TPoint): Boolean;
var
  ZoomLevel: Int32;
  MaxZoomLevel: Int32;
begin
  if Self.TileWithinZoom(Tile) then
    Exit(True);

  ZoomLevel := Minimap.ZoomToPoint(Self.WorldToMM(Tile));

  if Antiban.MaxZoom > 0 then
    MaxZoomLevel := Antiban.MaxZoom
  else
    MaxZoomLevel := 100;

  if (ZoomLevel >= Antiban.MinZoom) and (ZoomLevel <= MaxZoomLevel) then
    Options.SetZoomLevel(ZoomLevel);

  Result := Self.TileWithinZoom(Tile);
end;

function TRSWalker.ZoomToTile(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.ZoomToTile(Tile);
end;


function TRSWalker.MakeTileVisible(Tile: TPoint): Boolean;
begin
  Result := Self.TileVisible(Tile) or Self.ZoomToTile(Tile) or
            (Self.FaceTile(Tile) and Self.TileVisible(Tile));
end;

function TRSWalker.MakeTileVisible(Tiles: TPointArray): Boolean; overload;
begin
  Result := Self.MakeTileVisible(Self.GetClosestTile(Tiles));
end;


function TRSWalker.UntilTileVisible(Tile: TPoint; Interval, WaitTime: UInt32 = 0): Boolean;
begin
  Result := WaitUntil(Self.TileVisible(Tile), Interval, WaitTime);
end;

function TRSWalker.UntilTileVisible(Tiles: TPointArray; Interval, WaitTime: UInt32 = 0): Boolean; overload;
begin
  Result := WaitUntil(Self.TileVisible(Tiles), Interval, WaitTime);
end;



function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
var
  WorldPoint: TPoint;
begin
  for WorldPoint in WorldPoints do
    Result += Self.WorldToMM(PlayerPoint, WorldPoint, Radians);
end;

function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos, WorldPoints, Minimap.GetCompassAngle(False));
end;

function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
var
  P: TPoint;
begin
  if DotFilter.Circle <> [] then
  begin
    P := Self.WorldToMM(DotFilter.Circle.Mean);
    Result.Circle := [P.X, P.Y, DotFilter.Circle.Radius];
  end;

  Result.TPA      := Self.WorldToMM(DotFilter.TPA);
  Result.Inside   := DotFilter.Inside;
  Result.HasTimer := DotFilter.HasTimer;
  Result.Timer    := DotFilter.Timer;
end;

function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;
var
  DotFilter: TRSDotFilter;
begin
  for DotFilter in DotFilterArray do
    Result += Self.WorldToMM(DotFilter);
end;


(*
TRSWalker.GetPolygonMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray;
.. pascal:: function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray; overload;

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.
This calls **TRSMinimap.GetPolygonMS()** internally which in turn will use both methods above.

To put it simply, this will will first calculate a floor rectangle with **TileVector.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **TileVector.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon:

Example
-------
  Debug(RSW.GetPolygonMS([100, 100], [1, 1, 4], Offset));     //This will draw a polygon around the coordinate [100, 100].
*)
function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly;
var
  Angle: Double;
begin
  Angle := Minimap.GetCompassAngle(False);
  Loc   := Self.WorldToMM(Me, Loc, Angle);

  Result := Minimap.GetPolygonMS(Loc, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly; overload;
begin
  Result := Self.GetPolygonMS(Self.GetMyPos(), Loc, TileVector, Offset);
end;


(*
TRSWalker.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
.. pascal:: function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;

This are wrapper functions to retrieve multiple tiles. Refer to SRL's TRSWalker.GetTileMSEx() and TRSWalker.GetTileMS() for more information.
*)
function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
var
  Loc: TPoint;
begin
  for Loc in LocArray.Sorted(Me) do
    Result += Self.GetTileMSEx(Me, Loc, TileVector, Offset);
end;

function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos, LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetPolygonArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;
.. pascal:: function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetPolygonMS** for more information.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetPolygonArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray;
var
  Angle: Double;
  i: Int32;
begin
  Angle := Minimap.GetCompassAngle(False);

  for i := 0 to High(LocArray) do
    LocArray[i] := Self.WorldToMM(Me, LocArray[i], Angle);

  Result := Minimap.GetPolygonArrayMS(LocArray, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray; overload;
begin
  Result := Self.GetPolygonArrayMS(Self.GetMyPos(), LocArray, TileVector, Offset);
end;




function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;
begin
  Result := Self.WorldToMM(LocArray);
end;

function TRSWalker.InPoly(LocArray: TPointArray): Boolean;
var
  TPA: TPointArray  := Self.GetMMPoly(LocArray).Connect();
begin
  Result := SRL.PointInPoly(Minimap.Center, TPA);
end;

