(*
Walker extensions
=================
Extensions to SRL's TRSWalker.
*)

{$DEFINE WL_WALKER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{$I walker_regions.simba}
{$I waspweb.graph}
{$I agility.graph}

const
  WL_WALKER_MAP = {$MACRO CURRENT_DIRECTORY} + 'map.png';
  WALKER_MAP_VERSION = '1'; // Inc if images have changed

type
  RSHeightMap = record(TSRLBaseRecord)
  class var
    Enabled: Boolean;
    Map: TMufasaBitmap;
    MaxHeight: Double;
    MathCache: Double;
  end;

function RSHeightMap.GetColor(p: TPoint): Int64; static;
begin
  Result := RSHeightMap.Map.GetPixel(p.X, p.Y);
end;

function TRSWalkerMap.FindMap(Map: String): String; static; override;
var
  Mask: String = '.png;.bmp;';
  Files: TStringArray;
begin
  if FileExists(Map) then
    Exit(ExpandFileName(Map));

  Mask := StringReplace(Mask, '.', Map + '.', [rfReplaceAll]);

  Files := FindFile(ExtractFileDir(Map), Mask, False, False) +
           FindFile({$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator, Mask, True, False);

  if Length(Files) > 0 then
    Result := Files[0];
end;

procedure TRSWalkerMap.Load(FileName: String; ARegions: TBoxArray; Scaling: Integer; Padding: Integer = 50); override;
var
  Bitmaps, HBitmaps: TMufasaBitmapArray;
  I: Integer;
  hFileName: String;
begin
  hFileName := ExtractFilePath(FileName) + 'h' + ExtractFileName(FileName);
  RSHeightMap.Enabled := RSHeightMap.Enabled and (RSHeightMap.MaxHeight > 0) and FileExists(hFileName);

  SetLength(Self.Regions, Length(ARegions));
  SetLength(Self.RegionOffsets, Length(ARegions));

  SetLength(Bitmaps, Length(Self.Regions));
  SetLength(HBitmaps, Length(Self.Regions));
  for I := 0 to High(Bitmaps) do
  begin
    Self.RegionOffsets[I] := TPoint.Create(ARegions[I].X1, ARegions[I].Y1);

    Bitmaps[I] := Self.InternalLoadMap(FileName, ARegions[I]);
    if RSHeightMap.Enabled then
      HBitmaps[I] := Self.InternalLoadMap(hFileName, ARegions[I]);

    if (ARegions[I] <> RSWalkerRegions.WORLD) then
    begin
      Self.RegionOffsets[I].X -= Padding;
      Self.RegionOffsets[I].Y -= Padding;

      Bitmaps[I].Pad(Padding);
      if RSHeightMap.Enabled then
        HBitmaps[I].Pad(Padding);
    end;

    Self.Regions[I] := TBox.Create(0, 0, Bitmaps[I].GetWidth(), Bitmaps[I].GetHeight());
  end;

  Self.Regions := Self.Regions.Pack();
  Self.Map.Init();
  Self.Map.SetSize(Self.Regions.Merge.Width(), Self.Regions.Merge.Height());
  Self.Map.SetName('Walker.Map');
  AddOnTerminate(@Self.Map.Free);

  if RSHeightMap.Enabled then
  begin
    RSHeightMap.Map.Init();
    RSHeightMap.Map.SetSize(Self.Regions.Merge.Width(), Self.Regions.Merge.Height());
    RSHeightMap.Map.SetName('Heightmap');
    AddOnTerminate(@RSHeightMap.Map.Free);;
  end;

  for I := 0 to High(Self.Regions) do
  begin
    Self.Map.DrawBitmap(Bitmaps[I], TPoint.Create(Self.Regions[I].X1, Self.Regions[I].Y1));
    if RSHeightMap.Enabled then
      RSHeightMap.Map.DrawBitmap(HBitmaps[I], TPoint.Create(Self.Regions[I].X1, Self.Regions[I].Y1));
  end;

  Self.ScaledMap.Init();
  AddOnTerminate(@Self.ScaledMap.Free);
  Self.ScaledMap.SetName('Walker.ScaledMap');
  Self.Map.Downsample(Scaling, Self.ScaledMap);

  for I := 0 to High(Bitmaps) do
    Bitmaps[I].Free();

  if RSHeightMap.Enabled then
    for I := 0 to High(HBitmaps) do
      HBitmaps[I].Free();
end;


procedure TRSWalker.InternalSetup(); override;
var
  MinimapImage, MinimapSample: TMufasaBitmap;
begin
  Self.Name := 'Walker';

  MinimapImage := Self.GetCleanMinimap();
  MinimapSample := Self.ScaleMinimap(MinimapImage, Self.Scaling);

  Self.Cache := TMatchTemplateRGBCache.Create(Self.Map.ScaledMap.ToMatrix(), MinimapSample.ToMatrix());
  Self.WebGraph := WaspWeb;
  Self.ScreenWalk := True;

  MinimapSample.Free();
  MinimapImage.Free();
end;


procedure TRSWalker.Setup(Regions: TBoxArray; Scaling: Integer = 8); override;
begin
  Self.Scaling := Scaling;

  Self.Map.Load(WL_WALKER_MAP, Regions, Scaling);

  Self.InternalSetup();
end;


function TRSWalker.GetHeight(p: TPoint = []; global: Boolean = True): Double;
begin
  if p = [] then
  begin
    global := True;
    p := Self.GetMyPos();
  end;

  if global then
    p := Self.Map.GlobalToRegion(Self.RegionIndex, p);

  if RSHeightMap.MathCache = 0 then
    RSHeightMap.MathCache := RSHeightMap.MaxHeight / $FFFFFF;
  Result := RSHeightMap.GetColor(p) * RSHeightMap.MathCache;
end;


(*
procedure TRSWalker.DebugHeightTiles(Angle: Double = -1);
var
  Position: TPoint;
  TempTile: TPoint;
  CurrentHeight, TileHeight, HeightDiff: Double;

  BMP: TMufasaBitmap;
  X, Y: Int32;
  Tile: Vector3;
  TPA: TPointArray;
begin
  if Angle = -1 then
    Angle := Minimap.GetCompassAngle(False);

  Position := Self.GetMyPos();
  CurrentHeight := Self.GetHeight(Position);

  BMP := TMufasaBitmap.CreateFromClient();

  for X := Minimap.Center().X - 25 * 4 to Minimap.Center().X + 25 * 4 with 4 do
    for Y := Minimap.Center().Y - 25 * 4 to Minimap.Center().Y + 25 * 4 with 4 do
    begin

      TempTile := Position + ([X, Y] - Minimap.Center());
      TempTile := TempTile.Rotate(-Angle, Position);
      TileHeight := Self.GetHeight(TempTile);
      HeightDiff := CurrentHeight-TileHeight;

      Tile := Vec3(X, Y, HeightDiff).RotateXY(Angle, Minimap.Center().X, Minimap.Center().Y);
      TPA := Minimap.VecToMsRect(Tile, 1, 1, Angle).ToTPA().Connect();

      if MainScreen.IsVisible(TPA) then
        BMP.DrawTPA(TPA, Round(TileHeight * ($00ff00 + $00ff00)/ MAX_WALKER_HEIGHT));
    end;

  BMP.Show();
  BMP.Free();
end;
*)

(*
Walker.GetMyPos
~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetMyPos(out height: Double): TPoint; overload;

Overload that also returns the player height.

Example
-------

  WriteLn RSW.GetMyPos(height);
  WriteLn height;
*)
function TRSWalker.GetMyPos(out height: Double): TPoint; overload;
const
  SAMPLES = 3;
var
  bitmap: TMufasaBitmap;
  tpa: TPointArray;
  i: Int32;
  hit: TPoint;
  match: Single;
begin
  Self.RegionIndex := -1;
  Self.Region := [];
  Self.Similarity := 0;

  bitmap := Self.GetCleanMinimap();

  tpa := Self.ScaledSearch(bitmap, SAMPLES);
  for i := 0 to High(tpa) do
  begin
    hit := Self.FullSearch(bitmap, Self.Map.Map, tpa[i], match);

    if match > Self.Similarity then
    begin
      Self.Similarity := match;

      Result := hit;
    end;
  end;

  Self.RegionIndex := Self.Map.RegionIndexFromPoint(Result);
  if Self.RegionIndex > -1 then
  begin
    Self.Region := Self.Map.Regions[Self.RegionIndex];
    height := Self.GetHeight(Result, False);
    Result := Self.Map.RegionToGlobal(Result);
  end;

  bitmap.Free();
end;

(*
Walker.GetHeightDiff
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetHeightDiff(p: TPoint): Double;
.. pascal:: function TRSWalker.GetHeightDiff(p, q: TPoint): Double; overload;

Returns the height difference between 2 points. If only one point is passed, the player position is used as one of them.

Example
-------

  WriteLn RSW.GetMyPos(RSW.GetMyPos(), [100, 100]);
*)
function TRSWalker.GetHeightDiff(p: TPoint): Double;
var
  h: Double;
begin
  Self.GetMyPos(h);
  Result := h - Self.GetHeight(p);
end;

function TRSWalker.GetHeightDiff(p, q: TPoint): Double; overload;
begin
  Result := Self.GetHeight(p) - Self.GetHeight(q);
end;

(*
RSHeightMap.DebugPosition
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure RSHeightMap.DebugPosition(p: TPoint);

Debug a point in the loaded heightmap.

Example
-------

  RSHeightMap.DebugPosition(RSW.GetMyPos());
*)
procedure RSHeightMap.DebugPosition(p: TPoint);
var
  hMap: TMufasaBitmap;
begin
  hMap := RSHeightMap.Map.Copy();

  WriteLn('Height value: ', RSHeightMap.GetColor(p) * RSHeightMap.MathCache);

  hMap.DrawCross(p, 4, $00FFFF);
  hMap.Debug();
  hMap.Free();
end;





(*
TRSWalker.IsWalkable
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.IsWalkable(worldPoint: TPoint; playerPoint: TPoint; Angle: Double): Boolean; override;

Overriden to change the default behavior of TRSWalker.IsWalkable(), specifically for ScreenWalking since I don't like the default behaviour.
I find that minimap limits is extremely close to the render distance in the mainscreen, so personally I rather not
have the function bother any further if **worldPoint** is not on the minimap.

This override will affect both TRSWalker and TRSWalker.
*)
function TRSWalker.IsWalkable(worldPoint: TPoint; playerPoint: TPoint; Angle: Double): Boolean; override;
var
  mmPoint: TPoint;
  R: TRectangle;
begin
  mmPoint := Self.WorldToMM(playerPoint, worldPoint, Angle);

  Result := Minimap.IsPointOn(mmPoint, -1);

  if Result and Self.ScreenWalk then
  begin
    R := Minimap.PointToMSRect(mmPoint, 1, 1, Angle);
    Result := MainScreen.IsVisible(R.mean()) and (CountColor($000000, R.Bounds.Expand(0, MainScreen.Bounds)) = 0);
  end;
end;


(*
TRSWalker.AtTile
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.AtTile(worldPoint: TPoint; Distance: Int32 = 4): Boolean;
.. pascal:: function TRSWalker.AtTile(worldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;

method used to quickly check if we are within distance of a certain **worldPoint**. This distance is measure in pixels and in a radial way.
You can optionally pass in a TPA to check if the closest point is within distance.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.AtTile(worldPoint: TPoint; distance: Int32 = 4): Boolean;
var
  p: TPoint;
begin
  p := Self.GetMyPos();
  Result := p.WithinDistance(worldPoint, distance);
end;

function TRSWalker.AtTile(worldPointArray: TPointArray; distance: Int32 = 4): Boolean; overload;
var
  p: TPoint;
begin
  p := Self.GetMyPos();
  Result := p.WithinDistance(worldPointArray, distance);
end;



(*
TRSWalker.GetClosestPoint
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetClosestPoint(worldPointArray: TPointArray): TPoint;

method used to get the closest Point to the Player out of a TPA.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.GetClosestPoint(worldPointArray: TPointArray): TPoint;
begin
  Result := worldPointArray.NearestPoint(Self.GetMyPos());
end;

(*
TRSWalker.WebWalk
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WebWalk(Destination: TPointArray; waitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;

method used to webwalk to the closest Point to the player.
An example use case is for example, if you have sevel bank booths you can use, those would be your **Destination** TPA.
You will likely want to use the closest bank booth to you, so you use this.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.WebWalk(Destination: TPointArray; waitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestPoint(Destination), waitUntilDistance, PathRandomness);
end;


(*
TRSWalker.WorldToMM
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WorldToMM(playerPoint: TPoint; worldPoints: TPointArray; Radians: Double): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(worldPoints: TPointArray): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;

Overloaded methods required for TRSDotFilter. For more information on TRSDotFilter check their documentation.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.WorldToMM(playerPoint: TPoint; worldPoints: TPointArray; Radians: Double): TPointArray; overload;
var
  P: TPoint;
begin
  for P in worldPoints do
    Result += Self.WorldToMM(playerPoint, P, Radians);
end;

function TRSWalker.WorldToMM(worldPoints: TPointArray): TPointArray; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), worldPoints, Minimap.GetCompassAngle(False));
end;

function TRSWalker.WorldToMM(playerPoint: TPoint; dotFilter: TRSDotFilter; roll: Double = $FFFF): TRSDotFilter; overload;
var
  p: TPoint;
begin
  if (roll = $FFFF) then
    roll := Minimap.GetCompassAngle(False);

  if dotFilter.Circle <> [] then
  begin
    P := Self.WorldToMM(dotFilter.Circle.mean());
    Result.Circle := [P.X, P.Y, dotFilter.Circle.Radius];
  end;

  Result.TPA      := Self.WorldToMM(playerPoint, dotFilter.TPA, roll);
  Result.Inside   := dotFilter.Inside;
  Result.HasTimer := dotFilter.HasTimer;
  Result.Timer    := dotFilter.Timer;
end;

function TRSWalker.WorldToMM(dotFilter: TRSDotFilter; roll: Double = $FFFF): TRSDotFilter; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), dotFilter, roll);
end;

function TRSWalker.WorldToMM(playerPoint: TPoint; DotFilterArray: TRSDotFilterArray; roll: Double = $FFFF): TRSDotFilterArray; overload;
var
  dotFilter: TRSDotFilter;
begin
  if (roll = $FFFF) then
    roll := Minimap.GetCompassAngle(False);

  for dotFilter in dotFilterArray do
    Result += Self.WorldToMM(playerPoint, dotFilter, roll);
end;

function TRSWalker.WorldToMM(dotFilterArray: TRSDotFilterArray; roll: Double = $FFFF): TRSDotFilterArray; overload;
var
  dotFilter: TRSDotFilter;
begin
  for dotFilter in dotFilterArray do
    Result += Self.WorldToMM(Self.GetMyPos(), dotFilter, roll);
end;


(*
TRSWalker.MakePointVisible
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.MakePointVisible(P: TPoint): Boolean;
.. pascal:: function TRSWalker.MakePointVisible(TPA: TPointArray): Boolean; overload;

Wrapper function used to attempt to make a Point visible on the MainScreen.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.MakePointVisible(P: TPoint): Boolean;
begin
  Result := Minimap.MakePointVisible(Self.WorldToMM(P));
end;

function TRSWalker.MakePointVisible(TPA: TPointArray): Boolean; overload;
begin
  Result := Minimap.MakePointVisible(Self.WorldToMM(Self.GetClosestPoint(TPA)));
end;

(*
TRSWalker.GetCuboidMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetCuboidMS(me, loc: TPoint; tile: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray;
.. pascal:: function TRSWalker.GetCuboidMS(loc: TPoint; tile: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray; overload;

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.
This calls **TRSMinimap.GetCuboidMS()** internally which in turn will use both methods above.

To put it simply, this will will first calculate a floor rectangle with **tile.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **tile.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon:

Example
-------
  Debug(RSW.GetCuboidMS([100, 100], [1, 1, 4], Offset));     //This will draw a polygon around the coordinate [100, 100].
*)
function TRSWalker.GetCuboidMS(me, loc: TPoint; shape: TRSMainScreenShape; offset: Vector2 = [0, 0]): TCuboid;
var
  angle: Double;
begin
  angle := Minimap.GetCompassAngle(False);
  loc   := Self.WorldToMM(me, loc, Angle);
  if RSHeightMap.Enabled then
    shape.Tile.Z -= Self.GetHeightDiff(me, loc);
  Result := Minimap.GetCuboidMS(loc, shape, offset, angle);
end;

function TRSWalker.GetCuboidMS(loc: TPoint; shape: TRSMainScreenShape; offset: Vector2 = [0, 0]): TCuboid; overload;
begin
  Result := Self.GetCuboidMS(Self.GetMyPos(), loc, shape, offset);
end;

function TRSWalker.GetCuboidMS(me, loc: TPoint; tile: Vector3 = [1, 1, 4]; offset: Vector2 = [0, 0]): TCuboid; overload;
var
  Angle: Double;
begin
  Angle := Minimap.GetCompassAngle(False);
  loc   := Self.WorldToMM(me, loc, Angle);

  Result := Minimap.GetCuboidMS(loc, tile, Offset, Angle);
end;

function TRSWalker.GetCuboidMS(loc: TPoint; tile: Vector3 = [1, 1, 4]; offset: Vector2 = [0, 0]): TCuboid; overload;
begin
  Result := Self.GetCuboidMS(Self.GetMyPos(), loc, tile, Offset);
end;


(*
TRSWalker.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetTileArrayMS(me: TPoint; locArray: TPointArray; tile: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
.. pascal:: function TRSWalker.GetTileArrayMS(locArray: TPointArray; tile: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;

This are wrapper functions to retrieve multiple tiles. Refer to SRL's TRSWalker.GetTileMSEx() and TRSWalker.GetTileMS() for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.GetTileArrayMS(me: TPoint; locArray: TPointArray; shapeArray: TRSMainScreenShapeArray; offset: Vector2 = [0, 0]): TRectArray;
var
  angle, meHeight: Double;
  i: Int32;
begin
  locArray := locArray.SortFrom(me);
  angle := Minimap.GetCompassAngle(False);
  if RSHeightMap.Enabled then
    meHeight := Self.GetHeight(me);

  for i := 0 to High(locArray) do
  begin
    if RSHeightMap.Enabled then
      shapeArray[i].Tile.Z -= Self.GetHeightDiff(locArray[i]);
    locArray[i] := Self.WorldToMM(me, locArray[i], angle);

    Result += Minimap.GetTileMS(locArray[i], shapeArray[i].Tile, offset, angle + shapeArray[i].Angle);
  end;
end;

function TRSWalker.GetTileArrayMS(me: TPoint; locArray: TPointArray; shape: TRSMainScreenShape; offset: Vector2 = [0, 0]): TRectArray; overload;
var
  angle, meHeight: Double;
  i: Int32;
begin
  locArray := locArray.SortFrom(me);
  angle := Minimap.GetCompassAngle(False);
  if RSHeightMap.Enabled then
    meHeight := Self.GetHeight(me);

  for i := 0 to High(locArray) do
  begin
    if RSHeightMap.Enabled then
     shape.Tile.Z -= Self.GetHeightDiff(locArray[i]);
    locArray[i] := Self.WorldToMM(me, locArray[i], angle);

    Result += Minimap.GetTileMS(locArray[i], shape.Tile, offset, angle + shape.Angle);
  end;
end;

function TRSWalker.GetTileArrayMS(me: TPoint; locArray: TPointArray; tile: Vector3; offset: Vector2 = [0, 0]): TRectArray; overload;
var
  angle, meHeight: Double;
  i: Int32;
begin
  locArray := locArray.SortFrom(me);
  angle := Minimap.GetCompassAngle(False);
  if RSHeightMap.Enabled then
    meHeight := Self.GetHeight(me);

  for i := 0 to High(locArray) do
  begin
    if RSHeightMap.Enabled then
      tile.Z -= Self.GetHeightDiff(locArray[i]);
    locArray[i] := Self.WorldToMM(me, locArray[i], angle);

    Result += Minimap.GetTileMS(locArray[i], tile, offset, angle);
  end;
end;

function TRSWalker.GetTileArrayMS(locArray: TPointArray; tile: Vector3 = [1, 1, 0]; offset: Vector2 = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos(), locArray, tile, offset);
end;


(*
TRSWalker.GetCuboidArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetCuboidArrayMS(me: TPoint; locArray: TPointArray; tile: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;
.. pascal:: function TRSWalker.GetCuboidArrayMS(locArray: TPointArray; tile: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetCuboidMS** for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetCuboidArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSWalker.GetCuboidArrayMS(me: TPoint; locArray: TPointArray; shapeArray: TRSMainScreenShapeArray; Offset: Vector2 = [0, 0]): TCuboidArray;
var
  angle, meHeight: Double;
  i: Int32;
  tmpArray: TPointArray;
begin
  angle := Minimap.GetCompassAngle(False);
  tmpArray := Copy(locArray);

  if RSHeightMap.Enabled then
    meHeight := Self.GetHeight(me);

  for i := 0 to High(tmpArray) do
  begin
    if RSHeightMap.Enabled then
      shapeArray[i].Tile.Z -= meHeight - Self.GetHeight(locArray[i]);
    tmpArray[i] := Self.WorldToMM(me, locArray[i], angle);
  end;

  Result := Minimap.GetCuboidArrayMS(tmpArray, shapeArray, Offset, angle);
end;

(* TODO: FIXXXXX *)
function TRSWalker.GetCuboidArrayMS(me: TPoint; locArray: TPointArray; shape: TRSMainScreenShape; Offset: Vector2 = [0, 0]): TCuboidArray; overload;
var
  angle, meHeight: Double;
  i: Int32;
  tmpArray: TPointArray;
  shapeArray: TRSMainScreenShapeArray;
begin
  angle := Minimap.GetCompassAngle(False);
  tmpArray := Copy(locArray);

  if RSHeightMap.Enabled then
    meHeight := Self.GetHeight(me);

  for i := 0 to High(tmpArray) do
  begin
    shapeArray += shape;
    if RSHeightMap.Enabled then
      shapeArray[i].Tile.Z -= meHeight - Self.GetHeight(locArray[i]);
    tmpArray[i] := Self.WorldToMM(me, locArray[i], angle);
  end;

  Result := Minimap.GetCuboidArrayMS(tmpArray, shape, Offset, angle);
end;

function TRSWalker.GetCuboidArrayMS(me: TPoint; locArray: TPointArray; tile: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TCuboidArray; overload;
var
  shape: TRSMainScreenShape;
begin
  shape := [tile, 0];
  Result := Self.GetCuboidArrayMS(me, locArray, shape, offset);
end;

function TRSWalker.GetCuboidArrayMS(locArray: TPointArray; tile: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TCuboidArray; overload;
begin
  Result := Self.GetCuboidArrayMS(Self.GetMyPos(), locArray, tile, Offset);
end;


(*
TRSWalker.GetMMPoly
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetMMPoly(locArray: TPointArray): TPointArray;

This function converts a list of points to their respective points in the minimap.
This is extremely useful if you want to be sure you are within an area.
To make a polygon or a polygon array easily you can use Simba/Includes/WaspLib/tools/walkerpolygon.simba.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

Example
-------
  Debug(RSW.GetMMPoly(TPA).Connect());    //This will draw your TPA on the minimap.
*)
function TRSWalker.GetMMPoly(locArray: TPointArray): TPointArray;
begin
  Result := Self.WorldToMM(locArray);
end;

(*
TRSWalker.InPoly
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.InPoly(locArray: TPointArray): Boolean;

Checks if you are inside a polygon. If you need to debug the polygon check the example in TRSWalker.GetMMPoly.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

*)
function TRSWalker.InPoly(locArray: TPointArray): Boolean;
begin
  Result := PointInPolygon(Self.GetMyPos(), locArray);
end;



//This walker overloads are a bit messy... I need to find a cleaner way to do this later on but basically makes sure we stop trying to walk when we already
//red clicked the waspobject.
function TRSWalker.Click(mmPoint: TPoint; upText: TStringArray; out redClicked: Boolean; randomness: Int32): Boolean; overload;
var
  p: TPoint;
  line: TPointArray;
  i, j: Int32;
  hoveringTarget: Boolean;
  msUpText, str: String;
begin
  if MainScreen.IsUpText('>') then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  Result := True;

  if Self.ScreenWalk then
  begin
    repeat
      i += 1;
      p := mmPoint.Random(-randomness, randomness);
      if i >= 15 then
      begin
        WriteLn 'Stuck in TRSWalker.Click infinite loop';
        line := TPointArray.CreateFromLine(p, Minimap.Center());
        for j := 0 to High(line) do
          if Minimap.PointInZoomRectangle(line[j]) then
          begin
            p := line[j];
            Break;
          end;
      end;
    until Minimap.PointInZoomRectangle(p);

    Mouse.Move(Minimap.PointToMsRect(p).Mean());
    msUpText := MainScreen.GetUpText();

    for str in upText do
      if str in msUpText then
      begin
        hoveringTarget := True;
        Break;
      end;

    if not hoveringTarget and not ('Walk here' in msUpText) then
      Exit(ChooseOption.Select('Walk here'));
  end else
  begin
    repeat
      P := mmPoint.Random(-Randomness, Randomness);
    until Minimap.IsPointOn(P);

    Mouse.Move(P);
  end;

  Mouse.Click(MOUSE_LEFT);

  // 15% chance of spam clicking
  if (Randomness > 0) and (Random < Antiban.GetUniqueNumber(0.15, 0.1, 0.2)) then
    for i := 0 to Round(Antiban.GetUniqueNumber(2, 1, 3)) do
    begin
      Mouse.Click(Mouse.Position, MOUSE_LEFT);

      Wait(20, 150, wdLeft);
    end;

  redClicked := Self.ScreenWalk and hoveringTarget and MainScreen.DidRedClick;
end;

function TRSWalker.WalkFinalStep(playerPoint, worldPoint: TPoint; upText: TStringArray; out redClicked: Boolean; waitUntilDistance: Int32): Boolean; overload;
var
  mmPoint: TPoint;
begin
  if (@Self.OnWalkEvent <> nil) then
    Self.OnWalkEvent(@Self, playerPoint, worldPoint);
  if (@Self.OnWalkEventEx <> nil) then
    Self.OnWalkEventEx(@Self, playerPoint, worldPoint);

  if not Self.Enabled then
    Exit(True);

  mmPoint := Self.WorldToMM(playerPoint, worldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(mmPoint)) then
    Exit(False);
  if (Minimap.Center().DistanceTo(mmPoint) < 5) then
    Exit(True);

  Result := Self.Click(mmPoint, UpText, redClicked, 0);
  if Result then
    Self.WaitMoving(worldPoint, waitUntilDistance);
end;

function TRSWalker.WalkStep(playerPoint, worldPoint: TPoint; UpText: TStringArray; out redClicked: Boolean): Boolean; overload;
var
  mmPoint: TPoint;
  waitUntilDistance: Int32;
begin
  if (@Self.OnWalkEvent <> nil) then
    Self.OnWalkEvent(@Self, playerPoint, worldPoint);
  if (@Self.OnWalkEventEx <> nil) then
    Self.OnWalkEventEx(@Self, playerPoint, worldPoint);

  if not Self.Enabled then
    Exit(True);

  mmPoint := Self.WorldToMM(playerPoint, worldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(mmPoint)) then
    Exit(False);
  if (Minimap.Center().DistanceTo(mmPoint) < 5) then
    Exit(True);

  Result := Self.Click(mmPoint, UpText, redClicked, Self.ClickRandomness);

  if Result then
  begin
    if (Random() < 0.15) then // 15% chance of randomness else mean
      waitUntilDistance := Random(Distance(Minimap.Center(), mmPoint))
    else
      waitUntilDistance := RandomMean(0, Distance(Minimap.Center(), mmPoint) + 10);

    Self.WaitMoving(worldPoint, waitUntilDistance);
  end
end;

function TRSWalker.WalkPath(Path: TPointArray; upText: TStringArray; out redClicked: Boolean; waitUntilDistance: Int32 = 0): Boolean; overload;

  function BuildPath(TPA: TPointArray): TPointArray;
  var
    I, J: Int32;
    line: TPointArray;
  begin
    for I := 1 to High(TPA) do
    begin
      line := TPointArray.CreateFromLine(TPA[I-1], TPA[I]);

      J := 0;
      while J < High(line) do
      begin
        Result += line[J];

        // keep the steps low, as mainscreen walking might just have a few tiles visible when NearZoomMode is set True
        if (Self.NearZoomMode) and ((Self.ScreenWalk) or (Self.AdaptiveWalk)) then
          Inc(J, Random(1, 4))
        else
          Inc(J, Random(3, 12));
      end;
    end;

    Result += TPA[High(TPA)];
  end;

  function AdvancePath(var Index: Int32; playerPoint: TPoint): Boolean;
  var
    Angle: Double := Minimap.GetCompassAngle(False);
    Previous: Int32 := Index;
    Nearest, Furthest: Int32;
  begin
    Nearest := Self.Path.IndexOf(Self.Path.NearestPoint(playerPoint));
    Self.PathIndex := Nearest;

    while (Nearest < High(Self.Path)) and (not Self.IsWalkable(Self.Path[Nearest+1], playerPoint, Angle)) do
      Inc(Nearest);

    Furthest := Nearest;
    while (Furthest < High(Self.Path)) and Self.IsWalkable(Self.Path[Furthest+1], playerPoint, Angle) do
      Inc(Furthest);

    Index := Furthest;

    // do the result check before randomness to avoid false error
    Result := (Index > Previous);

    // 15% chance of randomness else furthest
    if Random() < 0.15 then
      Index := Random(Nearest, Furthest);
  end;

var
  playerPoint: TPoint;
  index, fails: Int32;
begin
  Self.Enabled := True;
  playerPoint := Self.GetMyPos();
  Self.Path := BuildPath([playerPoint] + Path);

  if Self.AdaptiveWalk then
  begin
    Self.AdaptiveToggleDistances.X := RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.X + Random(-6,6);
    Self.AdaptiveToggleDistances.Y := RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.Y + Random(-16,16);
    Self.AdaptiveWalkCheck(playerPoint);
  end;

  while Self.Enabled and (fails < 10) do
  begin
    playerPoint := Self.GetMyPos();

    if AdvancePath(index, playerPoint) then
      fails := 0
    else
    begin
      Inc(fails);

      // Likely haven't moved far enough to advance to next point
      if (fails < 5) then begin
        Wait(300);
        Continue;
      end else begin
        // screen walking struggles, so disable it
        if Self.AdaptiveWalk then
          Self.ScreenWalk := False
        else if (fails = 5) then
          case SRL.Dice(50) of
            True:  Minimap.SetCompassAngle(Minimap.GetCompassAngle() - RandomLeft(30, 360));
            False: Minimap.SetCompassAngle(Minimap.GetCompassAngle() + RandomLeft(30, 360));
          end;
      end;

      if (fails mod 2 = 0) then
        Minimap.WaitFlag();
    end;

    if index = High(Self.Path) then
    begin
      if Self.WalkFinalStep(playerPoint, Self.Path[index], upText, redClicked, waitUntilDistance) then
        Exit(True);
    end else
      Self.WalkStep(playerPoint, Self.Path[index], upText, redClicked);

    if redClicked then
      Exit(True);
  end;

  if fails = 10 then
    Self.DebugLn('Failed to advance path');
end;

function TRSWalker.WebWalk(Destination: TPoint; UpText: TStringArray; out redClicked: Boolean; waitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
var
  Path: TPointArray;
begin
  if not InRange(PathRandomness, 0, 1) then
    Self.Fatal('TRSWalker.WebWalk `PathRandomness` must be within 0..1');

  Path   := Self.WebGraph.PathBetween(Self.GetMyPos, Destination, PathRandomness);
  Result := Self.WalkPath(Path, UpText, redClicked, waitUntilDistance);
end;

function TRSWalker.WebWalk(Destination: TPointArray; UpText: TStringArray; out redClicked: Boolean; waitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestPoint(Destination), UpText, redClicked, waitUntilDistance, PathRandomness);
end;



begin
  RSHeightMap.Enabled := True;
  RSHeightMap.MaxHeight := 30;
end;
