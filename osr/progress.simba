{$DEFINE WL_PROGRESS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
type TProgressReport
~~~~~~~~~~~~~~~~~~~~~~~~

Type responsible for handling the HUDProgressReport, also commonly called as "Paint" or InGame/OnScreen Progress Report.
*)
type
  TProgressReport = record
    BGImg: TMufasaBitmap;
    Cache: TMufasaBitmap;

    TextColor: Int32;
    PreviousStrArray: TStringArray;

    Timer: TTimer;
    UsernameBox: TBox;

    Terminated: Boolean;
    IsSetup: Boolean;
  class var
    PadLength: Int32;
    PTimeRunning: ^TStopwatch;
    ProgressArray: TStringArray;
  end;

(*
ProgressReport.GetNextCycleColor
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TProgressReport.GetNextCycleColor(Color, Step: Int32): Int32;

Not currently used for anything, just a fun experiment. Can be used to give an RGB cycle effect.
You can see it in effect by uncommenting `Self.TextColor := Self.GetNextCycleColor(Self.TextColor, 10);` in **TProgressReport.Update()**.
*)
function TProgressReport.GetNextCycleColor(Color, Step: Int32): Int32;
var
  R, G, B: Int32;
begin
  ColorToRGB(Color, R, G, B);

  if (R = 255) and (G = 0) and (B < 255) then
    B += Step
  else if (R > 0)   and (G = 0)   and (B = 255) then
    R -= Step
  else if (R = 0)   and (G < 255) and (B = 255) then
    G += Step
  else if (R = 0)   and (G = 255) and (B > 0) then
    B -= Step
  else if (R < 255) and (G = 255) and (B = 0) then
    R += Step
  else if (R = 255) and (G > 0)   and (B = 0) then
    G -= Step;

  if R < 0    then R := 0;
  if R > 255 then R := 255;

  if G < 0    then G := 0;
  if G > 255 then G := 255;

  if B < 0    then B := 0;
  if B > 255 then B := 255;

  writeLn('R: ', R, ' G: ', G, ' B: ', B);
  Result := RGBtoColor(R, G, B);
end;

(*
ProgressReport.Terminate
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.Terminate();

Internal method called automatically on termination. This will do things such as free used assetsa and clear the progress report from the game screen.
*)
procedure TProgressReport.Terminate();
begin
  if Self.Terminated then //avoids multiple terminations in case the script is chained.
    Exit;

  Self.BGImg.Clear();
  Self.BGImg.Free();

  RSClient.Image.Clear();
  RSClient.Image.Free(); //not sure if it needs to be freed?

  Self.Terminated := True; //avoids multiple terminations in case the script is chained.
end;

(*
ProgressReport.Setup
~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.Setup();

Internal method called when we need to setup TProgressReport.
*)
procedure TProgressReport.Setup();
begin
  Self.BGImg := TMufasaBitmap.Create();
  Self.BGImg.Clear();
  Self.BGImg.LoadFromFile({$MACRO CURRENT_DIRECTORY} + 'WaspProgress.png');
  Self.BGImg.setFontAntialiasing(True);

  RSClient.Image := RSClient.Image;
  RSClient.Image.Clear();
  RSClient.Image.setFontAntialiasing(True);
  RSClient.Image.setFontSize(13);

  if Self.BGImg.GetFonts().Contains('Consolas') then
    Self.BGImg.setFontName('Consolas');
  RSClient.Image.setFontName('Consolas');

  Self.TextColor := $006CFF;

  Self.UsernameBox := Chat.GetDisplayNameBox();

  AddOnTerminate(@Self.Terminate);
end;

(*
ProgressReport.DrawBackground
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.DrawBackground(StrArray: TStringArray; FontColor: Int32);

Method that handles drawing the background of our TProgressReport.
Usually called internally by TProgressReport.Update().
*)
procedure TProgressReport.DrawBackground(StrArray: TStringArray; FontColor: Int32);
begin
  if not Self.IsSetup then
  begin
    Self.BGImg.setFontSize(18);
    Self.BGImg.DrawTextShadow(ScriptName.Before('.simba').Replace('_', ' ').Capitalize(), [Round(Self.BGImg.GetWidth()/2) + 25, 7], FontColor, False);

    Self.BGImg.setFontSize(14);
    FontColor -= $90A301 - $C8D100;

    Self.BGImg.DrawText(StrArray.Last(), [10, 135], FontColor);

    Self.IsSetup := True;
  end;

  RSClient.Image.DrawBitmap(Self.BGImg, [Chat.Bounds.X1, Chat.Bounds.Y1 - 12]);
end;

(*
ProgressReport.DrawProgress
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.DrawProgress(StrArray: TStringArray; FontColor: Int32);

Method that handles drawing the text of our TProgressReport.
Usually called internally by TProgressReport.Update().
*)
procedure TProgressReport.DrawProgress(StrArray: TStringArray; FontColor: Int32);
var
  p, q: TPoint;
  i: Int32;
begin
  p := [Chat.Bounds().X1 + 10, Chat.Bounds().Y1 + 40];
  q := [Round(Chat.Bounds().Width()/2) + 20, p.y];

  FontColor -= $C8D100;

  for i := 0 to High(StrArray) - 1 do
  begin
    if Frac(i/2) = 0 then
    begin
      RSClient.Image.DrawTextShadow(StrArray[i], p, FontColor, False);
      p.Y += 20;
    end
    else
    begin
      RSClient.Image.DrawTextShadow(StrArray[i], q, FontColor, False);
      q.Y += 20;
    end;
  end;

  Self.PreviousStrArray := StrArray;
end;

(*
ProgressReport.HideProgress
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.HideProgress();

Used to hide TProgressReport.
Usually called internally by TProgressReport.Update().
*)
procedure TProgressReport.HideProgress();
begin
  Self.IsSetup := False;

  RSClient.Image.DrawBoxFilled(Self.UsernameBox, $819DAC); //Hide username by painting a box with similar color to the chatbox background.
end;

(*
ProgressReport.Update
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.Update(StrArray: TStringArray);

Main method that should be called to used to start and update TProgressReport.

To see TProgressReport.GetNextCycleColor() in action, which was just a fun experiment,
uncomment `Self.TextColor := Self.GetNextCycleColor(Self.TextColor, 10);`
*)
procedure TProgressReport.Update(StrArray: TStringArray);
begin
  RSClient.Image.Clear();

  if StrArray = [] then
    Exit;

  //Self.TextColor := Self.GetNextCycleColor(Self.TextColor, 10);
  Self.DrawBackground(StrArray, Self.TextColor);
  Self.DrawProgress(StrArray, Self.TextColor);
end;

(*
ProgressReport.Setup
~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TProgressReport.Setup(); override;

Overriden method to enable TProgressReport.Timer.
This required to be overriden or we couldn't call already declared methods in ProgressReport.CheckButton().
*)
procedure TProgressReport.Setup(); override;
begin
  inherited;

  AddOnPause(@Self.HideProgress);
end;

(*
var ProgressReport
~~~~~~~~~~~~~~~~~~

Global TProgressReport variable.
*)
var
  ProgressReport: TProgressReport;
