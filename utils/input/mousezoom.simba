(*
MouseZoom
=========
Methods to handle the zoom levels with he mouse wheel.
*)

{$DEFINE WL_MOUSEZOOM_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

const
  MAX_TRUE_ZOOM = 768;

type
  TRSMouseZoom = record
    TrueZoomLevel: Int32;
 end;

function TRSMouseZoom.GetNext(value: Int32; down: Boolean): Int32;
begin
  if down then
    Result := value-26
  else
    Result := value+24;

  Result := EnsureRange(Result, 0, MAX_TRUE_ZOOM);
end;


function TRSMouseZoom.GetNext(value: Int32; amount: Int32 = 1; down: Boolean = True): Int32; overload;
var
  i: Int32;
begin
  Result := value;
  for i := 0 to amount-1 do
    Result := Self.GetNext(Result, down);
end;


function TRSMouseZoom.Level2Slider(value: Int32 = -1): Int32;
begin
  if value < 0 then
    value := Self.TrueZoomLevel;

  Result := Floor(value/8);

  //The following levels do not exist in the slider, probably due to roundings.
  //The scale of 0-100 is made up by us so we are bound to rounding issues.
  if Result >= 13 then
    Result += 1;

  if Result >= 37 then
    Result += 1;

  if Result >= 63 then
    Result += 1;

  if Result >= 87 then
    Result += 1;
end;

function TRSMouseZoom.Slider2Level(value: Int32 = -1): Int32;
begin
  if value < 0 then
    value := MM2MS.ZoomLevel;

  //The following levels do not exist in the slider, probably due to roundings.
  //The scale of 0-100 is made up by us so we are bound to rounding issues.
  //The slider real scale is actually 0-96.
  if value >= 13 then
    value -= 1;

  if value >= 37 then
    value -= 1;

  if value >= 63 then
    value -= 1;

  if value >= 87 then
    value -= 1;

  Result := value * 8;
end;

procedure TRSMouseZoom.Scroll(amount: Int32 = 1; down: Boolean; moveMouse: Boolean = True);
begin
  Self.TrueZoomLevel := Self.GetNext(Self.TrueZoomLevel, amount, down);

  MM2MS.ZoomLevel := Self.Level2Slider(Self.TrueZoomLevel);

  if moveMouse then
    Mouse.Scroll(MainScreen.Bounds(), amount, down)
  else
    Mouse.Scroll(amount, down);
end;

procedure TRSMouseZoom.Scroll(amount: Int32 = 1; moveMouse: Boolean = True); overload;
begin
  Self.Scroll(Floor(Sqrt(Power(amount,2))), amount < 0, moveMouse);
end;

procedure TRSMouseZoom.MaxZoom(down: Boolean = True);
var
  scrolls: Int32;
begin
  if down then
    scrolls := Floor(Self.TrueZoomLevel/26) + Random(3, 6)
  else
    scrolls := Floor((MAX_TRUE_ZOOM - Self.TrueZoomLevel)/24) + Random(3, 6);
  Self.Scroll(scrolls, down, True);
end;

function TRSMouseZoom.SetZoomLevel(level: Int32): Boolean;
var
  trueLevel, amount: Int32;
begin
  trueLevel := Self.Slider2Level(level);

  if InRange(trueLevel, Self.TrueZoomLevel-26, Self.TrueZoomLevel+24) then
    Self.MaxZoom(Antiban.BioDice());

  amount := trueLevel - Self.TrueZoomLevel;

  if Self.TrueZoomLevel > trueLevel then
    amount := Floor(amount/26)
  else
    amount := Floor(amount/24);

  Self.Scroll(amount);

  Result := InRange(MM2MS.ZoomLevel, level-4, level+4);
end;





//Only used for stress testing!
procedure TRSMouseZoom.AntiLogout(i, iterations: Int32);
begin

  if Frac(i/1000) = 0 then
    WriteLn('Progress: ', i, ' of ', iterations);

  if Frac(i/250) <> 0 then
    Exit;

  if Frac(i/500) = 0 then
    Self.MaxZoom(SRL.Dice(50))
  else
    case SRL.Dice(50) of
      True:  Minimap.SetCompassAngle(Minimap.GetCompassAngle() - RandomMode(30, 360, 3));
      False: Minimap.SetCompassAngle(Minimap.GetCompassAngle() + RandomMode(30, 360, 3));
    end;

  Mouse.Move(InterfaceArea.Bounds(), True);
end;

procedure TRSMouseZoom.RunStressTest(iterations: Int32 = 19999);
var
  i, slider: Int32;
  fails: TIntegerArray;
  down: Boolean;
begin
  Options.SetZoomLevel(50);
  Mouse.Move(InterfaceArea.Bounds(), True);

  SetLength(fails, 5);
  try
    for i := 0 to iterations do
    begin
      Self.AntiLogout(i, iterations);
      Down := SRL.Dice(48);

      Self.Scroll(1, down, True);
      Wait(5);
      slider := Options.GetZoomLevel();

      if slider = MM2MS.ZoomLevel then
        Continue;

      fails[0] += 1;
      if InRange(MM2MS.ZoomLevel, slider-2, slider+2) then
        Continue;

      fails[1] += 1
      if InRange(MM2MS.ZoomLevel, slider-5, slider+5) then
        Continue;

      fails[2] += 1;
      if InRange(MM2MS.ZoomLevel, slider-10, slider+10) then
        Continue;

      fails[3] += 1;
      if InRange(MM2MS.ZoomLevel, slider-15, slider+15) then
        Continue;

      fails[4] += 1;
    end;
  finally
    iterations := i; //
    WriteLn 'Level 0 fail = any fail.'+ LINEENDING + 'Level 1 fail = Fail that was off by 2' + LINEENDING +
            'Level 2 fail = Fail that was off by 5' + LINEENDING +
            'Level 3 fail = Fail that was off by 10 (this can really break things)' + LINEENDING +
            'Level 4 fail = Fail that was off by 15 (this can really break things)';

    for i := 0 to High(fails) do
      WriteLn('Level ', i, ' fail rate: ', fails[i], '/', iterations, ' (', Round(fails[i]/iterations * 100, 2), '%)');
  end;
end;


procedure TRSMouseZoom.DrawGraph();
var
  bmp: TMufasaBitmap;
  i: Int32;
  levelTPA, zInTPA, zOutTPA, zSlider: TPointArray;
begin
  bmp := TMufasaBitmap.Create(MAX_TRUE_ZOOM+10, MAX_TRUE_ZOOM+10);

  bmp.Fill($ECECEC);

  for i:=0 to bmp.GetWidth() do
    if Frac(i/2) = 0 then
      bmp.DrawLine([i,0], [i,bmp.GetHeight()], $F5F5F5); //This makes it easier to see... makes alternating gray scale columns.

  for i := 0 to MAX_TRUE_ZOOM do
  begin
    levelTPA += [i, i];
    zInTPA   += [i, Self.GetNext(i, False)];
    zOutTPA  += [i, Self.GetNext(i, True)];
    zSlider  += [i, Self.Level2Slider(i)];
  end;

  bmp.DrawTPA(levelTPA, Colors.ORANGE);
  bmp.DrawTPA(zInTPA, Colors.BLUE_OCEAN);
  bmp.DrawTPA(zOutTPA, Colors.CYAN);
  bmp.DrawTPA(zSlider, Colors.GREEN_SPRING);

  bmp.Show(True);
  bmp.Free();
end;

var
  RSMouseZoom: TRSMouseZoom;

function TRSOptions.SetZoomLevel(level: Int32): Boolean; override;
begin
  Result := inherited();
  if not Result then
    level := Options.GetZoomLevel();

  RSMouseZoom.TrueZoomLevel := RSMouseZoom.Slider2Level(level);
end;

