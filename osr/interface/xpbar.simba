{$DEFINE WL_XPBAR_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

const
  XP_COLORS: TIntegerArray = [
    $FFFFFF, //white
    $FFC8C8, //lilac
    $FF00FF, //cyan
    $C8FFC8, //jade
    $64FF64, //lime
    $40FFFF, //yellow
    $1F98FF, //orange
    $C8C8FF  //pink
  ];

type
  TRSXPDrop = record(TRSInterface)
    IsSetup: Boolean;
    Color: Int32;
    Alignments: array[ERSXPBarLocation] of TRSInterfaceAlignment;
  end;

procedure TRSXPDrop.Setup; override;
begin
  inherited;

  Self.Name := 'XPDrop';

  with Self.Alignments[ERSXPBarLocation.LEFT] do
  begin
    Left := [@InterfaceArea.X1, 16];
    Right := [@InterfaceArea.X1, 36];
    Top := [@InterfaceArea.Y1, 51];
    Bottom := [@InterfaceArea.Y1, 128];
  end;

  with Self.Alignments[ERSXPBarLocation.MIDDLE] do
  begin
    Left   := [@InterfaceArea.X1, 14];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 51];
    Bottom := [@InterfaceArea.Y1, 128];
    Center.MaxWidth  := 20;
  end;

  with Self.Alignments[ERSXPBarLocation.RIGHT] do
  begin
    Left   := [@InterfaceArea.X2, -22];
    Right  := [@InterfaceArea.X2, -2];
    Top    := [@InterfaceArea.Y1, 28];
    Bottom := [@InterfaceArea.Y1, 133];
  end;

end;

procedure TRSXPDrop.SetupAlignment(Mode: ERSClientMode); override;
begin
  inherited;

  // Default location
  Self.Alignment := Self.Alignments[ERSXPBarLocation.RIGHT];
end;


function TRSXPDrop.IsOpen: Boolean;
var
  TPA: TPointArray;
begin
  if FindColors(TPA, 11592943, Minimap.GetXPCircle.Bounds) then
    Result := Length(Minimap.GetXPCircle().Filter(TPA)) > 50;

  if Result and not IsSetup and XPBar.IsOpen then
  begin
    if (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.LEFT][ERSXPBarSize.SMALL]) or
       (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.LEFT][ERSXPBarSize.MEDIUM]) or
       (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.LEFT][ERSXPBarSize.LARGE]) then
      Self.Alignment := Self.Alignments[ERSXPBarLocation.LEFT]

    else if (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.MIDDLE][ERSXPBarSize.SMALL]) or
            (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.MIDDLE][ERSXPBarSize.MEDIUM]) or
            (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.MIDDLE][ERSXPBarSize.LARGE]) then
      Self.Alignment := Self.Alignments[ERSXPBarLocation.MIDDLE]

    else if (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.RIGHT][ERSXPBarSize.SMALL]) or
            (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.RIGHT][ERSXPBarSize.MEDIUM]) or
            (XPBar.Alignment = XPBar.Alignments[ERSXPBarLocation.RIGHT][ERSXPBarSize.LARGE]) then
      Self.Alignment := Self.Alignments[ERSXPBarLocation.RIGHT];
    IsSetup := True;
  end;
end;

function TRSXPDrop.Open: Boolean;
begin
  if Self.IsOpen then
    Exit(True);

  Mouse.Click(Minimap.GetXPCircle(), MOUSE_LEFT);

  Result := WaitUntil(Self.IsOpen(), SRL.TruncatedGauss(100, 1000), 3000);
end;


function TRSXPDrop.Find: Boolean;
var
  i, ColorCount: Int32;
begin
  if Color = 0 then
  begin
    for i := 0 to High(XP_COLORS) do
    begin
      ColorCount := SRL.CountColor(XP_COLORS[i], Self.Bounds);
      if (ColorCount > 0) and (ColorCount < 150) then
      begin
        Color := XP_Colors[i];
        Exit(True);
      end
      else if i = High(XP_COLORS) then
        Color := 0; //not found, reset!
    end;
  end
  else
  begin
    ColorCount := SRL.CountColor(Color, Self.Bounds);
    Exit((ColorCount > 0) and (ColorCount < 150));
  end;
end;

function TRSXPDrop.UpdateLocation: Boolean;
var
  Location: ERSXPBarLocation;
begin
  if IsSetup then
    Exit;
  Writeln 'IsSetup: ' + ToStr(IsSetup);
  for Location in ERSXPBarLocation do
  begin
    Self.Cache := [];
    Self.Alignment := Self.Alignments[Location];
    if Self.Find then
    begin
      IsSetup := True;
      Exit(True);
    end;
  end;
end;


function TRSXPDrop.FindDrop: Boolean;
begin
  Result :=  Self.Find or Self.UpdateLocation;
end;


function TRSXPDrop.WaitDrop(WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := SRL.TruncatedGauss(50, 200);

  Result := WaitUntil(Self.FindDrop, Interval, WaitTime);
end;

procedure TRSXPDrop.Draw(Bitmap: TMufasaBitmap); override;
begin
  if not Self.IsOpen then
    Exit;

  inherited;

  with Minimap.GetXPCircle do
    Bitmap.DrawCircle([X, Y], Radius, $00FFFF);

  Self.FindDrop;
  Bitmap.DrawBox(Self.Bounds, $00FFFF);
end;


var
  XPDrop: TRSXPDrop;

procedure TRSClient.ClientModeChanged; override;
begin
  inherited;

  XPDrop.SetupAlignment(Self.Mode);
end;

procedure TSRL.Setup; override;
begin
  inherited;

  XPDrop.Setup();
end;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
begin
  inherited;

  XPDrop.Draw(Bitmap);
end;
