{$DEFINE WL_OBJECT_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TRSObject = record
    Map: TRSWalker;
    Tiles: TPointArray;
    Height: Int32;
    UpText: TStringArray;
    Finder: TRSObjectFinder;
  end;

  TRSObjectArray = array of TRSObject;

var
  CurrentBank: TRSObject;

{$I walker/worldobject.simba}
{$I walker/zeahobject.simba}

// Searches for an object with ObjectFinder in the MainScreen with the
// help of RSWalker. Good when objects don't move and precision is needed.
function TRSObject.Find: T2DPointArray;
var
  Me: TPoint;
  Tile: TPoint;
  TileArray: TPointArray;
  i: Int32;
  Rect: TRectangle;
  Box: TBox;
  TPA: TPointArray;
  ATPA: T2DPointArray;
begin
  Me := Map.GetMyPos();
  TileArray := Copy(Tiles);
  TileArray.Sorted(Me);

  for Tile in TileArray do
  begin
    for i := 0 to Height do
    begin
      Rect := Map.GetTileMSEx(Me, Tile, i);
      ATPA += Rect.ToTPA;
    end;


    TPA := ATPA.Merge;
    TPA.ClearDuplicates;
    Box := TPA.Bounds;
    if InterfaceArea.Bounds.Contains(Box) then
      Result += MainScreen.FindObject(Finder, Box);
  end;

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

procedure TRSObject.SetupCommon(Walker: TRSWalker);
begin
  Map := Walker;
  Height := 3;
  Finder.ClusterDistance := 2;
  Finder.Erode := 2;
  Finder.Grow := 4;
end;

procedure TRSObject.Debug;
var
  Bitmap: TMufasaBitmap;
  Tile: TPoint;
  ATPA: T2DPointArray;
  Obj: T2DPointArray;
  Rect: TRectangle;
  Rectangles: Array of TRectangle;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  //Debug tiles
  for Tile in Tiles do
    Rectangles += Map.GetTileMS(Tile);
  for Rect in Rectangles do
    ATPA += Rect.ToTPA.Connect;
  Bitmap.DrawATPA(ATPA);

  //Debug Object
  Obj := Self.Find;
  Bitmap.DrawATPA(Obj);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;


function TRSObjectArray.GetClosestObject: TRSObject;  //NEED REWORK MAYBE?
var
  Map: TRSWalker;
  i: Int32;
  ClosestTiles: TPointArray;
  RSObject: TRSObject;
begin
  if Self = [] then
    Exit;

  for i := 0 to High(Self) do
  begin
    if Map = [] then
      Map := RSObject.Map;

    if Map <> RSObject.Map then
      Exit;

    ClosestTiles += Map.GetClosestTile(Self[i].Tiles);
  end;

  Result := Self[ClosestTiles.Find(Map.GetClosestTile(ClosestTiles))];
end;

procedure TRSWalker.SetCurrentBank(RSObject: TRSObject);
begin
  CurrentBank := RSObject;
end;


// HoverHelper function used by all non moving object hovering functions.
function TRSWalker.HoverHelper(RSObject: TRSObject; Attempts: Int32): Boolean; overload;
var
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for 0 to Attempts do
  begin
    if MainScreen.IsUpText(RSObject.UpText) then
      Exit(True);

    if (ATPA := RSObject.Find) <> [] then
    begin
      Points := ATPA[Random(0, High(ATPA))];
      Mouse.Move(Points.MinAreaRect);
    end;

    if MainScreen.IsUpText(RSObject.UpText) then
      Exit(True);

    Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// WalkHoverHelper function used by all moving object hovering functions.
function TRSWalker.WalkHoverHelper(RSObject: TRSObject; Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if MainScreen.IsUpText(RSObject.UpText) then
      Exit(True);

    if (ATPA := RSObject.Find) <> [] then
    begin
      Points := ATPA[Random(0, High(ATPA))];
      Mouse.Move(Points.MinAreaRect);
    end;

    if MainScreen.IsUpText(RSObject.UpText) then
      Exit(True)
    else if not Self.AtTile(RSObject.Tiles, 50) or ((Attempt = (Attempts - 1)) and not Self.AtTile(RSObject.Tiles, 30)) then
      Self.WebWalk(Self.GetClosestTile(RSObject.Tiles), 10, 0.2)
    else
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// ClickHelper function used by all object clicking functions.
function TRSWalker.ClickHelper(UpText: TStringArray; LeftClick: Boolean): Boolean;
begin
  if ChooseOption.IsOpen and ChooseOption.Select(UpText) then
    Exit(True);

  if LeftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and ChooseOption.Select(UpText));
end;

// SelectHelper function used by all object option selection functions.
function TRSWalker.SelectHelper(Action, UpText: TStringArray): Boolean;
begin
  if ChooseOption.IsOpen and
     ChooseOption.HasOption(UpText) and
     ChooseOption.Select(Action) then
    Exit(True);

  if not MainScreen.IsUpText(UpText) then
    Exit;

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;




// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSWalker.HoverRSObject(RSObject: TRSObject; Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(RSObject.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Self.MakeTileVisible(RSObject.Tiles) then
    Exit(False);

  Result := Self.HoverHelper(RSObject, Attempts);
end;

// Searches for an object with ObjectFinder and HoverRSObject and clicks it if found.
function TRSWalker.ClickRSObject(RSObject: TRSObject; LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSObject(RSObject, Attempts) and
            Self.ClickHelper(RSObject.UpText, LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSWalker.SelectRSObjectOption(RSObject: TRSObject; Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSObject(RSObject, Attempts) and
            Self.SelectHelper(Action, RSObject.UpText);
end;



// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSWalker.WalkHoverRSObject(RSObject: TRSObject; Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(RSObject.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Self.MakeTileVisible(RSObject.Tiles) then
    if not Self.WebWalk(Self.GetClosestTile(RSObject.Tiles), 30, 0.2) then
      Exit(False);

  Result := Self.WalkHoverHelper(RSObject, Attempts);
end;

// Searches for an object with ObjectFinder and WalkHoverRSObject and clicks it if found.
function TRSWalker.WalkClickRSObject(RSObject: TRSObject; LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSObject(RSObject, Attempts) and
            Self.ClickHelper(RSObject.UpText, LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSWalker.WalkSelectRSObjectOption(RSObject: TRSObject; Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSObject(RSObject, Attempts) and
            Self.SelectHelper(Action, RSObject.UpText);
end;



procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  case Map.Lower() of
    'world': WorldObjects.Load(Self);
    'zeah': ZeahObjects.Load(Self);
  end;
end;

procedure TRSWalker.Setup(Map: String; Offset: TPoint; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  if Map.Contains('world') then
    WorldObjects.Load(Self)
  else if Map.Contains('zeah') then
    ZeahObjects.Load(Self);
end;
