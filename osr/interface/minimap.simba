(*
Minimap
=======
Methods to handle Minimap. Extends SRL's Minimap.
*)

{$DEFINE WL_MINIMAP_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
Minimap.WaitMoving
~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSMinimap.WaitMoving(doAntiban: Boolean = True);

Gives **Minimap.WaitPlayerMoving** the ability to perform antiban tasks while moving.

Example
-------

.. code-block:: pascal

  Minimap.WaitMoving;
*)
procedure TRSMinimap.WaitMoving(doAntiban: Boolean = True);
var
  timout, countdown: TCountDown;
  moving: Boolean;
begin
  timout.Init(Round(RandomLeft(20000, 25000)));

  countdown.Init(Round(RandomLeft(500, 1500)));
  countdown.Timeout := GetTickCount() + Round(RandomLeft(2500, 3500));

  repeat
    //Self.CheckRunEnergy();

    if doAntiban then
      Antiban.WalkingTasks();

    moving := Self.IsPlayerMoving();

    if moving then
      countdown.Restart();

  until timout.IsFinished() or countdown.IsFinished() or not Self.HasFlag() or not moving;
end;

(*
Minimap.IsEnvenomed
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.IsEnvenomed();

**Minimap.IsEnvenomed** returns true if we are envenomed.

Example
-------

.. code-block:: pascal

  WriteLn Minimap.IsEnvenomed;
*)
function TRSMinimap.IsEnvenomed(): Boolean;
begin
  Result := SRL.CountColor(CTS0(1515790, 9), Self.GetHPCircle().Bounds()) > 0;
end;

//TODO: ADD TO SRL, the current one doesn't work.
function TRSMinimap.IsPoisoned(): Boolean; override;
begin
  Result := SRL.CountColor(CTS0(16391, 3), Self.GetHPCircle().Bounds()) > 0;
end;

(*
Minimap.HasStamina
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.HasStamina();

**Minimap.HasStamina()** returns true if we are stamina boosted.

Example
-------

.. code-block:: pascal

  WriteLn Minimap.HasStamina();
*)
function TRSMinimap.HasStamina(): Boolean;
begin
  Result := SRL.CountColor(CTS0(2709951, 38), Self.GetRunCircle().Bounds()) > 0;
end;

(*
Minimap.OnGroundLevel
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.OnGroundLevel();

**Minimap.OnGroundLevel** returns true if we are likely to be on the ground level.
This works by counting the amount of black in the minimap and might give false positives/negatives if there's more than 3500 black pixels on the minimap.

Example
-------

.. code-block:: pascal

  WriteLn Minimap.OnGroundLevel();
*)
function TRSMinimap.OnGroundLevel(): Boolean;
var
  p: TPoint;
  tpa, finalTPA: TPointArray;
begin
  if SRL.FindColors(tpa, 0, Self.Bounds()) = 0 then
    Exit(True);

  for p in tpa do
    if PointInPolygon(p, Self.GetPolygon()) then
      finalTPA += p;

  Result := Length(finalTPA) < 3300;
end;


(*
Minimap.InPOH
~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.InPOH(): Boolean;

**Minimap.InPOH** returns true if we are in a POH.
This might give false positives if you are upstairs or in a place with few colors on the minimap.
It might also give false negatives if the POH is crowded.

Example
-------

.. code-block:: pascal

  WriteLn Minimap.InPOH();
*)
function TRSMinimap.InPOH(): Boolean;
var
  tpa: TPointArray;
  colorArray: TIntegerArray;
  blackAmount: Int32;
  colorAmount: Int32;
begin
  tpa := Self.GetPolygon().Connect();
  tpa := tpa.ShapeFill().Erode(10);

  colorArray := GetColors(tpa);
  blackAmount := colorArray.IndicesOf(0).Length();

  colorAmount := Length(colorArray.Unique());
  Result := (colorAmount > 3) and (colorAmount < 25) and (blackAmount < 3500);
end;


(*
Minimap.FindRedArrow
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.FindRedArrow(out TPA: TPointArray): Boolean;
.. pascal:: function TRSMinimap.FindRedArrow: Boolean; overload;

Returns true if there's a red arrow on minimap.
If a TPointArray is passed as a parameter it will return with the location of the arrow.

Example
-------

  Writeln Minimap.FindRedArrow();
*)
function TRSMinimap.FindRedArrow(out tpa: TPointArray): Boolean;
begin
  Result := InRange(SRL.FindColors(tpa, CTS0(255, 0), Self.Bounds()), 1, 84);
end;

function TRSMinimap.FindRedArrow(): Boolean; overload;
begin
  Result := InRange(SRL.CountColor(CTS0(255, 0), Self.Bounds()), 1, 84);
end;

(*
Minimap.FindYellowArrow
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.FindYellowArrow(out TPA: TPointArray): Boolean;
.. pascal:: function TRSMinimap.FindYellowArrow(): Boolean; overload;

Returns true if there's a yellow arrow on minimap.
If a TPointArray is passed as a parameter it will return with the location of the arrow tip.

Example
-------

  Writeln Minimap.FindYellowArrow();
*)
function TRSMinimap.FindYellowArrow(out tpa: TPointArray): Boolean;
begin
  Result := InRange(SRL.FindColors(tpa, CTS0(1767418, 0), Self.Bounds()), 1, 16);
end;

function TRSMinimap.FindYellowArrow(): Boolean; overload;
begin
  Result := InRange(SRL.CountColor(CTS0(1767418, 0), Self.Bounds()), 1, 16);
end;

(*
MainScreen.FindArrow
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMainScreen.FindArrow(out TPA: TPointArray): Boolean;
.. pascal:: function TRSMainScreen.FindArrow(): Boolean; overload;

Returns true if there's a red or yellow arrow on screen.
If a TPointArray is passed as a parameter it will return with the location of the arrow.

Example
-------

  Writeln MainScreen.FindArrow();
*)
function TRSMinimap.FindArrow(out tpa: TPointArray): Boolean;
begin
  Result := Self.FindYellowArrow(tpa) or Self.FindRedArrow(tpa);
end;

function TRSMinimap.FindArrow(): Boolean; overload;
begin
  Result := Self.FindYellowArrow() or Self.FindRedArrow();
end;


(*
Minimap.WaitRedArrow
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.WaitRedArrow(TPA: TPointArray; WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;
.. pascal:: function TRSMinimap.WaitRedArrow(WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;

Waits **WaitTime** for a Red arrow to appear on Minimap.
If a TPointArray is passed as a parameter it will return with the location of the arrow tip.

Example
-------

  Writeln Minimap.WaitRedArrow;
*)
function TRSMinimap.WaitRedArrow(out TPA: TPointArray; WaitTime: Int32 = 120; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindRedArrow(TPA), Interval, WaitTime);
end;

function TRSMinimap.WaitRedArrow(WaitTime: Int32 = 120; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindRedArrow, Interval, WaitTime);
end;

(*
Minimap.WaitYellowArrow
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.WaitYellowArrow(TPA: TPointArray; WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;
.. pascal:: function TRSMinimap.WaitYellowArrow(WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;

Waits **WaitTime** for a yellow arrow to appear on Minimap.
If a TPointArray is passed as a parameter it will return with the location of the arrow tip.

Example
-------

  Writeln Minimap.WaitYellowArrow;
*)
function TRSMinimap.WaitYellowArrow(out TPA: TPointArray; WaitTime: Int32 = 120; Interval: Int32 = -1): Boolean;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindYellowArrow(TPA), Interval, WaitTime);
end;

function TRSMinimap.WaitYellowArrow(WaitTime: Int32 = 120; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindYellowArrow, Interval, WaitTime);
end;

(*
Minimap.WaitArrow
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMinimap.WaitArrow(TPA: TPointArray; WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;
.. pascal:: function TRSMinimap.WaitArrow(WaitTime: Int32 = 600; Interval: Int32 = -1): Boolean;

Waits **WaitTime** for a yellow or red arrow to appear on Minimap.
If a TPointArray is passed as a parameter it will return with the location of the arrow.

Example
-------

  Writeln Minimap.WaitArrow();
*)
function TRSMinimap.WaitArrow(out TPA: TPointArray; waitTime: Int32 = 120; interval: Int32 = -1): Boolean;
begin
  if (interval = -1) then
    interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindArrow(TPA), interval, waitTime);
end;

function TRSMinimap.WaitArrow(waitTime: Int32 = 120; interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 200);

  Result := WaitUntil(Self.FindArrow, interval, waitTime);
end;


function TRSMinimap.HasDotUnder(): Boolean;
var
  TPA: TPointArray;
begin
  if SRL.FindColors(TPA, 65536, Box(Self.Center, 2, 2)) > 0 then
    Result := TPA.Contains([Self.Center.X, Self.Center.Y + 2]);
end;


