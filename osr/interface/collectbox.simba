(*
CollectBox
==========
Methods to interact with the CollectBox.
*)

{$DEFINE WL_COLLECTBOX_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  ERSCollectBoxOperation = enum(
    UNKNOWN,
    BUYING,
    SELLING
  );

  TRSCollectBoxSlot = record
    ItemSlot: TBox;
    ChangeSlot: TBox;
    StatusSlot: TBox;
    OperationSlot: TBox;
  end;

  TRSCollectBox = record(TRSCommonInterface)
  class const
    ELEMENT_SLOTS_AREA:        TRSInterfaceElement = [15, 43, 429, 157];
    ELEMENT_COLLECT_INVENTORY: TRSInterfaceElement = [140, 211, 84, 19];
    ELEMENT_COLLECT_BANK:      TRSInterfaceElement = [235, 211, 84, 19];
  class var
    Slots: array of TRSCollectBoxSlot;
  end;

function TRSCollectBox.Find(item: TRSItem; out Box: TBox): Boolean;
begin
  Result := Self.ItemFinder.Find([item], Box);
end;

function TRSCollectBox.Hover(item: TRSItem): Boolean;
begin
  Result := Self.ItemFinder.Hover(item);
end;

function TRSCollectBox.Click(item: TRSItem): Boolean;
begin
  Result := Self.ItemFinder.Click(item);
end;

function TRSCollectBox.Interact(item: TRSItem; Option: String): Boolean;
begin
  Result := Self.ItemFinder.Interact(item, Option);
end;

function TRSCollectBox.Contains(item: TRSItem): Boolean; overload;
begin
  Result := Self.ItemFinder.Contains(item);
end;

function TRSCollectBox.ContainsAny(items: TRSItemArray): Boolean; overload;
begin
  Result := Self.ItemFinder.ContainsAny(items);
end;

function TRSCollectBox.ContainsAll(items: TRSItemArray): Boolean;
begin
  Result := Self.ItemFinder.ContainsAll(items);
end;

function TRSCollectBox.CountStack(item: TRSItem): Integer;
begin
  Result := Self.ItemFinder.CountStack(item);
end;

function TRSCollectBox.CollectToInventory(): Boolean;
begin
  if Self.GetFullSlots() = [] then
    Exit;

  Self.ElementFinder.Click(Self.ELEMENT_COLLECT_INVENTORY);
  Result := True;
end;

function TRSCollectBox.CollectToBank(): Boolean;
begin
  if Self.GetFullSlots() = [] then
    Exit;

  Self.ElementFinder.Click(Self.ELEMENT_COLLECT_BANK);
  Result := WaitUntil(Self.GetFullSlots() = [], 100, 3000);
end;


(*
CollectBox.IsOpen
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSCollectBox.IsOpen(): Boolean;
.. pascal:: function TRSCollectBox.IsOpen(WaitTime: Int32; Interval: Int32 = -1): Boolean; overload;

Returns true if the collect box screen is open.
*)
function TRSCollectBox.IsOpen(): Boolean;
begin
  Result := Self.IsTitle('Collection Box');
end;

function TRSCollectBox.IsOpen(WaitTime: Int32; Interval: Int32 = -1): Boolean; overload;
begin
  if (Interval = -1) then
    Interval := RandomLeft(50, 1500);

  Result := WaitUntil(Self.IsOpen(), Interval, WaitTime);
end;

function TRSCollectBox.Close(pressEscape: Boolean): Boolean;
begin
  if not Self.IsOpen() then
    Exit(True);

  Result := Self.ClickCloseButton(pressEscape) and WaitUntil(not Self.IsOpen(), RandomLeft(50, 1500), Random(1500, 2000));
end;

function TRSCollectBox.Close(Chance: Double = -1): Boolean; overload;
begin
  Result := MainScreen.CloseInterface(Chance);
end;


(*
CollectBox.FindItemBoundaries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSCollectBox.FindItemBoundaries: TBoxArray;

Finds item boundaries. This is an internal function used to retrieve the boxes we
search for items in.

Example
-------

  Boxes := Self.FindItemBoundaries();
  WriteLn ItemFinder.Find(Item, Boxes);
*)
function TRSCollectBox.FindItemBoundaries(): TBoxArray;
var
  i: Int32;
begin
  for i := 0 to High(Self.Slots) do
    Result += Self.Slots[i].ItemSlot;
end;


function TRSCollectBox.HasItem(slot: Int32): Boolean;
begin
  if not Self.IsOpen() then
    Exit;

  Result := SRL.CountColor(RSColors.ITEM_BORDER, Self.Slots[slot].ItemSlot) > 0;
end;

function TRSCollectBox.GetSlotsWithItems(): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self.Slots) do
    if Self.HasItem(i) then
      Result += i;
end;

function TRSCollectBox.HasChange(slot: Int32): Boolean;
begin
  if not Self.IsOpen() then
    Exit;

  Result := SRL.CountColor(RSColors.ITEM_BORDER, Self.Slots[slot].ChangeSlot) > 0;
end;

function TRSCollectBox.GetSlotsWithChange(): TIntegerArray;
var
  i: Int32;
begin
  for i := 0 to High(Self.Slots) do
    if Self.HasChange(i) then
      Result += i;
end;


function TRSCollectBox.GetFullSlots(): TIntegerArray;
begin
  Result := Self.GetSlotsWithItems() + Self.GetSlotsWithChange();
  Result := Result.Unique().Sorted();
end;


function TRSCollectBox.SetupSlot(b: TBox): TRSCollectBoxSlot;
begin
  Result.ItemSlot := [(b.X1 + 9), (b.Y1 + 31), (b.X1 + 47), (b.Y1 + 65)];
  Result.ChangeSlot := [(b.X1 + 53), (b.Y1 + 31), (b.X1 + 91), (b.Y1 + 65)];
  Result.StatusSlot := [(b.X1 + 8), (b.Y1 + 8), (b.X1 + 48), (b.Y1 + 26)];
  Result.OperationSlot := [(b.X1 + 50), (b.Y1 + 8), (b.X1 + 70), (b.Y1 + 26)];
end;

procedure TRSCollectBox.Setup(Name: String); override;
var
  b: TBox;
  slotBoxes: TBoxArray;
begin
  inherited;

  Self.ItemFinder.Name := Name + '.ItemFinder';
  Self.ItemFinder.GetSearchBoxesFunction := @Self.FindItemBoundaries;

  with Self.BoundsFinder.Alignments[ERSClientMode.FIXED] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -1];

    Center.MaxWidth := 460;
    Center.MaxHeight := 247;
  end;

  with Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC] do
  begin
    Left   := [@InterfaceArea.X1];
    Right  := [@InterfaceArea.X2];
    Top    := [@InterfaceArea.Y1, 2];
    Bottom := [@InterfaceArea.Y2, -2];

    Center.MaxWidth := 460;
    Center.MaxHeight := 247;
  end;

  // Same as above
  Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_MODERN] := Self.BoundsFinder.Alignments[ERSClientMode.RESIZABLE_CLASSIC];

  b := Self.ElementFinder.Bounds(Self.ELEMENT_SLOTS_AREA);
  slotBoxes := TBoxArray.Create([b.X1, b.X2], 4, 2, 100, 74, [10, 10]);

  for b in slotBoxes do
    Self.Slots += Self.SetupSlot(b);
end;


//Extra bank opening methods using TRSObjects
function TRSCollectBox.Hover(rsobject: TRSObject = []): Boolean; overload;
begin
  if rsobject = [] then
    rsobject := RSObjects.Banks.GetClosest();

  Result := rsobject.Hover();
end;

function TRSCollectBox.Open(rsobject: TRSObject = []): Boolean;
begin
  if MainScreen.HasInterface() then
  begin
    if (Self.IsOpen() or BankPin.IsOpen()) then
      Exit(True)
    else
      MainScreen.CloseInterface();
  end;

  if rsobject = [] then
    rsobject := RSObjects.Banks.GetClosest();

  if rsobject.SelectOption(['Collect']) or (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Collect'])) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil((Self.IsOpen() or BankPin.IsOpen()), RandomLeft(50, 1500), 3000);
  end;
end;

function TRSCollectBox.WalkHover(rsobject: TRSObject = []): Boolean;
begin
  if rsobject = [] then
    rsobject := RSObjects.Banks.GetClosest();

  Result := rsobject.WalkHover();
end;

function TRSCollectBox.WalkOpen(rsobject: TRSObject = []): Boolean;
begin
  if MainScreen.HasInterface() then
  begin
    if (Self.IsOpen() or BankPin.IsOpen()) then
      Exit(True)
    else
      MainScreen.CloseInterface();
  end;

  if rsobject = [] then
    rsobject := RSObjects.Banks.GetClosest();

  if rsobject.WalkSelectOption(['Collect']) or (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Collect'])) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil((Self.IsOpen() or BankPin.IsOpen()), RandomLeft(50, 1500), 3000);
  end;
end;


//Extra collectbox opening methods using TRSNPCs
function TRSCollectBox.Hover(npc: TRSNPC): Boolean; overload;
begin
  if npc = [] then
    npc := RSNPCs.Bankers.GetClosest();

  Result := npc.Hover();
end;

function TRSCollectBox.Open(npc: TRSNPC): Boolean; overload;
begin
  if MainScreen.HasInterface() then
  begin
    if (Self.IsOpen() or BankPin.IsOpen()) then
      Exit(True)
    else
      MainScreen.CloseInterface();
  end;

  if npc = [] then
    npc := RSNPCs.Bankers.GetClosest();

  if npc.SelectOption(['Collect']) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil((Self.IsOpen() or BankPin.IsOpen()), RandomLeft(50, 1500), 3000);
  end;
end;

function TRSCollectBox.WalkHover(npc: TRSNPC): Boolean; overload;
begin
  if npc = [] then
    npc := RSNPCs.Bankers.GetClosest();

  Result := npc.WalkHover();
end;

function TRSCollectBox.WalkOpen(npc: TRSNPC): Boolean; overload;
begin
  if MainScreen.HasInterface() then
  begin
    if (Self.IsOpen() or BankPin.IsOpen()) then
      Exit(True)
    else
      MainScreen.CloseInterface();
  end;

  if npc = [] then
    npc := RSNPCs.Bankers.GetClosest();

  if npc.WalkSelectOption(['Collect']) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil((Self.IsOpen() or BankPin.IsOpen()), RandomLeft(50, 1500), 3000);
  end;
end;




var
  CollectBox: TRSCollectBox;

begin
  CollectBox.Setup('CollectBox');
end;

procedure TSRL.Debug(bitmap: TMufasaBitmap); override;
var
  i: Int32;
begin
  if not CollectBox.IsOpen() then
    Exit;

  inherited;

  for i := 0 to High(CollectBox.Slots) do
  begin
    bitmap.DrawBox(CollectBox.Slots[i].StatusSlot, Colors.YELLOW);
    bitmap.DrawBox(CollectBox.Slots[i].OperationSlot, Colors.YELLOW);
    bitmap.DrawBox(CollectBox.Slots[i].ItemSlot, Colors.YELLOW);
    bitmap.DrawBox(CollectBox.Slots[i].ChangeSlot, Colors.YELLOW);
  end;
end;
