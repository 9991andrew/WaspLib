(*
Biometrics
==========
Methods related to biometrics that make your account behave in a unique way.
*)

{$DEFINE WL_BIOMETRICS_INCLUDED}
{$IFNDEF WL_UTILS}
  {$I WaspLib/utils.simba}
{$ENDIF}

(*
Antiban.SetupBiometrics
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TAntiban.SetupBiometrics;

This comes straight from older SRL versions.
This basically sets up our **Login.Players[Login.PlayerIndex].BioHash** which is a hash of the current player login username. Because usernames are unique, so will the Login.Players[Login.PlayerIndex].BioHash.
It also sets up **Endurance** and **Patience** which are also unique to each login username.
*)

type
  EBioBehavior = (
    MOUSE_SPEED,
    MOUSE_GRAVITY,
    MOUSE_WIND,
    MOUSE_MISS,

    FKEY_CHANCE,            //Chance to use FKeys
    ESCAPE_CHANCE,          //Chance to use Escape to close interfaces
    KEYBOARD_CHAT_CHANCE,   //Chance to use to handle chat options with the keyboard.

    REACTION_SPEED,       //Decides how long the player will wait after things like changing tabs, opening choose options menu, etc.
    SPAM_CLICK_CHANCE,    //Chance to spam click things (walking, eating, etc).
    DROP_PATTERN,
    CONSUME_IN_BANK,
    ADAPTIVE_WALK
  );


function TAntiban.GetBehavior(behavior: EBioBehavior): Int32;
begin
  if Login.PlayerIndex > Length(Login.Players) then
    Exit;
  Result := GetDigit(Login.Players[Login.PlayerIndex].BioHash, Ord(behavior) + 1); //+1 because all BioHashes start with "0."
end;

function TAntiban.GetChance(behavior: EBioBehavior): Double;
var
  hash: Double;
begin
  if Login.PlayerIndex > High(Login.Players) then
    Exit;
  hash := Login.Players[Login.PlayerIndex].BioHash;
  Result := (GetDigit(hash, Ord(behavior) + 1) * 10 + GetDigit(hash, Ord(behavior) + 2)) / 100;
end;


(*
Antiban.GetInfluencer
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TAntiban.GetInfluencer: Extended;

This generates a random number that is influenced by Login.Players[Login.PlayerIndex].BioHash.
There are times you will not want to use Login.Players[Login.PlayerIndex].BioHash itself because it's value is static, this function let's you get a number that is random but heavily influenced by Login.Players[Login.PlayerIndex].BioHash.

Example
-------

  Wait(Round(3000 * Antiban.GetInfluencer)));
*)
function TAntiban.GetInfluencer(): Extended;
var
  hash: Double;
begin
  if Login.PlayerIndex > High(Login.Players) then
    Exit;
  hash := Login.Players[Login.PlayerIndex].BioHash;
  Result := (Random() + hash) * hash * hash;
end;

(*
Antiban.GetUniqueNumber
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TAntiban.GetUniqueNumber(Input: Extended): Extended;
  function TAntiban.GetUniqueNumber(Input, Sum: Extended): Extended; overload;
  function TAntiban.GetUniqueNumber(Input, Min, Max: Extended): Extended; overload;

This generates a unique number based on your **Input**.
The overloaded functions allow you to use some extra parameters for this like:
  Sum an amount to the result, so **Sum** will always be the minimum value you get.
  Min and Max cap. The number generated will be between **Min** and **Max**.

Example
-------

  FoodAmount := Antiban.GetUniqueNumber(7, 3, 15);
*)
function TAntiban.GetUniqueNumber(input: Extended): Extended;
begin
  Result := input * Self.GetInfluencer();
end;

function TAntiban.GetUniqueNumber(input, sum: Extended): Extended; overload;
begin
  Result := Self.GetUniqueNumber(input) + sum;
end;

function TAntiban.GetUniqueNumber(input, min, max: Extended): Extended; overload;
begin
  Result := input * Self.GetInfluencer();

  if Result < min then
    Result := min
  else if Result > max then
    Result := max;
end;


(*
Antiban.GetUniqueAverage
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
  function TAntiban.GetUniqueAverage(input: Extended; Iterations: Integer): Extended;
  function TAntiban.GetUniqueAverage(input, sum: Extended; Iterations: Integer): Extended; overload;
  function TAntiban.GetUniqueAverage(input, min, max: Extended; Iterations: Integer): Extended; overload;

Functions to test **Antiban.GetUniqueNumber**.
It will run Antiban.GetUniqueNumber for how many **Iterations** you specify and average the results out.
Useful to know more or less what result to expect from your input.

Example
-------

  WriteLn Antiban.GetUniqueAverage(7, 3, 15, 500);
*)
function TAntiban.GetUniqueAverage(input: Extended; Iterations: Integer): Extended;
var
  randomCases: TExtendedArray;
begin
  for 1 to Iterations do
    randomCases += Self.GetUniqueNumber(input);

  Result := randomCases.Mean();
end;

function TAntiban.GetUniqueAverage(input, sum, Iterations: Integer): Extended; overload;
var
  randomCases: TExtendedArray;
begin
  for 1 to Iterations do
    randomCases += Self.GetUniqueNumber(input, sum);

  Result := randomCases.Mean();
end;

function TAntiban.GetUniqueAverage(input, min, max, Iterations: Integer): Extended; overload;
var
  randomCases: TExtendedArray;
begin
  for 1 to Iterations do
    randomCases += Self.GetUniqueNumber(input, min, max);

  Result := randomCases.Mean();
end;


(*
Antiban.BioDice()
~~~~~~~~~~~~~~~
.. pascal:: function TAntiban.BioDice(): Boolean;

Throws a **SRL.Dice** heavily skewed in certain directions depending on your TRSPlayer.BioHash.
BioHashes smaller than **0.15** will always return **False**.
BioHashes bigger than **0.80** will always return **True**.
BioHashes between 0.15 and 0.80 will randomly return True or False with true being more probable for higher BioHashes.

Example
-------

  UseBankEarly := Antiban.BioDice();
*)
function TAntiban.BioDice(): Boolean;
begin
  case Login.Players[Login.PlayerIndex].BioHash of
    0.00..0.15: Result := False;
    0.15..0.50: Result := SRL.Dice(Login.Players[Login.PlayerIndex].BioHash * 90);
    0.50..0.80: Result := SRL.Dice(Login.Players[Login.PlayerIndex].BioHash * 110);
    else        Result := True;
  end;
end;

function TAntiban.BioDice(behaviour: EBioBehavior): Boolean; overload;
var
  chance: Double := Self.GetChance(behaviour);
begin
  case Chance of
    0.0..0.2: Result := False;
    0.2..0.5: Result := SRL.Dice(chance * 90);
    0.5..0.8: Result := SRL.Dice(chance * 110);
    else      Result := True;
  end;
end;

function TAntiban.BioDice(chance: Double): Boolean; overload;
begin

  Result := SRL.Dice(EnsureRange(chance * Login.Players[Login.PlayerIndex].BioHash + (chance * 1.7), 0, 100));
end;

(*
Antiban.InvertedBioDice
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TAntiban.InvertedBioDice: Boolean;

Inverted **Antiban.BioDice()**.
*)
function TAntiban.InvertedBioDice(): Boolean;
begin
  Result := not Self.BioDice();
end;

function TAntiban.InvertedBioDice(Behaviour: EBioBehavior): Boolean; overload;
begin
  Result := not Self.BioDice(Behaviour);
end;


procedure TAntiban.SetSleepHour();
var
  Sleep: UInt64;
begin
  if WLSettings.Sleep.HourOverride <> '' then
  begin
    WLSettings.Sleep.Hour := WLSettings.Sleep.HourOverride;
    Exit;
  end;

  Sleep := (((22 + Round(5 * Login.Players[Login.PlayerIndex].BioHash)) * ONE_HOUR) +
           (Round(59 * Login.Players[Login.PlayerIndex].BioHash) * ONE_MINUTE));

  if Sleep > ONE_DAY then
    Sleep -= ONE_DAY;

  WLSettings.Sleep.Hour := SRL.MsToTime(Sleep, Time_Bare);
end;

procedure TAntiban.SetSleepLength();
begin
  if WLSettings.Sleep.LengthOverride > 0 then
  begin
    WLSettings.Sleep.Length := WLSettings.Sleep.LengthOverride * ONE_HOUR;
    Exit;
  end;

  WLSettings.Sleep.Length := (5 * ONE_HOUR) + ((200 * ONE_MINUTE) * Login.Players[Login.PlayerIndex].BioHash);
end;

procedure BioWait(time: UInt32);
begin
  Wait(Round(time * Login.Players[Login.PlayerIndex].BioHash));
end;

procedure BioWait(min, max: UInt32; weight:EWaitDir=wdMean); overload;
var
  hash: Double;
begin
  hash := Login.Players[Login.PlayerIndex].BioHash;
  Wait(Round(min*hash), Round(max*hash), weight);
end;
