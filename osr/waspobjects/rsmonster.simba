(*
RSMonters
=========
Methods to handle TRSMonters.
TRSMonters are a type or TRSNPC that can be fought.
*)

{$DEFINE WL_RSMONSTER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

var
  ValueThreshold: Int32;

type
  TRSMonster = record(TRSMMDot)
    MonsterName: String;
    Hitpoints: Int32;
    MaxHit: Int32;
    AttackTypes: array of ERSMonsterAttackType;
    Drops: array of TRSMonsterDrop;
    GoodDrops: TRSItemArray;
    LootGItem: TRSGroundItem;
  end;

  TRSMonsterArray = array of TRSMonster;
  PRSMonster = ^TRSMonster;
  PRSMonsterArray = array of PRSMonster;

procedure TRSMonster.SetupCommon(Name: String); overload;
var
  i, Size: Int32;
begin
  MonsterName := Name;

  Self.SetupCommon;

  Name := Name.Lower;
  Name[1] := UpperCase(Name[1])[1];

  UpText += Name;

  Hitpoints := MonsterData.GetInt(Name, 'hitpoints');
  MaxHit := MonsterData.GetInt(Name, 'max_hit');
  Size := MonsterData.GetInt(Name, 'size');
  if Size = 1 then
    ShapeArray := [[[], [1, 1, 0]]]
  else
    ShapeArray := [[[], [Size/2, Size/2, 0]]];
  AttackTypes := MonsterData.GetAttackTypes(Name);

  ValueThreshold := 10000;

  Drops := MonsterData.GetDrops(Name);

  for i := 0 to High(Drops) do
  begin
    if Drops[i].Noted then
      GoodDrops += Drops[i].Item
    else if (ItemData.GetHighAlchProfit(Drops[i].ID) > 500) then
    begin
      if RSAction.AlchItemArray.Find(Drops[i].Item) < 0 then
        RSAction.AlchItemArray += Drops[i].Item;
      GoodDrops += Drops[i].Item;
    end
    else if ItemData.GetAverage(Drops[i].ID) >= ValueThreshold then
      GoodDrops += Drops[i].Item;
  end;

  LootGItem.SetupCommon;
  LootGItem.Filter.Finder := False;

  for i := 0 to High(GoodDrops) do
    LootGItem.UpText += ToStr(GoodDrops[i]);
end;

procedure TRSMonster.ResetGoodDrops;
var
  i: Int32;
begin
  GoodDrops := [];
  LootGItem := [];
  Drops := MonsterData.GetDrops(MonsterName);

  for i := 0 to High(Drops) do
  begin
    if Drops[i].Noted then
      GoodDrops += Drops[i].Item
    else if (ItemData.GetHighAlchProfit(Drops[i].ID) > 500) then
    begin
      if RSAction.AlchItemArray.Find(Drops[i].Item) < 0 then
        RSAction.AlchItemArray += Drops[i].Item;
      GoodDrops += Drops[i].Item;
    end
    else if ItemData.GetAverage(Drops[i].ID) >= ValueThreshold then
      GoodDrops += Drops[i].Item;
  end;

  LootGItem.SetupCommon;
  LootGItem.Filter.Finder := False;

  for i := 0 to High(GoodDrops) do
    LootGItem.UpText += ToStr(GoodDrops[i]);
end;


function TRSMonster._HandleLooting: Boolean;
var
  Str: String;
begin
  if not MainScreen.IsUpText('Take') then
    Exit;

  ChooseOption.Open;
  if not ChooseOption.HasOption(LootGItem.UpText) then
    Exit;

  for Str in LootGItem.UpText do
  begin
    if Inventory.IsFull then
    begin
      if (not Str.Contains('noted') or not Inventory.FindItem(Str)) then
        Continue;
      //TODO! EAT OR DROP SOMETHING!
    end;

    ChooseOption.Select(Str.After('noted '));
  end;
end;

function TRSMonster.CheckLoot(P: TPoint): Boolean;
begin
  Mouse.Move(P);

  Result := Self._HandleLooting;
end;

function TRSMonster.CheckLoot(B: TBox): Boolean; overload;
begin
  Mouse.Move(P);

  Result := Self._HandleLooting;
end;
