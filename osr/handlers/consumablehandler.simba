(*
ConsumableHandlers and Managers
===============================
*)

{$DEFINE WL_CONSUMABLEHANDLER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
(*
type TConsumableHandler
~~~~~~~~~~~~~~~~~~~~~~~

Consumable handler is the record responsible to handle `TRSConsumables <https://torwent.github.io/WaspLib/consumables.html>`_.
This will handle caching all found consumables to this point, bank withdraw amounts, timer if the last consumable had a timer, etc.
*)
  TConsumableHandler = record(TSRLBaseRecord)
    ConsumableType: ERSConsumable;
    ConsumableArray: TRSConsumableArray;

    Amount: Int32;
    MinInvPoints: Int32;

    Timer: TCountDown;
    ConsumableDelay: TCountDown;

    IsSetup: Boolean;
  end;

(*
type PConsumableHandler
~~~~~~~~~~~~~~~~~~~~~~~

Wrapper type of a TConsumableHandler pointer.
*)
  PConsumableHandler = ^TConsumableHandler;

(*
ConsumableHandler.Setup()
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.Setup(Item: TRSItem): TRSConsumable;

Used internally to add a TRSConumable to TConsumableHandler.ConsumableArray.

Example
-------

  FoodHandler.Setup('Shark');
*)
function TConsumableHandler.Setup(Item: TRSItem): TRSConsumable;
begin
  Result.Item := Item;

  case Self.ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Result.SetupFood;
    ERSConsumable.PRAYER_CONSUMABLE:    Result.SetupPrayer;
    ERSConsumable.ENERGY_CONSUMABLE:    Result.SetupEnergy;
    ERSConsumable.POISON_CONSUMABLE:    Result.SetupAntiPoison;
    ERSConsumable.VENOM_CONSUMABLE:     Result.SetupAntiVenom;
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Result.SetupAntiFire;
    ERSConsumable.BOOST_CONSUMABLE:     Result.SetupBoost;
  end;
end;

(*
ConsumableHandler.FindInBank()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.FindInBank(): TRSConsumableArray;

Returns an TRSConsumableArray of all TRSConsumables of **TConsumableHandler.ConsumableType** found in the bank window.
*)
function TConsumableHandler.FindInBank(): TRSConsumableArray;
var
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  Self.DebugLn('Setting up consumable of type: ' + ToStr(Self.ConsumableType));

  for Item in GetConsumableArray(Self.ConsumableType) do
  begin
    if Self.ConsumableArray.Contains(Item) then //avoid resetting items.
      Continue;

    if Bank.ContainsItem(Item.Reorder(False)) then
    begin
      Self.DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self.Setup(Item);
      Consumable.BankTab := Bank.GetCurrentTab(); //TODO: Search parent maybe?

      Result += Consumable;
    end;
  end;
end;

(*
ConsumableHandler.FindInInventory()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.FindInInventory(): TRSConsumableArray;

Returns an TRSConsumableArray of all TRSConsumables of **TConsumableHandler.ConsumableType** found in the inventory.
*)
function TConsumableHandler.FindInInventory(): TRSConsumableArray;
var
  Consumable: TRSConsumable;
  Item: TRSItem;
begin
  Self.DebugLn('Setting up consumable of type: ' + ToStr(Self.ConsumableType));

  for Item in GetConsumableArray(Self.ConsumableType) do
  begin
    if Self.ConsumableArray.Contains(Item) then //avoid resetting leftover items.
      Continue;

    if Inventory.ContainsItem(Item) then
    begin
      Self.DebugLn('Consumable found: ' + ToStr(Item));
      Consumable := Self.Setup(Item);

      Result += Consumable;
    end;
  end;
end;

(*
ConsumableHandler.NeedToConsume()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TConsumableHandler.NeedToConsume(): Boolean;

Returns an **True** if there's a timer setup and it has ran out.
*)
function TConsumableHandler.NeedToConsume(): Boolean;
begin
  if not Self.IsSetup then
    Exit;

  Result := ((Self.Timer.Length > 0) and Self.Timer.IsFinished())
            or Self.Timer.IsPaused();
end;

(*
ConsumableHandler.Setup()
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TConsumableHandler.Setup(ConsumableType: ERSConsumable); overload;

Overloaded function used to setup TConsumableHandler.ConsumableArray by TConsumableHandler.ConsumableType.
This will use TConsumableHandler.FindInInventory() or TConsumableHandler.FindInBank() by that order to setup
found TRSConsumables.
*)
procedure TConsumableHandler.Setup(ConsumableType: ERSConsumable); overload;
begin
  if Self.IsSetup then
    Exit;

  Self.ConsumableType := ConsumableType;

  case Self.ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Self.Name := 'FoodHandler';
    ERSConsumable.PRAYER_CONSUMABLE:    Self.Name := 'PrayerHandler';
    ERSConsumable.ENERGY_CONSUMABLE:    Self.Name := 'EnergyHandler';
    ERSConsumable.POISON_CONSUMABLE:    Self.Name := 'PoisonHandler';
    ERSConsumable.VENOM_CONSUMABLE:     Self.Name := 'VenomHandler';
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Self.Name := 'AntiFireHandler';
    ERSConsumable.BOOST_CONSUMABLE:     Self.Name := 'BoostHandler';
  end;

  if Inventory.Open() then
    Self.ConsumableArray := Self.FindInInventory();

  if (Self.ConsumableArray = []) and Bank.IsOpen() then
    Self.ConsumableArray := Self.FindInBank();

  Self.IsSetup := Self.ConsumableArray <> [];

  if Self.IsSetup and (Self.ConsumableArray[0].Timer > 0) then
    Self.Timer.Setup(Self.ConsumableArray[0].Timer);
end;

var
(*
var FoodHandler
~~~~~~~~~~~~~~~

Global FoodHandler variable. This handler is the one responsible for handling FOOD_CONSUMABLE.

var PrayerHandler
~~~~~~~~~~~~~~~~~

Global PrayerHandler variable. This handler is the one responsible for handling PRAYER_CONSUMABLE.

var EnergyHandler
~~~~~~~~~~~~~~~~~

Global EnergyHandler variable. This handler is the one responsible for handling ENERGY_CONSUMABLE.

var PoisonHandler
~~~~~~~~~~~~~~~~~

Global PoisonHandler variable. This handler is the one responsible for handling POISON_CONSUMABLE.

var VenomHandler
~~~~~~~~~~~~~~~~

Global VenomHandler variable. This handler is the one responsible for handling VENOM_CONSUMABLE.

var AntifireHandler
~~~~~~~~~~~~~~~~~~~

Global AntifireHandler variable. This handler is the one responsible for handling ANTI_FIRE_CONSUMABLE.

var BoostHandler
~~~~~~~~~~~~~~~~

Global BoostHandler variable. This handler is the one responsible for handling BOOST_CONSUMABLE.
*)
  FoodHandler: TConsumableHandler;
  PrayerHandler: TConsumableHandler;
  EnergyHandler: TConsumableHandler;
  PoisonHandler: TConsumableHandler;
  VenomHandler: TConsumableHandler;
  AntifireHandler: TConsumableHandler;
  BoostHandler: TConsumableHandler;

(*
GetHandler()
~~~~~~~~~~~~
.. pascal:: function GetHandler(ConsumableType: ERSConsumable): PConsumableHandler;

Method to return a pointer to the right handler for each ConsumableType passed in.
*)
function GetHandler(ConsumableType: ERSConsumable): PConsumableHandler;
begin
  case ConsumableType of
    ERSConsumable.FOOD_CONSUMABLE:      Result := @FoodHandler;
    ERSConsumable.PRAYER_CONSUMABLE:    Result := @PrayerHandler;
    ERSConsumable.ENERGY_CONSUMABLE:    Result := @EnergyHandler;
    ERSConsumable.POISON_CONSUMABLE:    Result := @PoisonHandler;
    ERSConsumable.VENOM_CONSUMABLE:     Result := @VenomHandler;
    ERSConsumable.ANTI_FIRE_CONSUMABLE: Result := @AntifireHandler;
    ERSConsumable.BOOST_CONSUMABLE:     Result := @BoostHandler;
  end;

  Result^.Setup(ConsumableType);
end;

(*
Inventory.FindItems()
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.FindItems(Items: TRSConsumableArray; out FoundItems: TRSConsumableArray; out Slots: TIntegerArray): Boolean; overload;

Overloaded method used to find consumables in the inventory. Can be used directly but in most cases is used internally.
*)
function TRSInventory.FindItems(consumables: TRSConsumableArray; out foundConsumable: TRSConsumableArray): TIntegerArray; overload;
var
  singleItem: TRSItem;
  consumable: TRSConsumable;
  currentSearch: TIntegerArray;
begin
  if not Self.Open() then
    Exit;

  for consumable in consumables do
  begin
    for singleItem in consumable.Item.GetArray() do
    begin
      currentSearch := Self.ItemFinder.IndicesOf([singleItem]);
      if currentSearch <> [] then
      begin
        foundConsumable += consumable;
        Result += currentSearch;
      end;
    end;
  end;

  Result := Result.Unique();
end;

function TRSInventory.ContainsItem(consumables: TRSConsumableArray): Boolean; overload;
var
  singleItem: TRSItem;
  consumable: TRSConsumable;
  currentSearch: TIntegerArray;
begin
  if not Self.Open() then
    Exit;

  for consumable in consumables do
  begin
    for singleItem in consumable.Item.GetArray() do
    begin
      currentSearch := Self.ItemFinder.IndicesOf([singleItem]);
      if currentSearch <> [] then
        Exit(True);
    end;
  end;
end;

(*
Inventory.FindConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.FindConsumable(ConsumableType: ERSConsumable; out FoundConsumables: TRSConsumableArray; out Slots: TIntegerArray): Boolean;
.. pascal:: function TRSInventory.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;

Method used to find already setup consumables in the inventory. Can be used directly but in most cases is used internally.
*)
function TRSInventory.FindConsumable(ConsumableType: ERSConsumable; out foundConsumables: TRSConsumableArray): TIntegerArray;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindItems(ConsumableHandler^.ConsumableArray.Reversed, foundConsumables);
end;

function TRSInventory.FindConsumable(ConsumableType: ERSConsumable): TIntegerArray; overload;
var
  foundItems: TRSConsumableArray;
begin
  Result := Self.FindConsumable(ConsumableType, foundItems);
end;


function TRSInventory.ContainsConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.ContainsItem(ConsumableHandler^.ConsumableArray.Reversed);
end;


(*
Inventory.Consume()
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.Consume(ConsumableType: ERSConsumable; out Slots: TIntegerArray): Boolean;
.. pascal:: function TRSInventory.Consume(ConsumableType: ERSConsumable): Boolean; overload;

Methods used to consume consumables.

Example
-------

  Inventory.Consume(FOOD_CONSUMABLE);
*)
function TRSInventory.Consume(consumableType: ERSConsumable; out slots: TIntegerArray): Boolean;
var
  consumableHandler: PConsumableHandler := GetHandler(consumableType);
  foundConsumables: TRSConsumableArray;
  startingPoints: Int32;
  trashSlots: TIntegerArray;
begin
  if not consumableHandler^.IsSetup then
    Exit;

  case consumableType of
    ERSConsumable.FOOD_CONSUMABLE:
      startingPoints := Minimap.GetHPLevel();

    ERSConsumable.PRAYER_CONSUMABLE:
      startingPoints := Minimap.GetPrayerLevel();

    ERSConsumable.ENERGY_CONSUMABLE:
      startingPoints := Minimap.GetRunEnergy();
  end;

  slots := Self.FindConsumable(consumableType, foundConsumables)

  if slots.Length() = 0 then
    Exit;

  if not Antiban.BioDice(EBioBehavior.CONSUME_IN_BANK) and
     MainScreen.HasInterface() then
     MainScreen.CloseInterface;

  if (consumableHandler^.ConsumableDelay.Length > 0) then
    while not consumableHandler^.ConsumableDelay.IsFinished() do
      Wait(50, 100);

  Result := Self.ClickSlot(slots[0], ['Eat', 'Drink']);

  if Result then
    case consumableType of
      ERSConsumable.FOOD_CONSUMABLE:
        Result := WaitUntil(startingPoints < Minimap.GetHPLevel(), 100, 3000);

      ERSConsumable.PRAYER_CONSUMABLE:
        Result := WaitUntil(startingPoints < Minimap.GetPrayerLevel(), 100, 3000);

      ERSConsumable.ENERGY_CONSUMABLE:
        Result := WaitUntil(startingPoints < Minimap.GetRunEnergy(), 100, 3000);
      else
        BioWait(1000, 2000, wdLeft);
    end;

  if Result then
  begin
    case consumableType of
      ERSConsumable.FOOD_CONSUMABLE:
        begin
          if foundConsumables.First().Item = 'Cooked karambwan' then
            consumableHandler^.ConsumableDelay.Init(1200)
          else
            consumableHandler^.ConsumableDelay.Init(1800);
        end;
      else
        consumableHandler^.ConsumableDelay.Init(600);
    end;

    if foundConsumables[0].Timer > 0 then
    begin
      if consumableHandler^.Timer.Length <> foundConsumables[0].Timer then
        consumableHandler^.Timer.Setup(foundConsumables[0].Timer);

      if consumableType = ERSConsumable.ANTI_FIRE_CONSUMABLE then
        consumableHandler^.Timer.Restart(Random(-50000, -20000))
      else
        consumableHandler^.Timer.Restart(Random(-3000, 3000));
    end;

    TotalConsumableCost += foundConsumables[0].Cost;

    trashSlots := Self.FindItems(TRASH_ARRAY);

    if trashSlots.Length() > 0 then
    begin
      if Bank.IsOpen() then
        Bank.DepositSlot([trashSlots[0], BANK_DEPOSIT_ALL], False)
      else
        Self.ShiftDrop(trashSlots.Intersection(Self.RandomPattern()));

      slots := slots.Difference(trashSlots); //Delete trashSlots from slots.
    end;
  end;
end;

function TRSInventory.Consume(ConsumableType: ERSConsumable): Boolean; overload;
var
  Slots: TIntegerArray;
begin
  Result := Self.Consume(ConsumableType, Slots);
end;


(*
Inventory.CountConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.CountConsumable(ConsumableType: ERSConsumable): Int32;

Method used to count each slot that has a consumable of **ConsumableType**.

Example
-------

  WriteLn Inventory.CountConsumable(FOOD_CONSUMABLE);
*)
function TRSInventory.CountConsumable(consumableType: ERSConsumable): Int32;
var
  foundConsumables: TRSConsumableArray;
begin
  Result := Length(Self.FindConsumable(consumableType, foundConsumables));
end;

(*
Inventory.CountEachConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.CountEachConsumable(ConsumableType: ERSConsumable): TIntegerArray;

Method used to count each type of consumable of **ConsumableType**.

Example
-------

  WriteLn Inventory.CountEachConsumable(FOOD_CONSUMABLE);
*)
function TRSInventory.CountEachConsumable(ConsumableType: ERSConsumable): TIntegerArray;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Item: TRSConsumable;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  for Item in ConsumableHandler^.ConsumableArray do
    Result += Self.CountItem(Item.Item);
end;

(*
Inventory.CountPoints()
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.CountPoints(Consumable: TRSConsumable): Int32;
.. pascal:: function TRSInventory.CountPoints(ConsumableType: ERSConsumable): Int32; overload;

Method used to count the total points value of a **Consumable** or **ConsumableType**.

Example
-------

  WriteLn Inventory.CountPoints(FOOD_CONSUMABLE); //Assumind you have 3 sharks in your inventory, 60 will be printed.
*)
function TRSInventory.CountPoints(Consumable: TRSConsumable): Int32;
var
  i: Int32;
  Items: TRSItemArray;
begin
  Items := Consumable.Item.GetArray();

  for i := 0 to High(Items) do
    Result += Self.CountItem(Items[i]) * Consumable.Points * (i + 1);
end;

function TRSInventory.CountPoints(ConsumableType: ERSConsumable): Int32; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Consumable: TRSConsumable;
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  for Consumable in ConsumableHandler^.ConsumableArray do
    Result += Self.CountPoints(Consumable);
end;

(*
Inventory.HasEnoughConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean;

Method used to figure out if we are low on a type of consumable.

Example
-------

  if not Inventory.HasEnoughConsumable(FOOD_CONSUMABLE) then
    Bank.WithdrawItem(['Shark', 5, False], False);
*)
function TRSInventory.HasEnoughConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  Result := Self.CountPoints(ConsumableType) >= ConsumableHandler^.MinInvPoints;
end;


(*
Bank.FindConsumable()
~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray; out Consumable: TRSConsumable): Boolean;
.. pascal:: function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray): Boolean; overload;
.. pascal:: function TRSBank.FindConsumable(ConsumableType: ERSConsumable; out Consumable: TRSConsumable): Boolean; overload;
.. pascal:: function TRSBank.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;

Method used to find already setup consumables in the bank. Can be used directly but in most cases is used internally.

Example
-------

  WriteLn Bank.FindConsumable(FOOD_CONSUMABLE);
*)
function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray; out Consumable: TRSConsumable): Boolean;
begin
  for Consumable in ConsumableArray do
    if Self.ContainsItem(Consumable.Item) then
      Exit(True);
end;

function TRSBank.FindConsumable(ConsumableArray: TRSConsumableArray): Boolean; overload;
var
  Consumable: TRSConsumable;
begin
  Result := Self.FindConsumable(ConsumableArray, Consumable);
end;

function TRSBank.FindConsumable(ConsumableType: ERSConsumable; out Consumable: TRSConsumable): Boolean; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindConsumable(ConsumableHandler^.ConsumableArray, Consumable);
end;

function TRSBank.FindConsumable(ConsumableType: ERSConsumable): Boolean; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
  if not ConsumableHandler^.IsSetup then
    Exit;

  Result := Self.FindConsumable(ConsumableHandler^.ConsumableArray);
end;


(*
Bank.CountPoints()
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.CountPoints(Consumable: TRSConsumable): Int32;

Method used to count the points of the first dose/portion of a consumable found in bank.
This prioritizes higher dosage visible ones first and returns only just that one.
*)
function TRSBank.CountPoints(Consumable: TRSConsumable): Int32;
var
  i: Int32;
  Items: TRSItemArray;
begin
  Items := Consumable.Item.Reorder(False).GetArray();

  for i := 0 to High(Items) do
    if Self.ContainsItem(Items[i]) then
      Exit(Consumable.Points * Items[i].GetPortion());
end;

(*
Bank.WithdrawConsumableAmount()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable): Int32;
.. pascal:: function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Consumable: TRSConsumable): Int32; overload;

Method used to return the amount we need to withdraw to meet the TRSConsumable.MinInvPoints.
*)
function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable): Int32;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  Consumable: TRSConsumable;
begin
  for Consumable in ConsumableHandler^.ConsumableArray do
  begin
    case ConsumableHandler^.Amount of
      BANK_WITHDRAW_ALL:         Result := BANK_WITHDRAW_ALL;
      BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
      0: Result := Ceil((ConsumableHandler^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / Self.CountPoints(Consumable));
      else Result := ConsumableHandler^.Amount;
    end;

    if Result > 0 then
      Exit;
  end;
end;

function TRSBank.WithdrawConsumableAmount(ConsumableType: ERSConsumable; Consumable: TRSConsumable): Int32; overload;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
begin
    case ConsumableHandler^.Amount of
      BANK_WITHDRAW_ALL: Result := BANK_WITHDRAW_ALL;
      BANK_WITHDRAW_ALL_BUT_ONE: Result := BANK_WITHDRAW_ALL_BUT_ONE;
      0: Result := Ceil((ConsumableHandler^.MinInvPoints - Inventory.CountPoints(ConsumableType)) / Self.CountPoints(Consumable));
      else Result := ConsumableHandler^.Amount;
    end;
end;

(*
Bank.WithdrawConsumable()
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSBank.WithdrawConsumable(ConsumableType: ERSConsumable): Boolean;

Method used to withdraw a consumable type.

Example
-------

  FoodHandler.MinInvPoints := 100;

  Bank.WithdrawConsumable(FOOD_CONSUMABLE); //This will withdraw FOOD_CONSUMABLEs until we have 100 points value of food in our inventory.
*)
function TRSBank.WithdrawConsumable(ConsumableType: ERSConsumable): Boolean;
var
  ConsumableHandler: PConsumableHandler := GetHandler(ConsumableType);
  WithdrawAmount: Int32;
  Consumable: TRSConsumable;
begin
  if not Self.FindConsumable(ConsumableType, Consumable) then
  begin
    if not ConsumableHandler^.IsSetup then
      Exit;

    if ConsumableHandler^.ConsumableArray[0].BankTab < 0 then
      ConsumableHandler^.ConsumableArray[0].BankTab := Self.FindItemTab(Consumable.Item)
    else
      Self.OpenTab(ConsumableHandler^.ConsumableArray[0].BankTab);

    if not Self.FindConsumable(ConsumableType, Consumable) then
      Exit;
  end;

  WithdrawAmount := Self.WithdrawConsumableAmount(ConsumableType, Consumable);

  if WithdrawAmount <= 0 then
    Exit(True); //We have enough food.

  Self.WithdrawItem(Consumable.BankTab, [Consumable.Item, WithdrawAmount, False], False);

  Result := WaitUntil(Inventory.HasEnoughConsumable(ConsumableType), 100, 3000);
end;

//overrides
procedure TConsumablePanel.Init();
var
  i: Int32;
begin
  if not Self.IsSetup then
    Exit;

  i := Self.ConsumableSelector.GetItemIndex();

  if i > -1 then
    case Self.ConsumableType of
      FOOD_CONSUMABLE: FoodHandler.Setup(FOOD_ARRAY[i]);
      PRAYER_CONSUMABLE: PrayerHandler.Setup(PRAYER_ARRAY[i]);
      ENERGY_CONSUMABLE: EnergyHandler.Setup(ENERGY_ARRAY[i]);
      BOOST_CONSUMABLE:  BoostHandler.Setup(BOOST_ARRAY[i]);
    end;
end;

procedure TScriptForm.Init(Sender: TObject); override;
begin
  //override me to add stuff!
  Self.WLPanel.FoodPanel.Init();
  Self.WLPanel.PrayerPanel.Init();
  inherited;
end;

