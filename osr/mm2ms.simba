{$DEFINE WL_MM2MS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

procedure TMM2MS.SetupZoom;
begin
  if (Self.ZoomLevel = -1) then
  begin
    Self.DebugLn('Unknown zoom level, reading from options...');
    Self.ZoomLevel := Options.GetZoomLevel();
    Self.DebugLn('Current zoom level: ' + ToString(Self.ZoomLevel));
  end;
end;

function Minimap.ZoomRadius: Int32;
begin
  if MM2MS.ZoomLevel = -1 then
    MM2MS.ZoomLevel := Options.GetZoomLevel;

  Result := Round(73 - (0.8 * (MM2MS.ZoomLevel + 25)));
end;

function Minimap.PointInZoomRadius(Pt: TPoint): Boolean;
var
  Radius: Int32;
begin
  Radius := Self.ZoomRadius;
  Result := Pt.InCircle([Minimap.Center.X, Minimap.Center.Y, Radius]);
end;

function Minimap.ZoomToPoint(Pt: TPoint): Int32;
var
  Distance: Int32;
begin
  Distance := Round(Pt.DistanceTo(Minimap.Center));

  //- Random(5, 10) to give it some margin
  Result := Round((73 - Distance) / 0.8) - Random(25, 30);
end;

//overloaded for multiple tiles. For one tile Expand should be 1.
function TRSMinimap.VecToMsRect(Vec: Vector3; Expand: Int32; Roll:Single=$FFFF): TRectangle; overload;
var
  arr: TPointArray;
  Size: Int32;
begin
  if Expand = 0 then
    Expand := 1;

  Size := 2 * Expand;

  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);

  Arr := MM2MS.Run([Vec3(Vec.x-Size, Vec.y-Size, Vec.z),
                    Vec3(Vec.x+Size, Vec.y-Size, Vec.z),
                    Vec3(Vec.x+Size, Vec.y+Size, Vec.z),
                    Vec3(Vec.x-Size, Vec.y+Size, Vec.z)], Roll);

  Result := [Arr[0], Arr[1], Arr[2], Arr[3]];
end;

function TRSMinimap.VecToMsRect(Vec: Vector3; ExpandV, ExpandH: Int32; Roll:Single=$FFFF): TRectangle; overload;
var
  arr: TPointArray;
  SizeV: Int32;
  SizeH: Int32;
begin
  if ExpandV = 0 then ExpandV := 1;
  if ExpandH = 0 then ExpandH := 1;

  SizeV := 2 * ExpandV;
  SizeH := 2 * ExpandH;

  if (Roll = $FFFF) then Roll := Self.GetCompassAngle(False);
  Vec := Vec.RotateXY(PI*2 - Roll, Minimap.Center.X, Minimap.Center.Y);

  Arr := MM2MS.Run([Vec3(Vec.x-SizeH, Vec.y-SizeV, Vec.z),
                    Vec3(Vec.x+SizeH, Vec.y-SizeV, Vec.z),
                    Vec3(Vec.x+SizeH, Vec.y+SizeV, Vec.z),
                    Vec3(Vec.x-SizeH, Vec.y+SizeV, Vec.z)], Roll);

  Result := [Arr[0], Arr[1], Arr[2], Arr[3]];
end;


