{$DEFINE WL_WALKER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{$I waspweb.graph}
{$I agility.graph}

var
  WalkerArray: TStringArray;
  WalkerOffsetArray: TPointArray;

// overriden just so I can load maps from WaspLib maps folder
function TRSWalker.FindMap(Map: String): String; static; override;
var
  Mask: String = '.png;.bmp;';
  Files: TStringArray;
begin
  if FileExists(Map) then
    Exit(ExpandFileName(Map));

  Mask := StringReplace(Mask, '.', Map + '.', [rfReplaceAll]);

  Files := FindFile(ExtractFileDir(Map), Mask, False, False) +
           FindFile({$MACRO CURRENT_DIRECTORY}, Mask, True, False);

  if Length(Files) > 0 then
    Result := Files[0];
end;

// overriden to provide the ability to offset the map
procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
var
  Path: String;
  Bitmap, Mask, Sample: TMufasaBitmap;
  X, Y: Int32;
begin
  Self.Name := Map.Lower();

  Path := Self.FindMap(Map);
  if (Path = '') then
    Self.Fatal('Unable to find map: ' + Map);

  Self.Scaling := Scaling;
  Self.ClickRandomness := 4;

  if Name.Contains('agility') then
    Self.WebGraph := WaspAgility
  else
    Self.WebGraph := WaspWeb;

  Self.World := Self.LoadMap(Path);
  if Manage then
    AddOnTerminate(@Self.Free);

  // Fixed or resizable, doesn't matter.
  Sample := Self.World.Downsample(Self.Scaling);
  Bitmap := Self.GetCleanMinimap();
  Mask := Self.ScaleMinimap(Bitmap, Self.Scaling);

  for X := 0 to Mask.getWidth() - 1 do
    for Y := 0 to Mask.getHeight() - 1 do
      if (Mask.GetPixel(X, Y) <> 0) then
        Mask.SetPixel(X, Y, $FFFFFF);

  Self.Cache := TMatchTemplateRGBCache.Create(Sample.ToMatrix(), Mask.ToMatrix());

  Sample.Free();
  Bitmap.Free();
  Mask.Free();

  WalkerArray += Name;
  if Name.Contains('mainland') then
    WalkerOffsetArray += [3583, 0]
  else if Name.ContainsAll(['x', 'y']) then
  begin
    X := StrToInt(Name.After('x').Before('y'));
    Y := StrToInt(Name.After('x').After('y'));
    WalkerOffsetArray += [X, Y];
  end
  else
    WalkerOffsetArray += [0, 0];
end;

// overriden to take into account map offset on debug
procedure TRSWalker.DebugPosition; override;
var
  X1, Y1, X2, Y2, X, Y: Int32;
  P: TPoint;
  Bitmap, WorldBitmap, MinimapBitmap: TMufasaBitmap;
  Time: Double;
  Position: TPoint;
  Lines: TStringArray;
  WalkerOffset: TPoint;
begin
  WalkerOffset := WalkerOffsetArray[WalkerArray.Find(Name)];

  Freeze();

  Time := PerformanceTimer();
  Position := Self.GetMyPos();
  Time := PerformanceTimer() - Time;

  X1 := Max(0, (Position.X - WalkerOffset.X) - 200);
  Y1 := Max(0, (Position.Y - WalkerOffset.Y) - 200);
  X2 := Min(X1 + 400, Self.World.GetWidth()  - 1);
  Y2 := Min(Y1 + 400, Self.World.GetHeight() - 1);

  X := (Position.X - WalkerOffset.X) - X1;
  Y := (Position.Y - WalkerOffset.Y) - Y1;

  WorldBitmap := Self.World.Copy(X1, Y1, X2, Y2);
  WorldBitmap.LineTo(Point(0, Y), Point(X2 - X1, Y), $00FF00);
  WorldBitmap.LineTo(Point(X, 0), Point(X, Y2 - Y1), $00FF00);
  WorldBitmap.DrawBox(Box(X - 2, Y - 2, X + 2, Y + 2), $FFFFFF);

  MinimapBitmap := ScaleMinimap(GetCleanMinimap(), 1);

  P := MinimapBitmap.GetCenter();
  if RSClient.Mode = ERSClientMode.FIXED then
    P := P.Offset(0, 8).Rotate(-Minimap.GetCompassAngle(False), P);

  MinimapBitmap.DrawBoxFilled([P.X - 1, P.Y - 1, P.X + 1, P.Y + 1], False, $FFFFFF);
  MinimapBitmap.SetTransparentColor(0);

  Bitmap.Init();
  Bitmap.SetSize(400 + MinimapBitmap.GetWidth() + 30, 420);
  Bitmap.DrawClear($403027);

  Lines := [
    '('      + ToStr(Position.X, ', ', Position.Y) + ')',
    'Acc: '  + ToStr(Round(Self.Similarity, 3)),
    'Time: ' + ToStr(Round(Time)) + ' ms'
  ];

  Bitmap.SetFontName('Consolas');
  Bitmap.SetFontSize(18);
  Bitmap.SetFontAntialiasing(True);

  Bitmap.DrawText(Lines[0], [420, 20 + MinimapBitmap.GetHeight()], $FFFFFF);
  Bitmap.DrawText(Lines[1] + LineEnding + Lines[2], [420, 370], $FFFFFF);

  WorldBitmap.DrawTransparent(10, 10, Bitmap);
  WorldBitmap.Free();

  MinimapBitmap.DrawTransparent(420, 10, Bitmap);
  MinimapBitmap.Free();

  Bitmap.Debug();
  Bitmap.Free();

  UnFreeze();
end;

// overriden to take into account map offset
function TRSWalker.FullSearch(Templ, World: TMufasaBitmap; Position: TPoint; out Match: Single): TPoint; override;
const
  TEMPL_SIZE = 25;
  SLICE_SIZE = TEMPL_SIZE + 45;
  SCALING = 2;
var
  Slice, SliceScaled, TemplScaled: TMufasaBitmap;
  Matrix: TSingleMatrix;
  Area: TBox;
  WalkerOffset: TPoint;
begin
  WalkerOffset := WalkerOffsetArray[WalkerArray.Find(Name)];

  Area := [
    Max(0, Position.X - SLICE_SIZE),
    Max(0, Position.Y - SLICE_SIZE),
    Min(World.GetWidth()  - 1, Position.X + SLICE_SIZE),
    Min(World.GetHeight() - 1, Position.Y + SLICE_SIZE)
  ];

  Slice := World.Copy(Area.X1, Area.Y1, Area.X2, Area.Y2);
  SliceScaled := Slice.Downsample(SCALING);

  TemplScaled := Templ.Downsample(SCALING);
  with TemplScaled.GetCenter() do
    TemplScaled.Crop(X - TEMPL_SIZE, Y - TEMPL_SIZE, X + TEMPL_SIZE, Y + TEMPL_SIZE);

  Matrix := SliceScaled.MatchTemplate(TemplScaled, TM_CCOEFF_NORMED);

  with Matrix.ArgMax() do
  begin
    Match := Matrix[Y, X];

    Result.X := Area.X1 + (X + TEMPL_SIZE) * SCALING;
    Result.Y := Area.Y1 + (Y + TEMPL_SIZE) * SCALING;
    Result := Result.Offset(WalkerOffset);
  end;

  TemplScaled.Free();
  SliceScaled.Free();
  Slice.Free();
end;





// Checks if we are within Distance of Tile
function TRSWalker.AtTile(Tile: TPoint; Distance: Int32 = 15): Boolean;
begin
  Result := Self.GetMyPos.DistanceTo(Tile) <= Distance;
end;

function TRSWalker.AtTile(TilesArray: TPointArray; Distance: Int32 = 15): Boolean; overload;
var
  i: Int32;
begin
  Result := False;

  for i := 0 to High(TilesArray) do
  begin
    if (Self.GetMyPos.DistanceTo(TilesArray[i]) <= Distance) then
      Exit(True);
  end;
end;

function TRSWalker.AtTile(T2DTileArray: T2DPointArray; Distance: Int32 = 15): Boolean; overload;
var
  Idx, i: Int32;
begin
  Result := False;

  for Idx := 0 to High(T2DTileArray) do
    for i := 0 to High(T2DTileArray[Idx]) do
      if (Self.GetMyPos.DistanceTo(T2DTileArray[Idx][i]) <= Distance) then
        Exit(True);

end;


// Returns the closest tile to the player
// If the Distance is the same for more than one, a random one will be returned
function TRSWalker.GetClosestTile(Tiles: TPointArray): TPoint;
var
  Tile: TPoint;
  ClosestDistances: TIntegerArray;
  Distances: TExtendedArray;
begin
  if Tiles = [] then
    Exit
  else if Length(Tiles) = 1 then
    Exit(Tiles[0]);

  for Tile in Tiles do
    Distances += Self.GetMyPos.DistanceTo(Tile);

   ClosestDistances := Distances.FindAll(Distances.Min());

  Result := Tiles[ClosestDistances[Random(0, High(ClosestDistances))]];
end;

function TRSWalker.GetClosestTile(TilesArray: T2DPointArray): TPoint; overload;
var
  Tiles, ClosesTiles: TPointArray;
begin
  if TilesArray = [] then
    Exit;

  for Tiles in TilesArray do
    ClosesTiles += Self.GetClosestTile(Tiles);

  Result := Self.GetClosestTile(ClosesTiles);
end;


function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestTile(Destination), WaitUntilDistance, PathRandomness);
end;


// Returns all the an array of tiles that have the closest distance to the player
function TRSWalker.GetClosestTileCluster(TilesArray: T2DPointArray): TPointArray;
var
  Tiles: TPointArray;
begin
  if TilesArray = [] then
    Exit;

  for Tiles in TilesArray do
    Result += Self.GetClosestTile(Tiles);
end;

// Checks if the tile is currently visible
function TRSWalker.TileVisible(Tile: TPoint): Boolean; overload;
begin
  Result := MainScreen.IsVisible(Self.GetTileMS(Tile));
end;

function TRSWalker.TileVisible(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.TileVisible(Tile);
end;

// Checks if we can make the tile visible by zooming out
function TRSWalker.TileWithinZoom(Tile: TPoint): Boolean;
begin
  Result := Minimap.PointInZoomRadius(Self.WorldToMM(Tile));
end;

function TRSWalker.TileWithinZoom(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.TileWithinZoom(Tile);
end;



function TRSWalker.FacingTile(Tile: TPoint; Randomness: Int32 = 20): Boolean;
var
  Angle: Double;
begin
  Angle := MainScreen.PointToMM(Self.GetTileMS(Tile).Mean).ToPoint.AngleBetween(Minimap.Center);
  Result := (Angle <= (0 + Randomness)) or (Angle >= (360 - Randomness));
end;

// Attempts to rotate the screen in order to make Tile visible.
function TRSWalker.FaceTile(Tile: TPoint): Boolean;
begin
  if not Self.TileWithinZoom(Tile) then
    Exit;

  if not Self.FacingTile(Tile, 10) then
  begin
    MainScreen.FacePoint(Self.GetTileMS(Tile).Mean, 10);
    Result := Self.FacingTile(Tile, 10);
  end;
end;

function TRSWalker.FaceTile(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.FaceTile(Tile);
end;

// Attempts to zoom out enough so Tile is visible.
function TRSWalker.ZoomToTile(Tile: TPoint): Boolean;
var
  ZoomLevel: Int32;
  MaxZoomLevel: Int32;
begin
  if Self.TileWithinZoom(Tile) then
    Exit(True);

  ZoomLevel := Minimap.ZoomToPoint(Self.WorldToMM(Tile));

  if Antiban.MaxZoom > 0 then MaxZoomLevel := Antiban.MaxZoom
  else MaxZoomLevel := 100;

  if (ZoomLevel >= Antiban.MinZoom) and (ZoomLevel <= MaxZoomLevel) then
    Options.SetZoomLevel(ZoomLevel);

  Result := Self.TileWithinZoom(Tile);
end;

function TRSWalker.ZoomToTile(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := Self.ZoomToTile(Tile);
end;


function TRSWalker.MakeTileVisible(Tile: TPoint): Boolean;
begin
  Result := Self.TileVisible(Tile) or ZoomToTile(Tile) or
            (Self.FaceTile(Tile) and Self.TileVisible(Tile));
end;

function TRSWalker.MakeTileVisible(Tiles: TPointArray): Boolean; overload;
var
  Tile: TPoint := Self.GetClosestTile(Tiles);
begin
  Result := MakeTileVisible(Tile);
end;


function TRSWalker.UntilTileVisible(Tile: TPoint; Interval, WaitTime: UInt32 = 0): Boolean;
begin
  Result := WaitUntil(Self.TileVisible(Tile), Interval, WaitTime);
end;

function TRSWalker.UntilTileVisible(Tiles: TPointArray; Interval, WaitTime: UInt32 = 0): Boolean; overload;
begin
  Result := WaitUntil(Self.TileVisible(Tiles), Interval, WaitTime);
end;



function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
var
  WorldPoint: TPoint;
begin
  for WorldPoint in WorldPoints do
    Result += Self.WorldToMM(PlayerPoint, WorldPoint, Radians);
end;

function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), WorldPoints, Minimap.GetCompassAngle(False));
end;



//overriden to prevent running out memory due to the points being too far
function TRSWalker.GetTileMSEx(Me, Loc: TPoint; Height: Double = 0; Offx, Offy: Double = 0): TRectangle; override;
var
  angle: Double;
begin
  Loc := Minimap.Center + (Loc - Me);
  if not Minimap.IsPointOn(Loc) then Exit;

  angle := Minimap.GetCompassAngle(False);
  Loc   := Loc.Rotate(angle, Minimap.Center);
  Result := Minimap.VecToMSRect(Vec3(Loc.x - offx, Loc.y - offy, Height), angle);
end;

function TRSWalker.GetTileMSEx(Me, Loc: TPoint; Height: Double = 0; Offx, Offy: Double; Expand: Int32): TRectangle; overload;
var
  angle: Double;
begin
  Loc := Minimap.Center + (Loc - Me);
  if not Minimap.IsPointOn(Loc) then Exit;

  angle := Minimap.GetCompassAngle(False);
  Loc   := Loc.Rotate(angle, Minimap.Center);
  Result := Minimap.VecToMSRect(Vec3(Loc.x - offx, Loc.y - offy, Height), Expand, angle);
end;

function TRSWalker.GetTileMSEx(Me, Loc: TPoint; Height: Double = 0; Offx, Offy: Double; ExpandV, ExpandH: Int32): TRectangle; overload;
var
  angle: Double;
begin
  Loc := Minimap.Center + (Loc - Me);
  if not Minimap.IsPointOn(Loc) then Exit;

  angle := Minimap.GetCompassAngle(False);
  Loc   := Loc.Rotate(angle, Minimap.Center);
  Result := Minimap.VecToMSRect(Vec3(Loc.x - offx, Loc.y - offy, Height), ExpandV, ExpandH, angle);
end;


function TRSWalker.GetTilePoly(Me, Loc: TPoint; Height: Double = 0; Offx, Offy: Double; Expand: Int32 = 1): TPoly;
var
  Rect: TRectangle;
begin
  if Height = 0 then
    Result := Self.GetTileMSEx(Me, Loc, 0, Offx, Offy, Expand).ToTPA
  else
  begin
    Rect := Self.GetTileMSEx(Me, Loc, 0, Offx, Offy, Expand);
    Result := Rect.GetPoly(Self.GetTileMSEx(Me, Loc, Height, Offx, Offy, Expand));
  end;
end;

function TRSWalker.GetTilePoly(Me, Loc: TPoint; Height: Double = 0; Offx, Offy: Double; ExpandV, ExpandH: Int32): TPoly; overload;
var
  Rect: TRectangle;
begin
  if Height = 0 then
    Result := Self.GetTileMSEx(Me, Loc, 0, Offx, Offy, ExpandV, ExpandH).ToTPA
  else
  begin
    Rect := Self.GetTileMSEx(Me, Loc, 0, Offx, Offy, ExpandV, ExpandH);
    Result := Rect.GetPoly(Self.GetTileMSEx(Me, Loc, Height, Offx, Offy, ExpandV, ExpandH));
  end;
end;

function TRSWalker.GetTilePoly(Loc: TPoint; Height: Double = 0; Expand: Int32 = 1): TPoly; overload;
begin
  Result := Self.GetTilePoly(Self.GetMyPos, Loc, Height, 0, 0, Expand);
end;

function TRSWalker.GetTilePoly(Loc: TPoint; Height: Double = 0; ExpandV, ExpandH: Int32): TPoly; overload;
begin
  Result := Self.GetTilePoly(Self.GetMyPos, Loc, Height, 0, 0, ExpandV, ExpandH);
end;


function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; Height: Double = 0; Offx, Offy: Double; Expand: Int32 = 1): TRectArray;
var
  Loc: TPoint;
begin
  for Loc in LocArray.Sorted(Me) do
    Result += Self.GetTileMSEx(Me, Loc, Height, Offx, Offy, Expand);
end;

function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; Height: Double = 0; Offx, Offy: Double; ExpandV, ExpandH: Int32): TRectArray; overload;
var
  Loc: TPoint;
begin
  for Loc in LocArray.Sorted(Me) do
    Result += Self.GetTileMSEx(Me, Loc, Height, Offx, Offy, ExpandV, ExpandH);
end;

function TRSWalker.GetTileArrayMS(LocArray: TPointArray; Height: Double = 0; Expand: Int32 = 1): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos, LocArray, Height, 0, 0, Expand);
end;

function TRSWalker.GetTileArrayMS(LocArray: TPointArray; Height: Double = 0; ExpandV, ExpandH: Int32): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos, LocArray, Height, 0, 0, ExpandV, ExpandH);
end;


function TRSWalker.GetTileArrayPolys(Me: TPoint; LocArray: TPointArray; Height: Double = 0; Offx, Offy: Double; Expand: Int32 = 1): TPolyArray;
var
  Loc: TPoint;
begin
  for Loc in LocArray do
    Result += Self.GetTilePoly(Me, Loc, Height, Offx, Offy, Expand);
end;

function TRSWalker.GetTileArrayPolys(Me: TPoint; LocArray: TPointArray; Height: Double = 0; Offx, Offy: Double; ExpandV, ExpandH: Int32): TPolyArray; overload;
var
  Loc: TPoint;
begin
  for Loc in LocArray do
    Result += Self.GetTilePoly(Me, Loc, Height, Offx, Offy, ExpandV, ExpandH);
end;

function TRSWalker.GetTileArrayPolys(LocArray: TPointArray; Height: Double = 0; Expand: Int32 = 1): TPolyArray; overload;
begin
    Result := Self.GetTileArrayPolys(Self.GetMyPos, LocArray, Height, 0, 0, Expand);
end;

function TRSWalker.GetTileArrayPolys(LocArray: TPointArray; Height: Double = 0; ExpandV, ExpandH: Int32): TPolyArray; overload;
begin
    Result := Self.GetTileArrayPolys(Self.GetMyPos, LocArray, Height, 0, 0, ExpandV, ExpandH);
end;


