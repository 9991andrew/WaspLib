(*
WaspWalker
==============
Methods to handle walking around OSRS.
This file expands on SRL's walker file.
*)

{$DEFINE WL_WALKER2_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
(*
type ERSMap
~~~~~~~~~~~
  Enumerator used for auto-completion of map names since the same cannot be achieved with strings directly.
*)
  ERSMap = (
    WORLD_MAP,
    MAINLAND_MAP,
    ZEAH_MAP,

    ABYSS_MAP,
    ASGARNIA_ICE_DUNGEON_MAP,
    BARBARIAN_VILLAGE_MAP,
    BRIMHAVEN_DUNGEON_MAP,
    CATACOMBS_OF_KOUREND_MAP,
    CHASM_OF_FIRE_MAP,
    CORSAIR_COVE_DUNGEON_MAP,
    CRAFTING_GUILD_MAP,
    DEATH_PLATEU_MAP,
    FALADOR_MAP,
    FREMMENNIK_SLAYER_CAVE_MAP,
    GIANTS_DEN_MAP,
    GRAND_EXCHANGE_MAP,
    IORWERTH_DUNGEON_MAP,
    KALPHITE_CAVE_MAP,
    KALPHITE_LAIR_MAP,
    KARUULM_SLAYER_DUNGEON_MAP,
    KRAKEN_COVE_MAP,
    LUMBRIDGE_MAP,
    LUNAR_ISLAND_MAP,
    MOSLE_HARMLESS_CAVE_MAP,
    MOURNER_TUNNELS_MAP,
    OTTOS_GROTTO_MAP,
    PISCARILIUS_MAP,
    SLAYER_TOWER_BASEMENT_AND_UPPERLEVEL_MAP,
    SLAYER_TOWER_GROUNDFLOOR_MAP,
    SMOKE_DEVIL_DUNGEON_MAP,
    SMOKE_DUNGEON_MAP,
    STRONGHOLD_SLAYER_DUNGEON_MAP,
    VARROCK_MAP,
    WC_GUILD_MAP,
    WEST_VARROCK_MAP,
    WINTERTODT_MAP,
    ZULANDRA_MAP
  );

function ERSMap.Get(Map: ERSMap): String; Static;
begin
  Result := ToStr(Map);
end;

type
(*
type TRSMap
~~~~~~~~~~~
Type that holds information of RS Map in pre-extracted or to be extracted from the main image file.

**TRSMap.Name** is simply an identifier for that TRSMap.
**TRSMap.Plane** is the Z plane of RS to know which map to load. RS have 4 planes, plane 0 is where most ground and underground areas reside
while 1, 2 and 3 contain upper levels in that order.
**TRSMap.Coordinates** are the coordinate to crop from Simba/Includes/SRL/osr/walker/maps/#.bmp  where # is the plane we want to use.
*)
  TRSMap = record
    Name: String;
    Plane: Int32;      //runescape has 4 planes. Plane 0 is where most things are, 1, 2 and 3 are upper floors in that order.
    Coordinates: TBox; //coordinates of our map in relation to the raw map dump.
  end;

  TRSMapArray = array of TRSMap;

(*
var WASP_MAP_ARRAY
~~~~~~~~~~~~~~~~~~~~
Global variable used to store pre-defines TRSMap's.
*)
var
  WASP_MAP_ARRAY: TRSMapArray;

(*
TRSMapArray.IndexOf
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSMapArray.IndexOf(Name: String): Int32; overload;

Overload to search for a TRSMap in a TRSMapArray only by name.
*)
function TRSMapArray.IndexOf(Name: String): Int32; overload;
var
  i: Int32;
begin
  Result := -1;

  for i := 0 to High(Self) do
    if Self[i].Name = Name then
      Exit(i);
end;

(*
TRSMap.Setup
~~~~~~~~~~~~
.. pascal:: function TRSMap.Setup(Name: String; Coordinates: TBox; Plane: Int32 = 0): TRSMap; static;
.. pascal:: function TRSMap.Setup(Name: String; X, Y: Int32; Plane: Int32 = 0): TRSMap; static; overload;

Method used to setup a TRSMap. This will setup critical information about the TRSMap.
*)
function TRSMap.Setup(Name: String; Coordinates: TBox; Plane: Int32 = 0): TRSMap; static;
begin
  Result.Name := Name.ToLower();

  Result.Name := Name.ToLower();

  if Coordinates.X2 = 0 then
    Coordinates.X2 := Coordinates.X1 + 1000; //Automatically give the map 1000px width if we only gave it X1

  if Coordinates.Y2 = 0 then
    Coordinates.Y2 := Coordinates.Y1 + 1000; //Automatically give the map 1000px height if we only gave it Y1

  Result.Coordinates := Coordinates;
  Result.Plane := Plane;
  WASP_MAP_ARRAY += Result;
end;

function TRSMap.Setup(Name: String; X, Y: Int32; Plane: Int32 = 0): TRSMap; static; overload;
begin
  Result := TRSMap.Setup(Name, [X, Y, 0, 0], Plane);
end;

type
  //Walker with TRSMap support.
  TWaspWalker = record(TRSWalker)
    Map: TRSMap;
    HeightMap: TMufasaBitmap;

    Offset: TPoint;
  end;

  TWaspWalkerArray = array of TWaspWalker;

(*
var WASP_WALKER_ARRAY
~~~~~~~~~~~~~~~~~~~~~
Global array used to store all TWaspWalkers being used at any given moment.
*)
var
  WASP_WALKER_ARRAY: TWaspWalkerArray;

(*
TWaspWalker.FindMap
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TWaspWalker.FindMap(Map: String): String; static;
.. pascal:: function TWaspWalker.FindMap(Map: TRSMap): String; static; overload;

Function used to return the path of the map we want to use.

If you pass in a **String**, it will attempt to find the map file in Simba/Includes/SRL/osr/walker/maps/
The map file has to be either a .png or a .bmp.

If you pass a **TRSMap** instead, it will return a fictional path to an unexistent file that TWaspWalker
will know how to handle in **TWaspWalker.LoadMap()** for more information read the docs in that function.
*)
function TWaspWalker.FindMap(Map: String): String; static; override;
var
  Mask: String = '.png;.bmp;';
  Files: TStringArray;
begin
  if FileExists(Map) then
    Exit(ExpandFileName(Map));

  Mask := StringReplace(Mask, '.', Map + '.', [rfReplaceAll]);
  Files := FindFile(ExtractFileDir(Map), Mask, False, False) +
           FindFile({$MACRO CURRENT_DIRECTORY}, Mask, True, False);

  if Length(Files) > 0 then
    Result := Files[0];
end;

function TWaspWalker.FindMap(Map: TRSMap): String; static; overload;
begin
  //This file is never created but we add ".png" at the end so we don't need to rewrite much of TRSWalker.LoadMap().
  Result := {$MACRO CURRENT_DIRECTORY} + 'plane' + ToStr(Map.Plane) + ToStr(Map.Coordinates) + '.png';
end;


(*
TWaspWalker.LoadMap
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TWaspWalker.LoadMap(Path: String): TMufasaBitmap; static;
.. pascal:: function TWaspWalker.LoadMap(Path: String; Map: TRSMap): TMufasaBitmap; static; overload;

This method is responsible for returning our map as a **TMufasaBitmap** to be setup in **TWaspWalker.World**.

If you only pass it a String, it will use that as the map image path.
When doing this it will also make a version of the image in .bmp if you passed in a .png because those are much faster to load.

If you also pass in a TRSMap it will assume that **Path** is a fictional file that doesn't exist,
if there's an already cached version of this map, it will use that, if not, it will load "plane.bmp" instead
(for more info on planes, read TRSMap documentation above) and then crop the coordinates that
the TRSMap holds from "plane.bmp" and save it as a cache file for future uses.
This process might be slow the first time you do it for a certain set of coordinates but once the cache maps are generated
future runs will be fast.
*)
function TWaspWalker.LoadMap(Path: String): TMufasaBitmap; static; override;
const
  MAPS = {$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator;
var
  Cache: String;
begin
  Result := TMufasaBitmap.Create();

  if ExtractFileExt(Path) <> '.bmp' then
  begin
    Cache := MAPS + SHA1File(Path) + '.bmp';

    // Save as bitmap for much faster loading
    if not FileExists(Cache) then
    begin
      Result.LoadFromFile(Path);
      Result.SaveToFile(Cache);
    end;

    if FileExists(Cache) then
      Path := Cache;
  end;

  Result.LoadFromFile(Path);
end;

function TWaspWalker.LoadMap(Path: String; Map: TRSMap): TMufasaBitmap; static; overload;
const
  MAPS = {$MACRO CURRENT_DIRECTORY} + 'maps' + DirectorySeparator;
var
  Cache: String;
begin
  Result := TMufasaBitmap.Create();

  if ExtractFileExt(Path) <> '.bmp' then
  begin
    Cache := MAPS + 'cache' + DirectorySeparator + SHA1String(Path) + '.bmp';

    // Save as bitmap for much faster loading
    if not FileExists(Cache) then
    begin
      if Map = [] then
        Result.LoadFromFile(Path)
      else
      begin
        if not FileExists(MAPS + ToStr(Map.Plane) + '.bmp') then
        begin
          WriteLn('Some files require to be extracted since this is your first run, this may take a while.');
          UnZipFile(MAPS + 'maps.zip', MAPS);
        end;

        Result.LoadFromFile(MAPS + ToStr(Map.Plane) + '.bmp', Map.Coordinates);
      end;

      Result.SaveToFile(Cache);
    end;

    if FileExists(Cache) then
      Path := Cache;
  end;

  Result.LoadFromFile(Path);
end;

(*
TWaspWalker.Setup
~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;

Override TRSWalker.Setup so TWaspWalker can make use of TRSMaps.
*)
procedure TWaspWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
var
  Path: String;
  Bitmap, Mask, Sample: TMufasaBitmap;
  i: Int32;
  X, Y: Int32;
begin
  Self.Name := Map.ToLower();

  i := WASP_MAP_ARRAY.IndexOf(Self.Name);

  if i > -1 then
    Self.Map := WASP_MAP_ARRAY[i];

  Self.ScreenWalk := True; //Make ScreenWalk on by default.

  Self.Scaling := Scaling;
  Self.ClickRandomness := 4;

  if i = -1 then
    Path := Self.FindMap(Map)
  else
    Path := Self.FindMap(Self.Map);

  if (Path = '') then
    Self.Fatal('Unable to find map: ' + Map);

  if Self.Name.Contains('agility') then
    Self.WebGraph := WaspAgility
  else
    Self.WebGraph := WaspWeb;

  Self.World := Self.LoadMap(Path, Self.Map);

  if Manage then
    AddOnTerminate(@Self.Free);

  //Self.HighlightFeatures(Self.World);

  // Fixed or resizable, doesn't matter.
  Sample := TMufasaBitmap.Create();
  Self.World.Downsample(Sample, Self.Scaling);
  Bitmap := Self.GetCleanMinimap();
  Mask := Self.ScaleMinimap(Bitmap, Self.Scaling);

  for X := 0 to Mask.getWidth() - 1 do
    for Y := 0 to Mask.getHeight() - 1 do
      if (Mask.GetPixel(X, Y) <> 0) then
        Mask.SetPixel(X, Y, $FFFFFF);

  Self.Cache := TMatchTemplateCache.Create(Sample.ToMatrix(), Mask.ToMatrix());

  Sample.Free();
  Bitmap.Free();
  Mask.Free();

  WASP_WALKER_ARRAY += Self;

  if Self.Map <> [] then
    Self.Offset := [Self.Map.Coordinates.X1, Self.Map.Coordinates.Y1];
end;


(*
TWaspWalker.Free
~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspWalker.Free(); override;

Method used to free the memory used by a TWaspWalker. This method is overriden so we can also clear it from WASP_WALKER_ARRAY.
*)
procedure TWaspWalker.Free(); override;
begin
  WASP_WALKER_ARRAY.Delete(WASP_WALKER_ARRAY.IndexOf(Self), 1);

  if Self.World <> nil then
  begin
    Self.World.Free();
    Self.World := nil;
  end;
end;


(*
TWaspWalker.FullSearch
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TWaspWalker.FullSearch(Templ, World: TMufasaBitmap; Position: TPoint; out Match: Single): TPoint; override;

Overriden method to properly offset the player position if we are using a TRSMap.
*)
function TWaspWalker.FullSearch(Templ, World: TMufasaBitmap; Position: TPoint; out Match: Single): TPoint; override;
const
  TEMPL_SIZE = 25;
  SLICE_SIZE = TEMPL_SIZE + 45;
  SCALING = 2;
var
  Slice, SliceScaled, TemplScaled: TMufasaBitmap;
  Matrix: TSingleMatrix;
  Area: TBox;
begin
  Area := [
    Max(0, Position.X - SLICE_SIZE),
    Max(0, Position.Y - SLICE_SIZE),
    Min(World.GetWidth()  - 1, Position.X + SLICE_SIZE),
    Min(World.GetHeight() - 1, Position.Y + SLICE_SIZE)
  ];

  Slice := World.Copy(Area.X1, Area.Y1, Area.X2, Area.Y2);
  SliceScaled := Slice.Copy();
  SliceScaled.Downsample(SCALING);

  TemplScaled := Templ.Copy();
  TemplScaled.Downsample(SCALING);
  with TemplScaled.GetCenter() do
    TemplScaled.Crop(X - TEMPL_SIZE, Y - TEMPL_SIZE, X + TEMPL_SIZE, Y + TEMPL_SIZE);

  Matrix := SliceScaled.MatchTemplate(TemplScaled, TM_CCOEFF_NORMED);

  with Matrix.ArgMax() do
  begin
    Match := Matrix[Y, X];

    Result.X := Area.X1 + (X + TEMPL_SIZE) * SCALING;
    Result.Y := Area.Y1 + (Y + TEMPL_SIZE) * SCALING;
    Result += Self.Offset;
  end;

  TemplScaled.Free();
  SliceScaled.Free();
  Slice.Free();
end;

(*
TWaspWalker.DebugPosition
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: procedure TWaspWalker.DebugPosition(EnsureVisible: Boolean = True);

Overriden method to properly offset the player position if we are using a TRSMap.
*)
procedure TWaspWalker.DebugPosition(EnsureVisible: Boolean = True); override;
var
  X1, Y1, X2, Y2, X, Y: Int32;
  P: TPoint;
  Bitmap, WorldBitmap, MinimapBitmap: TMufasaBitmap;
  Time: Double;
  Position, RemovedOffset: TPoint;
  Lines: TStringArray;
begin
  Freeze();

  Time := PerformanceTimer();
  Position := Self.GetMyPos();
  RemovedOffset := Position - Self.Offset; //because Self.GetMyPos() returns the position offset, we need to remove it for certain things.

  Time := PerformanceTimer() - Time;

  X1 := Max(0, RemovedOffset.X - 200);
  Y1 := Max(0, RemovedOffset.Y - 200);
  X2 := Min(X1 + 400, Self.World.GetWidth()  - 1);
  Y2 := Min(Y1 + 400, Self.World.GetHeight() - 1);

  X := RemovedOffset.X - X1;
  Y := RemovedOffset.Y - Y1;

  WorldBitmap := Self.World.Copy(X1, Y1, X2, Y2);
  WorldBitmap.DrawLine(Point(0, Y), Point(X2 - X1, Y), $00FF00);
  WorldBitmap.DrawLine(Point(X, 0), Point(X, Y2 - Y1), $00FF00);
  WorldBitmap.DrawBox([X - 2, Y - 2, X + 2, Y + 2], $FFFFFF);

  MinimapBitmap := Self.ScaleMinimap(Self.GetCleanMinimap(), 1);

  P := MinimapBitmap.GetCenter();
  if RSClient.Mode = ERSClientMode.FIXED then
    P := P.Offset(0, 8).Rotate(-Minimap.GetCompassAngle(False), P);

  MinimapBitmap.DrawBoxFilled([P.X - 1, P.Y - 1, P.X + 1, P.Y + 1], $FFFFFF);

  Bitmap := TMufasaBitmap.Create();
  Bitmap.SetSize(400 + MinimapBitmap.GetWidth() + 30, 420);
  Bitmap.Fill($403027);

  Lines := [
    '('      + ToStr(Position.X, ', ', Position.Y) + ')',
    'Acc: '  + ToStr(Round(Self.Similarity, 3)),
    'Time: ' + ToStr(Round(Time)) + ' ms'
  ];

  Bitmap.SetFontName('Consolas');
  Bitmap.SetFontSize(18);
  Bitmap.SetFontAntialiasing(True);

  Bitmap.DrawText(Lines[0], [420, 20 + MinimapBitmap.GetHeight()], $FFFFFF);
  Bitmap.DrawText(Lines[1] + LineEnding + Lines[2], [420, 370], $FFFFFF);

  Bitmap.DrawBitmap(WorldBitmap, [10, 10]);
  WorldBitmap.Free();

  Bitmap.DrawBitmap(MinimapBitmap, [420, 10]);
  MinimapBitmap.Free();

  Bitmap.Show(EnsureVisible);
  Bitmap.Free();

  UnFreeze();
end;

(*
TRSWalker.IsWalkable
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TWaspWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;

Overriden to change the default behavior of TRSWalker.IsWalkable(), specifically for ScreenWalking since I don't like the default behaviour.
I find that minimap limits is extremely close to the render distance in the mainscreen, so personally I rather not
have the function bother any further if **WorldPoint** is not on the minimap.

This override will affect both TRSWalker and TWaspWalker.
*)
function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;
var
  MinimapPoint: TPoint;
  R: TRectangle;
begin
  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Angle);

  Result := Minimap.IsPointOn(MinimapPoint, -1);

  if Result and Self.ScreenWalk then
  begin
    R := Minimap.PointToMSRect(MinimapPoint, Angle);
    Result := MainScreen.IsVisible(R.Mean) and (CountColor($000000, R.Bounds.Expand(0, MainScreen.Bounds)) = 0);
  end;
end;


(*
TRSWalker.AtTile
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.AtTile(WorldPoint: TPoint; Distance: Int32 = 4): Boolean;
.. pascal:: function TRSWalker.AtTile(WorldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;

Method used to quickly check if we are within distance of a certain **WorldPoint**. This distance is measure in pixels and in a radial way.
You can optionally pass in a TPA to check if the closest point is within distance.

This is a TRSWalker method so it will exist both on TRSWalker and TWaspWalker.
*)
function TRSWalker.AtTile(WorldPoint: TPoint; Distance: Int32 = 4): Boolean;
begin
  Result := Self.GetMyPos.WithinDistance(WorldPoint, Distance);
end;

function TRSWalker.AtTile(WorldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;
begin
  Result := Self.GetMyPos.WithinDistance(WorldPointArray, Distance);
end;



(*
TRSWalker.GetClosestPoint
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetClosestPoint(WorldPointArray: TPointArray): TPoint;

Method used to get the closest Point to the Player out of a TPA.

This is a TRSWalker method so it will exist both on TRSWalker and TWaspWalker.
*)
function TRSWalker.GetClosestPoint(WorldPointArray: TPointArray): TPoint;
begin
  if WorldPointArray <> [] then
    Result := WorldPointArray.Sorted(Self.GetMyPos())[0];
end;

(*
TRSWalker.WebWalk
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;

Method used to webwalk to the closest Point to the player.
An example use case is for example, if you have sevel bank booths you can use, those would be your **Destination** TPA.
You will likely want to use the closest bank booth to you, so you use this.

This is a TRSWalker method so it will exist both on TRSWalker and TWaspWalker.
*)
function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestTile(Destination), WaitUntilDistance, PathRandomness);
end;


(*
TRSWalker.WorldToMM
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;

Overloaded methods required for TRSDotFilter. For more information on TRSDotFilter check their documentation.

This is a TRSWalker method so it will exist both on TRSWalker and TWaspWalker.
*)
function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
var
  P: TPoint;
begin
  for P in WorldPoints do
    Result += Self.WorldToMM(PlayerPoint, P, Radians);
end;

function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), WorldPoints, Minimap.GetCompassAngle(False));
end;

function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
var
  P: TPoint;
begin
  if DotFilter.Circle <> [] then
  begin
    P := Self.WorldToMM(DotFilter.Circle.Mean);
    Result.Circle := [P.X, P.Y, DotFilter.Circle.Radius];
  end;

  Result.TPA      := Self.WorldToMM(DotFilter.TPA);
  Result.Inside   := DotFilter.Inside;
  Result.HasTimer := DotFilter.HasTimer;
  Result.Timer    := DotFilter.Timer;
end;

function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;
var
  DotFilter: TRSDotFilter;
begin
  for DotFilter in DotFilterArray do
    Result += Self.WorldToMM(DotFilter);
end;


(*
TRSWalker.GetPolygonMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray;
.. pascal:: function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray; overload;

This are TRSWalker methods so they will exist both on TRSWalker and TWaspWalker.

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.
This calls **TRSMinimap.GetPolygonMS()** internally which in turn will use both methods above.

To put it simply, this will will first calculate a floor rectangle with **TileVector.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **TileVector.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon:

Example
-------
  Debug(RSW.GetPolygonMS([100, 100], [1, 1, 4], Offset));     //This will draw a polygon around the coordinate [100, 100].
*)
function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly;
var
  Angle: Double;
begin
  Angle := Minimap.GetCompassAngle(False);
  Loc   := Self.WorldToMM(Me, Loc, Angle);

  Result := Minimap.GetPolygonMS(Loc, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly; overload;
begin
  Result := Self.GetPolygonMS(Self.GetMyPos(), Loc, TileVector, Offset);
end;


(*
TRSWalker.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
.. pascal:: function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;

This are wrapper functions to retrieve multiple tiles. Refer to SRL's TRSWalker.GetTileMSEx() and TRSWalker.GetTileMS() for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TWaspWalker.
*)
function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
var
  Loc: TPoint;
begin
  for Loc in LocArray.Sorted(Me) do
    Result += Self.GetTileMSEx(Me, Loc, TileVector, Offset);
end;

function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos, LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetPolygonArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;
.. pascal:: function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetPolygonMS** for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TWaspWalker.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetPolygonArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray;
var
  Angle: Double;
  i: Int32;
  tmpArray: TPointArray;
begin
  Angle := Minimap.GetCompassAngle(False);
  tmpArray := Copy(LocArray);

  for i := 0 to High(tmpArray) do
    tmpArray[i] := Self.WorldToMM(Me, LocArray[i], Angle);

  Result := Minimap.GetPolygonArrayMS(tmpArray, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray; overload;
begin
  Result := Self.GetPolygonArrayMS(Self.GetMyPos(), LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetMMPoly
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;

This function converts a list of points to their respective points in the minimap.
This is extremely useful if you want to be sure you are within an area.
To make a polygon or a polygon array easily you can use Simba/Includes/WaspLib/tools/walkerpolygon.simba.

This are TRSWalker methods so they will exist both on TRSWalker and TWaspWalker.

Example
-------
  Debug(RSW.GetMMPoly(TPA).Connect());    //This will draw your TPA on the minimap.
*)
function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;
begin
  Result := Self.WorldToMM(LocArray);
end;

(*
TRSWalker.InPoly
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.InPoly(LocArray: TPointArray): Boolean;

Checks if you are inside a polygon. If you need to debug the polygon check the example in TRSWalker.GetMMPoly.

This are TRSWalker methods so they will exist both on TRSWalker and TWaspWalker.

*)
function TRSWalker.InPoly(LocArray: TPointArray): Boolean;
begin
  Result := SRL.PointInPoly(Self.GetMyPos(), LocArray);
end;


begin
  TRSMap.Setup('zeah', [0, 34150, 3100, 36900]);
  TRSMap.Setup('mainland', [3500, 33960, 11008, 40266]);
  TRSMap.Setup('craftguildfloor', [7000, 37200, 7300, 37400]);
end;
