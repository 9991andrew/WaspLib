{$DEFINE WL_BANK_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

function TRSBank.Find(item: TRSItem; out bounds: TBox): Boolean; override;
var
  tempItem: TRSItem;
begin
  if not Self.IsOpen() then
    Exit;

  for tempItem in item.GetArray() do
  begin
    Result := inherited(tempItem, bounds);
    if Result then
      Exit;
  end;
end;

function TRSBank.Find(item: TRSItem; out bounds: TBox): Boolean; override;
begin
  Result := Self.ItemFinder.Find([item], bounds);
end;

function TRSBank.Contains(item: TRSBankWithdrawItem): Boolean; overload;
begin
  Result := Self.Contains(item.Item);
end;

function TRSBank.Find(tab: Int32; item: TRSItem; out bounds: TBox): Boolean; overload;
begin
    Result := Self.OpenTab(tab) and Self.Find(item, bounds);
end;

function TRSBank.Find(items: TRSItemArray; out bounds: TBox): Boolean; overload
var
  item: TRSItem;
begin
  for item in items do
    if Self.Find(item, bounds) then
      Exit(True);
end;

function TRSBank.Contains(tab: Int32; item: TRSItem): Boolean; overload;
begin
  Result := Self.OpenTab(tab) and Self.Contains(item);
end;

function TRSBank.Contains(tab: Int32; item: TRSBankWithdrawItem): Boolean; overload;
begin
  Result := Self.OpenTab(tab) and Self.Contains(item);
end;



function TRSBank.CountSlotStack(Slot: Int32): Int32;
begin
  Result := -1;
  Result := SRL.GetItemAmount(Self.GetItemBoxes[Slot]);
end;

function TRSBank.WithdrawHelper(B: TBox; Amount: Int32; Noted: Boolean; useButtons: Boolean): Boolean; override;
begin
  case Noted of
    True:  if (not Self.ElementFinder.Toggle(Self.ELEMENT_NOTE, RSColors.BUTTON_RED, 5)) then Exit;
    False: if (not Self.ElementFinder.Toggle(Self.ELEMENT_ITEM, RSColors.BUTTON_RED, 5)) then Exit;
  end;

  if useButtons then
  begin
    if not (Amount in [1,5,10]) then
    begin
      if not Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_X, RSColors.BUTTON_RED, 5) then
        Exit;

      Mouse.Move(B);

      if Result := MainScreen.IsUpText('Withdraw-' + ToString(Amount)) then
        Mouse.Click(MOUSE_LEFT)
      else
        Result := (ChooseOption.Select('Withdraw-' + ToString(Amount), MOUSE_LEFT, True, False)) or
                  (ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000)));

      if (WL.GameSettings.BankWithdrawX = Amount) or MainScreen.IsUpText('Withdraw-' + ToString(Amount)) then
      begin
        Mouse.Click(MOUSE_LEFT);
        Result := True;
      end else
      begin
        Result := (ChooseOption.Select('Withdraw-' + ToString(Amount), MOUSE_LEFT, True, False)) or
                  (ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 4000)));
        if Result then
          WL.GameSettings.BankWithdrawX := Amount;
      end;
    end else
    begin
      case Amount of
        1:  Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_1, RSColors.BUTTON_RED, 5);
        5:  Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_5, RSColors.BUTTON_RED, 5);
        10: Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_10, RSColors.BUTTON_RED, 5);
        else
            Result := Self.ElementFinder.Toggle(Self.ELEMENT_QUANTITY_ALL, RSColors.BUTTON_RED, 5);
      end;

      if Result then
        Mouse.Click(B, MOUSE_LEFT);
    end;
  end else
  begin
    Mouse.Move(B);

    case Amount of
      -1:
        Result := ChooseOption.Select('Withdraw-All');
      -2:
        Result := ChooseOption.Select('Withdraw-All-but-1');
      else
        Result := (ChooseOption.Select('Withdraw-' + ToString(Amount) + ' ', MOUSE_LEFT, True, False)) or
                  (ChooseOption.Select('Withdraw-X') and Chat.AnswerQuery('Enter amount', ToString(Amount), Random(2000, 2500)));
    end;
  end;
end;


function TRSBank.WithdrawIndex(tab: Int32; item: TRSBankWithdrawIndex; useButtons: Boolean): Boolean; overload;
var
  itemCount: Int32;
begin
  if not Self.IsOpen or (tab = -1) then
    Exit;

  Self.OpenTab(tab);

  itemCount := Self.CountSlotStack(item.Index);
  if Self.WithdrawIndex(item, useButtons) then
    Result := WaitUntil(Self.CountSlotStack(item.Index) < itemCount, 100, 2000);
end;


function TRSBank.WithdrawItem(out tab: Int32; item: TRSBankWithdrawItem; useButtons: Boolean): Boolean; overload;
var
  b: TBox;
  itemCount: Int32;
begin
  if not Self.IsOpen() then
    Exit;

  if Inventory.IsFull() and not Inventory.IsStackable(item.Item) then
    Exit;

  if not Self.Find(item.Item, b) then
  begin
    if tab = -1 then
      tab := Self.FindItemTab(item.Item)
    else
      Self.OpenTab(tab);

    if not Self.Find(item.Item, b) then
      Exit(False);
  end;

  itemCount := SRL.GetItemAmount(b);
  if Self.WithdrawHelper(b, item.Quantity, item.Noted, useButtons) then
    Result := WaitUntil(SRL.GetItemAmount(b) < itemCount, 100, 2000);
end;

function TRSBank.WithdrawItems(tab: Int32; Items: array of TRSBankWithdrawItem; useButtons: Boolean): Boolean;
var
  Item: TRSBankWithdrawItem;
begin
  for Item in Items do
    if not Self.WithdrawItem(tab, Item, useButtons) then
      Exit(False);

  Result := True;
end;



function TRSBank.DepositItem(tab: Int32; item: TRSBankDepositItem; useButtons: Boolean): Boolean; overload;
var
  isStackable: Boolean;
  itemCount: Int32;
begin
  if not Self.IsOpen then
    Exit;

  if isStackable := Inventory.IsStackable(item.Item) then
    itemCount := Inventory.CountStack(item.Item)
  else
    itemCount := Inventory.Count(item.Item);

  if tab > -1 then
    Self.OpenTab(tab);

  if Self.DepositItem(item, useButtons) then
  begin
    if IsStackable then
      Result := WaitUntil((Inventory.CountStack(item.Item) <> itemCount), 50, 2000)
    else
      Result := WaitUntil((Inventory.Count(item.Item) <> itemCount), 50, 2000);
  end;
end;

function TRSBank.DepositItem(tab: Int32; item: TRSItem; useButtons: Boolean): Boolean; overload;
begin
  Result := Self.DepositItem(tab, [item, -1], useButtons);
end;

function TRSBank.DepositItemArray(tab: Int32; itemArray: array of TRSBankDepositItem; useButtons: Boolean): Boolean;
var
  item: TRSBankDepositItem;
  itemList: array of TRSBankDepositItem;
begin
  for item in itemArray do
    if Inventory.Contains(item.Item) then
      itemList += item;

  for item in itemList do
    if not Self.DepositItem(tab, item, useButtons) then
      Exit(False);

  Result := True;
end;

function TRSBank.DepositItemArray(tab: Int32; itemArray: TRSItemArray; useButtons: Boolean): Boolean; overload;
var
  item: TRSItem;
  itemList: TRSItemArray;
begin
  for item in itemArray do
    if Inventory.Contains(item) then
      itemList += item;

  for item in ItemList do
    Self.DepositItem(tab, item, useButtons);

  Result := not Inventory.ContainsAny(itemList);
end;

function TRSBank.DepositAllBut(tab: Int32; items: TRSItemArray): Boolean;
var
  item: TRSItem;
  slots: TIntegerArray;
  depositSlots: TIntegerArray;
begin
  if not Self.IsOpen() then
    Exit;

  if tab > -1 then
    Self.OpenTab(tab);

  for item in items do
    slots += Inventory.FindItem(item);

  depositSlots := slots.SymmetricDifference(Inventory.GetUsedIndexs());

  if depositSlots <> [] then
  repeat
    if not Self.IsOpen then //Exit in case the bank somehow closed.
      Exit;

    if Self.DepositIndex([depositSlots[0], -1], True) then
      WaitUntil(not Inventory.IsIndexUsed(depositSlots[0]), 100, 2000);

    depositSlots := slots.SymmetricDifference(Inventory.GetUsedIndexs());
  until Result := (depositSlots = []);
end;

function TRSBank.Close(PressEscape: Boolean = False): Boolean; override;
begin
  if not Self.IsOpen() then
    Exit(True);

  Result := MainScreen.CloseInterface(PressEscape);
end;

function TRSBank.Close(Chance: Double): Boolean; overload;
var
  PressEscape: Boolean;
begin
  if Chance = Login.Players[Login.PlayerIndex].BioHash then
    PressEscape := Antiban.BioDice()
  else
    PressEscape := SRL.Dice(Chance);

  Result := MainScreen.CloseInterface(PressEscape);
end;
