{$DEFINE WL_OBJECT_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  TRSObject = record
    Map: TRSWalker;
    Tiles: TPointArray;
    Height: Int32;
    UpText: TStringArray;
    Finder: TRSObjectFinder;
  end;

  TRSObjectArray = array of TRSObject;

var
  CurrentBank: TRSObject;

{$I walker/worldobject.simba}
{$I walker/zeahobject.simba}

// Searches for an object with ObjectFinder in the MainScreen with the
// help of RSWalker. Good when objects don't move and precision is needed.
function TRSObject.Find: T2DPointArray;
var
  Me: TPoint;
  Tile: TPoint;
  TileArray: TPointArray;
  Rect: TRectangle;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  B: TBox;
  TPA: TPointArray;
begin
  Me := Map.GetMyPos();
  TileArray := Copy(Tiles);
  TileArray.Sorted(Me);

  for Tile in TileArray do
  begin
    Rect := Map.GetTileMSEx(Me, Tile, Height);
    HighTPA := Rect.ToTPA;

    if Height > 0 then
    begin
      Rect := Map.GetTileMSEx(Me, Tile, 0);
      LowTPA := Rect.ToTPA;
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    B := TPA.Bounds;

    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      TPA := MainScreen.FindObject(Finder, B).Merge;
      Result += Rect.Filter(TPA);
    end;
  end;

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

procedure TRSObject.Debug;
var
  Bitmap: TMufasaBitmap;
  Tile: TPoint;
  Rect: TRectangle;
  Rectangles: Array of TRectangle;
  Me: TPoint;
  TileArray: TPointArray;
  HighTPA: TPointArray;
  LowTPA: TPointArray;
  TPA: TPointArray;
  B: TBox;
  Obj: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  //Debug tiles
  for Tile in Tiles do
    Rectangles += Map.GetTileMS(Tile);
  for Rect in Rectangles do
    Bitmap.DrawRect(Rect, $ffffff);

  //Debug Object
  Me := Map.GetMyPos();
  TileArray := Copy(Tiles);
  TileArray.Sorted(Me);

  for Tile in TileArray do
  begin
    Rect := Map.GetTileMSEx(Me, Tile, Height);
    HighTPA := Rect.ToTPA;
    Bitmap.DrawRect(Rect, $ffffff);

    if Height > 0 then
    begin
      Rect := Map.GetTileMSEx(Me, Tile, 0);
      LowTPA := Rect.ToTPA;
      Bitmap.DrawRect(Rect, $ffffff);
      TPA := HighTPA.Combine(LowTPA);
      TPA.ClearDuplicates;
    end
    else
      TPA := HighTPA;

    Rect := TPA.MinAreaRect;
    Bitmap.DrawRect(Rect, $0000ff);

    B := TPA.Bounds;
    if InterfaceArea.Bounds.Contains(Rect) then
    begin
      TPA := MainScreen.FindObject(Finder, B).Merge;
      Obj += Rect.Filter(TPA);
    end;
  end;

  if Obj = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  Obj.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(Obj);
  Bitmap.DrawTPA(Obj[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;


procedure TRSObject.SetupCommon(Walker: TRSWalker; ObjHeight: Int32 = 3);
begin
  Map := Walker;
  Height := ObjHeight;
  Finder.ClusterDistance := 2;
  Finder.Erode := 2;
  Finder.Grow := 4;
end;


function TRSObject.BlindFind: T2DPointArray;
begin
  Result := MainScreen.FindObject(Finder);

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

procedure TRSObject.BlindDebug;
var
  Bitmap: TMufasaBitmap;
  Obj: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  Obj := MainScreen.FindObject(Finder);

  if Obj = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  Obj.SortByMiddle(MainScreen.GetPlayerBox.Middle);
  Bitmap.DrawATPA(Obj);
  Bitmap.DrawTPA(Obj[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;



function TRSObjectArray.GetClosestObject: TRSObject;  //NEED REWORK MAYBE?
var
  Map: TRSWalker;
  i: Int32;
  ClosestTiles: TPointArray;
  RSObject: TRSObject;
begin
  if Self = [] then
    Exit;

  for i := 0 to High(Self) do
  begin
    if Map = [] then
      Map := RSObject.Map;

    if Map <> RSObject.Map then
      Exit;

    ClosestTiles += Map.GetClosestTile(Self[i].Tiles);
  end;

  Result := Self[ClosestTiles.Find(Map.GetClosestTile(ClosestTiles))];
end;

procedure TRSObject.SetCurrentBank;
begin
  CurrentBank := Self;
end;


// HoverHelper function used by all non moving object hovering functions.
function TRSObject.HoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
        Mouse.Move(Points[Random(0, High(Points))]);
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// HoverHelper function used by all blind object hovering functions.
function TRSObject.BlindHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.BlindFind) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
        Mouse.Move(Points[Random(0, High(Points))]);
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// WalkHoverHelper function used by all moving object hovering functions.
function TRSObject.WalkHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
begin
  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
        Mouse.Move(Points[Random(0, High(Points))]);
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True)
    else if not Map.AtTile(Tiles, 50) or ((Attempt = (Attempts - 1)) and not Map.AtTile(Tiles, 30)) then
      Map.WebWalk(Map.GetClosestTile(Tiles), 10, 0.2)
    else
      Minimap.SetCompassAngle(Random(Minimap.GetCompassAngle - 50, Minimap.GetCompassAngle + 50) , 10);
  end;
end;

// ClickHelper function used by all object clicking functions.
function TRSObject.ClickHelper(LeftClick: Boolean): Boolean;
begin
  if ChooseOption.IsOpen and ChooseOption.Select(UpText) then
    Exit(True);

  if LeftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and ChooseOption.Select(UpText));
end;

// SelectHelper function used by all object option selection functions.
function TRSObject.SelectHelper(Action: TStringArray): Boolean;
begin
  if ChooseOption.IsOpen and
     ChooseOption.HasOption(UpText) and
     ChooseOption.Select(Action) then
    Exit(True);

  if not MainScreen.IsUpText(UpText) then
    Exit;

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;




// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSObject.HoverRSObject(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Map.MakeTileVisible(Tiles) then
    Exit(False);

  Result := Self.HoverHelper(Attempts);
end;

// Searches for an object with ObjectFinder and HoverRSObject and clicks it if found.
function TRSObject.ClickRSObject(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSObject(Attempts) and
            Self.ClickHelper(LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSObject.SelectRSObjectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.HoverRSObject(Attempts) and
            Self.SelectHelper(Action);
end;



// Searches for an object with ObjectFinder blindly and hovers it if found.
function TRSObject.BlindHoverRSObject(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Map.MakeTileVisible(Tiles) then
    Exit(False);

  Result := Self.BlindHoverHelper(Attempts);
end;

// Searches for an object with ObjectFinder and BlindHoverRSObject and clicks it if found.
function TRSObject.BlindClickRSObject(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.BlindHoverRSObject(Attempts) and
            Self.ClickHelper(LeftClick);
end;

// Searches for an object with ObjectFinder and BlindHoverRSObject and selects the specified action if found.
function TRSObject.BlindSelectRSObjectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.BlindHoverRSObject(Attempts) and
            Self.SelectHelper(Action);
end;



// Searches for an object with ObjectFinder in a certain tile and hovers it if found.
function TRSObject.WalkHoverRSObject(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Map.MakeTileVisible(Tiles) then
    if not Map.WebWalk(Map.GetClosestTile(Tiles), 30, 0.2) then
      Exit(False);

  Result := Self.WalkHoverHelper(Attempts);
end;

// Searches for an object with ObjectFinder and WalkHoverRSObject and clicks it if found.
function TRSObject.WalkClickRSObject(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSObject(Attempts) and
            Self.ClickHelper(LeftClick);
end;

// Searches for an object with ObjectFinder and HoverRSObject and selects the specified action if found.
function TRSObject.WalkSelectRSObjectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHoverRSObject(Attempts) and
            Self.SelectHelper(Action);
end;



procedure TRSWalker.Setup(Map: String; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  case Map.Lower() of
    'world': WorldObjects.Load(Self);
    'zeah': ZeahObjects.Load(Self);
  end;
end;

procedure TRSWalker.Setup(Map: String; Offset: TPoint; Manage: Boolean = True; Scaling: Int32 = 9); override;
begin
  inherited;

  if Map.Contains('world') then
    WorldObjects.Load(Self)
  else if Map.Contains('zeah') then
    ZeahObjects.Load(Self);
end;
