(*
WaspObjects
===========
Methods to handle TWaspObjects.
TWaspObjects can be anything that have a shape in the mainscreen.
They are divided in 2 main categories and one of them in 3 sub-categories:
  - RSObjects
  - MMDots:
    -RSNPCs
    -RSGroundItems
    -RSPlayers
*)

{$DEFINE WL_WASPOBJECT_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
(*
type TRSObjectShape
~~~~~~~~~~~~~~~~~~~

TRSObjectShape is the record used in **TWaspObject.Self.ShapeArray** which is an array of TRSObjectShape.
This record holds information about the shape of a TWaspObject

* **TRSObjectShape.Self.TileArray**

  Self.TileArray is a TPointArray holding the tiles of a TWaspObject with **specific Size**. Multiple sized TWaspObjects, e.g. TWaspObjects that are oriented differently throught runescape should be set separately in **TWaspObject.Self.ShapeArray**.

* **TRSObjectShape.TileVector**

  TileVector is a Vector3 type holding the information about the size and orientation of a TWaspObject. Multiple sized TWaspObjects, e.g. TWaspObjects that are oriented differently throught runescape should be set separately in **TWaspObject.Self.ShapeArray**.

  TileVector has 3 variables:
    - **X** ( Number of tiles the TWaspObject takes from **West** to **East** )
    - **Y** ( Number of tiles the TWaspObject takes from **North** to **South** )
    - **Z** ( Height of the TWaspObject from the **Floor** to it's **Top**. This value cannot be measured and has to be guessed by trial and error, for reference, a Player or a human NPC height is about **6** )
*)

  TRSObjectShape = record
    TileArray: TPointArray;
    TileVector: Vector3;
  end;

(*
type TRSObjectFilter
~~~~~~~~~~~~~~~~~~~~

TRSObjectFilter is the record used in **TWaspObject.Filter**. This record is used to enable or disable functionality from TWaspObjects.

    MinimapDot: Boolean;
    Self.Finder: Boolean;
    Self.UpText: Boolean;

* **TRSObjectShape.Walker**

  Walker enables/disables TRSWalker for the given TWaspObject.
  When enabled TWaspObjects will use TRSWalker to get the TWaspObject tiles and will then search those tiles for the TWaspObject.
  It's the most accurate way to use TWaspObject but also the slowest. In cases TRSWalker is not needed, it should be disabled for maximum performance.

  Usage
  -----
  .. pascal::

     WaspObject.Self.Filter.Walker := False;
*)

  TRSObjectFilter = record
    Walker: Boolean;
    MinimapDot: Boolean;
    Finder: Boolean;
    UpText: Boolean;
  end;

(*
type TWaspObject
~~~~~~~~~~~~~~~~

TWaspObject is the base record used by **TRSObjects and TRSMMDots**.

* **TWaspObject.Walker**

  Variable holding a **PRSWalker** pointer.

  Usage
  -----
  .. pascal::

     WaspObject.Walker := @RSW;

* **TWaspObject.Self.ShapeArray**

  Self.ShapeArray holds an array of **TRSObjectShape**.
  You can add as many TRSObjectShape as you want but in reality you should never need more than 2 shapes, one for vertical (north/south) oriented objects and another for horizontal (west/east) oriented ones.

* **TWaspObject.Self.TileArray**

  Self.TileArray holds a **TPointArray**.
  This array should contain all the TPoints stores in every TRSObjectShape.Self.TileArray in TWaspObject.Self.ShapeArray.
  This variable exists so Walker can refer to the TWaspObject location.

  Setup example
  -------------
  .. pascal::

     for i := 0 to High(Self.ShapeArray) do
       Self.TileArray.Extend(Self.ShapeArray[i].TileArray);

* **TWaspObject.Self.Finder**

  Self.Finder holds a **TRSObjectFinder**.
  It is used to find the TWaspObject on the mainscreen.
  For more information refer to: https://ollydev.github.io/SRL-Development/mainscreen.html#type-TRSObjectFinder

* **TWaspObject.Self.UpText**

  Self.UpText holds a **TStringArray** with strings of the TWaspObject up text.

  Usage
  -----
  .. pascal::

     WaspObject.Self.UpText := ['Banker'];
     Writeln MainScreen.IsUpText(WaspObject.Self.UpText);

* **TWaspObject.Filter**

  Filter holds a **TRSObjectFilter**.
  For more information: https://torwent.github.io/WaspLib/waspobject.html#type-trsobjectfilter
*)

  TWaspObject = record
    WalkerIndex: Int32;
    ShapeArray: array of TRSObjectShape;
    TileArray: TPointArray;
    Finder: TRSObjectFinder;
    UpText: TStringArray;
    ActionUpText: TStringArray;
    Filter: TRSObjectFilter;
    RedClicked: Boolean;
  end;
(*
type TRSObject
~~~~~~~~~~~~~~

TRSObject is a **TWaspObject** specific for objects that do not have a minimap dot.
They can be used for objects with a minimap dot that do not move but **TRSMMDot** gives you more flexibility for those.
*)

  TRSObject = type TWaspObject;
  TRSObjectArray = array of TRSObject;
  PRSObject = ^TRSObject;
  PRSObjectArray = array of PRSObject;

  TRSDoor = record
    Open: TRSObject;
    Closed: TRSObject;
  end;

(*
type TRSMMDot
~~~~~~~~~~~~~

TRSMMDot is a **TWaspObject** specific for objects that have a minimap dot.
There's 3 types of TRSMMDot:
  - TRSNPC
  - TRSGroundItem
  - TRSPlayer

Each one made to handle each type of TRSMMDot.
*)

  TRSMMDot = record(TWaspObject)
    ClosestDot: TPoint;
    DotType: ERSMinimapDot;
    DotFilter: TRSDotFilterArray;
  end;

  TRSNPC = type TRSMMDot;
  TRSNPCArray = array of TRSNPC;
  PRSNPC = ^TRSNPC;
  PRSNPCArray = array of PRSNPC;

  TRSGroundItem = record(TRSMMDot)
    Item: TRSItem;
    Value: Int32;
    HighAlch: Int32;
  end;

  TRSGroundItemArray = array of TRSGroundItem;
  PRSGroundItem = ^TRSGroundItem;
  PRSGroundItemArray = array of PRSGroundItem;

  TRSPlayer = type TRSMMDot;
  TRSPlayerArray = array of TRSPlayer;
  PRSPlayer = ^TRSPlayer;
  PRSPlayerArray = array of PRSPlayer;

function MakeShape(TileVector: Vector3; TileArray: TPointArray): TRSObjectShape;
begin
  Result := [TileArray, TileVector];
end;

procedure TWaspObject.SetupCommon();
begin
  Self.Finder.ClusterDistance := 3;
  Self.Finder.Erode := 2;
  Self.Finder.Grow := 4;

  Self.Filter.Finder := True;
  Self.Filter.UpText := True;
end;

procedure TRSObject.SetupCommon(Height: Double; ObjTileArray: TPointArray); overload;
begin
  Self.TileArray := ObjTileArray;
  Self.ShapeArray := [[ObjTileArray, [1, 1, Height]]];
  Self.Filter.Walker := True;
end;

procedure TRSObject.SetupCommon(Size, Height: Double; ObjTileArray: TPointArray); overload;
begin
  Self.TileArray := ObjTileArray;
  Self.ShapeArray := [[ObjTileArray, [Size, Size, Height]]];
  Self.Filter.Walker := True;
end;

procedure TRSObject.SetupCommon(TileVector: Vector3; ObjTileArray: TPointArray); overload;
begin
  Self.TileArray := ObjTileArray;
  Self.ShapeArray := [[ObjTileArray, TileVector]];
  Self.Filter.Walker := True;
end;

procedure TRSObject.SetupCommon(Shapes: array of TRSObjectShape); overload;
var
  i: Int32;
begin
  Self.ShapeArray := Shapes;
  Self.Filter.Walker := True;

  for i := 0 to High(Shapes) do
    Self.TileArray.Extend(Shapes[i].TileArray);
end;


procedure TRSDoor.Setup(ClosedObject, OpenObject: TRSObject);
begin
  Self.Open := OpenObject;
  Self.Closed := ClosedObject;
end;



procedure TRSMMDot.SetupCommon(); override;
begin
  inherited;

  Self.ShapeArray := [[[], [1, 1, 6]]];
  Self.Filter.MinimapDot := True;
end;

procedure TRSMMDot.SetupCommon(Radius: Int32; Height: Double; ObjTileArray: TPointArray); overload;
var
  P: TPoint;
begin
  Self.TileArray := ObjTileArray;
  if Self.ShapeArray <> [] then
    Self.ShapeArray := [[ObjTileArray, [Self.ShapeArray[0].TileVector.X, Self.ShapeArray[0].TileVector.Y, Height]]]
  else
    Self.ShapeArray := [[ObjTileArray, [1, 1, Height]]];

  for P in ObjTileArray do
    Self.DotFilter.Setup([P.X, P.Y, Radius], True);

  Self.Filter.Walker := True;
end;

procedure TRSMMDot.SetupCommon(Radius: Int32; Size, Height: Double; ObjTileArray: TPointArray); overload;
var
  P: TPoint;
begin
  Self.TileArray := ObjTileArray;
  Self.ShapeArray := [[ObjTileArray, [Size, Size, Height]]];

  for P in ObjTileArray do
    Self.DotFilter.Setup([P.X, P.Y, Radius], True);

  Self.Filter.Walker := True;
end;

procedure TRSMMDot.SetupCommon(Radius: Int32; TileVector: Vector3; ObjTileArray: TPointArray); overload;
var
  P: TPoint;
begin
  Self.TileArray := ObjTileArray;
  Self.ShapeArray := [[ObjTileArray, TileVector]];

  for P in ObjTileArray do
    Self.DotFilter.Setup([P.X, P.Y, Radius], True);

  Self.Filter.Walker := True;
end;

procedure TRSMMDot.SetupCommon(Radius: Int32; Shapes: array of TRSObjectShape); overload;
var
  i: Int32;
  P: TPoint;
begin
  Self.ShapeArray := Shapes;
  Self.Filter.Walker := True;

  for i := 0 to High(Shapes) do
    Self.TileArray.Extend(Shapes[i].TileArray);

  for P in Self.TileArray do
    Self.DotFilter.Setup([P.X, P.Y, Radius], True);
end;



procedure TRSNPC.SetupCommon(); override;
begin
  inherited;

  Self.DotType := ERSMinimapDot.NPC;
end;

procedure TRSGroundItem.SetupCommon(); override;
begin
  inherited;

  Self.ShapeArray := [[[], [1, 1, 1]]];
  Self.DotType := ERSMinimapDot.ITEM;
end;

procedure TRSGroundItem.SetupCommon(ItemName: TRSItem); overload;
begin
  Self.SetupCommon;

  Self.Item := ItemName;
  Self.UpText := [ToStr(Self.Item)];
  Self.Value := ItemData.GetAverage(Self.Item);
  Self.HighAlch := ItemData.GetHighAlchProfit(Self.Item);
end;


procedure TRSPlayer.SetupCommon(); override;
begin
  inherited;

  Self.DotType := ERSMinimapDot.PLAYER;
end;

function TRSObject.GetPolys(out FloorTiles, RoofTiles: TRectArray): TPolyArray;
var
  Me: TPoint := WalkerArray[Self.WalkerIndex].GetMyPos;
  i: Int32;
begin
  for i := 0 to High(Self.ShapeArray) do
  begin
    FloorTiles.Extend(WalkerArray[Self.WalkerIndex].GetTileArrayMS(
          Me, Self.ShapeArray[i].TileArray,
          [Self.ShapeArray[i].TileVector.X, Self.ShapeArray[i].TileVector.Y, 0]));

    if Self.ShapeArray[i].TileVector.Z > 0 then
    begin
      RoofTiles.Extend(WalkerArray[Self.WalkerIndex].GetTileArrayMS(
          Me, Self.ShapeArray[i].TileArray, Self.ShapeArray[i].TileVector));

      Result := FloorTiles.GetPolys(RoofTiles);
    end
    else
      Result := FloorTiles.GetPolys;
  end;
end;

function TRSObject.GetPolys(): TPolyArray; overload;
var
  i, x: Int32;
  APA: array of TPolyArray;
begin
  for i := 0 to High(Self.ShapeArray) do
    APA += WalkerArray[Self.WalkerIndex].GetPolygonArrayMS(WalkerArray[Self.WalkerIndex].GetMyPos, Self.ShapeArray[i].TileArray,
                                      Self.ShapeArray[i].TileVector, [0, 0]);
  for i := 0 to High(APA) do
    for x := 0 to High(APA[i]) do
      Result += APA[i][x];
end;



function TRSMMDot._GetWMMPolys(out MMPoints, Dots: TPointArray; out DotFilters: TRSDotFilterArray; out Tiles, FloorTiles, RoofTiles: TRectArray): TPolyArray;
begin
  MMPoints := WalkerArray[Self.WalkerIndex].WorldToMM(Self.TileArray);
  DotFilters.ClearExpired;
  DotFilters := WalkerArray[Self.WalkerIndex].WorldToMM(Self.DotFilter);
  Dots := Minimap.GetFilteredDotArray(Self.DotType, DotFilters);

  Tiles := WalkerArray[Self.WalkerIndex].GetTileArrayMS(
                   MMPoints, [Self.ShapeArray[0].TileVector.X, Self.ShapeArray[0].TileVector.Y, 0]);

  FloorTiles := Minimap.GetTileArrayMS(Dots, [Self.ShapeArray[0].TileVector.X, Self.ShapeArray[0].TileVector.Y, 0], [-2, -2]);

  if Self.ShapeArray[0].TileVector.Z > 0 then
  begin
    RoofTiles := Minimap.GetTileArrayMS(Dots, Self.ShapeArray[0].TileVector, [-2, -2]);
    Result := FloorTiles.GetPolys(RoofTiles);
  end
  else
    Result := FloorTiles.GetPolys;
end;

function TRSMMDot._GetWPolys(out FloorTiles, RoofTiles: TRectArray): TPolyArray;
var
  Me: TPoint := WalkerArray[Self.WalkerIndex].GetMyPos;
begin
  FloorTiles := WalkerArray[Self.WalkerIndex].GetTileArrayMS(Me, Self.ShapeArray[0].TileArray,
                        [Self.ShapeArray[0].TileVector.X, Self.ShapeArray[0].TileVector.Y, 0], [0, 0]);

  if Self.ShapeArray[0].TileVector.Z > 0 then
  begin
    RoofTiles := WalkerArray[Self.WalkerIndex].GetTileArrayMS(Me, Self.ShapeArray[0].TileArray,
                                        Self.ShapeArray[0].TileVector, [0, 0]);

    Result := FloorTiles.GetPolys(RoofTiles);
  end
  else
    Result := FloorTiles.GetPolys;
end;

function TRSMMDot._GetMMPolys(out Dots: TPointArray; out FloorTiles, RoofTiles: TRectArray): TPolyArray;
begin
  Dots := Minimap.GetDots(Self.DotType);
  FloorTiles := Minimap.GetTileArrayMS(Dots,
                  [Self.ShapeArray[0].TileVector.X, Self.ShapeArray[0].TileVector.Y, 0], [-2, -2]);

  if Self.ShapeArray[0].TileVector.Z > 0 then
  begin
    RoofTiles := Minimap.GetTileArrayMS(Dots, Self.ShapeArray[0].TileVector, [-2, -2]);
    Result := FloorTiles.GetPolys(RoofTiles);
  end
  else
    Result := FloorTiles.GetPolys;
end;


function TRSMMDot.GetPolys(out MMPoints, Dots: TPointArray; out DotFilters: TRSDotFilterArray; out Tiles, FloorTiles, RoofTiles: TRectArray): TPolyArray; overload;
begin
  if Self.Filter.Walker and Self.Filter.MinimapDot then
    Result := Self._GetWMMPolys(MMPoints, Dots, DotFilters, Tiles, FloorTiles, RoofTiles)
  else if Self.Filter.Walker then
    Result := Self._GetWPolys(FloorTiles, RoofTiles)
  else if Self.Filter.MinimapDot then
    Result := Self._GetMMPolys(Dots, FloorTiles, RoofTiles);
end;

function TRSMMDot.GetPolys(): TPolyArray; overload;
var
  Dots: TPointArray;
  Expand: Double;
begin
  if Self.Filter.Walker and Self.Filter.MinimapDot then
  begin
    Dots := Minimap.GetFilteredDotArray(Self.DotType,
                    WalkerArray[Self.WalkerIndex].WorldToMM(Self.DotFilter));

    if Dots <> [] then
      Result := Minimap.GetPolygonArrayMS(Dots, Self.ShapeArray[0].TileVector, [-2, -2]);
  end

  else if Self.Filter.Walker then
  begin
    Expand := Round(
                (Self.ShapeArray[0].TileVector.Y + Self.ShapeArray[0].TileVector.X) / 2);

    Result := Minimap.GetPolygonArrayMS(
                        WalkerArray[Self.WalkerIndex].WorldToMM(Self.ShapeArray[0].TileArray),
                        [Expand, Expand, Self.ShapeArray[0].TileVector.Z]);
  end

  else if Self.Filter.MinimapDot then
  begin
    Dots := Minimap.GetDots(Self.DotType);
    if Dots <> [] then
      Result := Minimap.GetPolygonArrayMS(Dots, Self.ShapeArray[0].TileVector, [-2, -2]);
  end;
end;




function TWaspObject.GetATPA(PolyArray: TPolyArray): T2DPointArray;
var
  i: Int32;
  TPA: TPointArray;
  UnlimitedFinder: TRSObjectFinder;
begin
  if Self.Filter.Finder then
    UnlimitedFinder := Self.Finder.Unlimited;

  PolyArray := MainScreen.Filter(PolyArray);
  for i := 0 to High(PolyArray) do
  begin
    if Self.Filter.Finder then
    begin
      TPA := MainScreen.FindObject(UnlimitedFinder, PolyArray[i].Bounds).Merge;
      if TPA <> [] then
        Result += PolyArray[i].Filter(TPA);
    end
    else
    begin
      TPA := PolyArray[i].Connect;
      TPA.Fill;
      Result += TPA;
    end;
  end;
end;

function TWaspObject.FindATPA(PolyArray: TPolyArray): Boolean;
var
  i: Int32;
  UnlimitedFinder: TRSObjectFinder;
begin
  if Self.Filter.Finder then
    UnlimitedFinder := Self.Finder.Unlimited;

  PolyArray := MainScreen.Filter(PolyArray);
  for i := 0 to High(PolyArray) do
  begin
    if Self.Filter.Finder then
    begin
      if MainScreen.FindObject(UnlimitedFinder, PolyArray[i].Bounds) <> [] then
        Exit(True);
    end
    else
      Exit(True);
  end;
end;



// Searches for an object with ObjectSelf.Finder in the MainScreen with the
// help of RSWalker. Good when objects don't move and precision is needed.
function TRSObject.Find(out FloorTiles, RoofTiles: TRectArray; out PolyArray: TPolyArray; out ATPA: T2DPointArray): Boolean;
begin
  MM2MS.SetupZoom;

  if Self.Filter.Walker then
  begin
    PolyArray := Self.GetPolys(FloorTiles, RoofTiles);

    if PolyArray = [] then
      Exit(False);

    ATPA := Self.GetATPA(PolyArray);
  end

  else if Self.Filter.Finder then
    ATPA := MainScreen.FindObject(Self.Finder);

  Result := ATPA <> [];

  if Result then
    ATPA.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

//instead of calling the previous function inside this one we actually make it slightly differently.
//since we don't want to return as many parameters on this one we can improve it's performance slightly.
function TRSObject.Find(out ATPA: T2DPointArray): Boolean; overload;
var
  PolyArray: TPolyArray;
begin
  MM2MS.SetupZoom;

  if Self.Filter.Walker then
  begin
    PolyArray := Self.GetPolys();

    if PolyArray = [] then
      Exit(False);

    ATPA := Self.GetATPA(PolyArray);
  end

  else if Self.Filter.Finder then
    ATPA := MainScreen.FindObject(Self.Finder);

  Result := ATPA <> [];

  if Result then
    ATPA.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

//This one is for True or False only but performs even better because it exits on the first match.
function TRSObject.Find(): Boolean; overload;
var
  PolyArray: TPolyArray;
begin
  MM2MS.SetupZoom;

  if Self.Filter.Walker then
  begin
    PolyArray := Self.GetPolys;

    if PolyArray = [] then
      Exit(False);

    Exit(Self.FindATPA(PolyArray));
  end

  else if Self.Filter.Finder then
    Result := MainScreen.FindObject(Self.Finder) <> [];
end;


//MMDot.Find functions
function TRSMMDot.Find(out MMPoints, Dots: TPointArray; out DotFilters: TRSDotFilterArray; out Tiles, FloorTiles, RoofTiles: TRectArray; out PolyArray: TPolyArray; out ATPA: T2DPointArray): Boolean;
begin
  MM2MS.SetupZoom;

  if Self.Filter.Walker or Self.Filter.MinimapDot then
  begin
    PolyArray := Self.GetPolys(MMPoints, Dots, DotFilters,
                               Tiles, FloorTiles, RoofTiles);

    if PolyArray = [] then
      Exit(False);

    ATPA := Self.GetATPA(PolyArray);
  end

  else if Self.Filter.Finder then
    ATPA := MainScreen.FindObject(Self.Finder);

  if Result := (ATPA <> []) then
  begin
    ATPA.SortByMiddle(MainScreen.GetPlayerBox.Middle);
    if Self.WalkerIndex < 0 then
      Self.ClosestDot := WalkerArray[Self.WalkerIndex].MSToWorld(ATPA[0].Mean);
  end;
end;

function TRSMMDot.Find(out ATPA: T2DPointArray): Boolean; overload;
var
  PolyArray: TPolyArray;
begin
  MM2MS.SetupZoom;

  if Self.Filter.Walker or Self.Filter.MinimapDot then
  begin
    PolyArray := Self.GetPolys;

    if PolyArray = [] then
      Exit(False);

    ATPA := Self.GetATPA(PolyArray);
  end

  else if Self.Filter.Finder then
    ATPA := MainScreen.FindObject(Self.Finder);

  if Result := (ATPA <> []) then
  begin
    ATPA.SortByMiddle(MainScreen.GetPlayerBox.Middle);
    if Self.WalkerIndex < 0 then
      Self.ClosestDot := WalkerArray[Self.WalkerIndex].MSToWorld(ATPA[0].Mean);
  end;
end;

function TRSMMDot.Find(): Boolean; overload;
var
  PolyArray: TPolyArray;
begin
  MM2MS.SetupZoom;

  if Self.Filter.Walker or Self.Filter.MinimapDot then
  begin
    PolyArray := Self.GetPolys;

    if PolyArray = [] then
      Exit(False);

    Exit(Self.FindATPA(PolyArray));
  end

  else if Self.Filter.Finder then
    Result := MainScreen.FindObject(Self.Finder) <> [];
end;



//Debug RSObject.
procedure Debug(RSObject: TRSObject); overload;
var
  Bitmap: TMufasaBitmap;
  FloorTiles, RoofTiles: TRectArray;
  PolyArray: TPolyArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  Bitmap := TMufasaBitmap.CreateFromClient;

  RSObject.Find(FloorTiles, RoofTiles, PolyArray, ATPA);

  Bitmap.DrawATPA(ATPA);
  if ATPA <> [] then
    Bitmap.DrawTPA(ATPA[0], $000000);

  for I := 0 to High(FloorTiles) do
    Bitmap.DrawRect(FloorTiles[I], $FFFFFF);

  for I := 0 to High(RoofTiles) do
    Bitmap.DrawRect(RoofTiles[I], $FFFFFF);

  for I := 0 to High(PolyArray) do
    Bitmap.DrawTPA(PolyArray[I], $00FFFF);

  Bitmap.Show(True);
  Bitmap.Free;
end;

//Debug TRSMMDot
procedure Debug(MMDot: TRSMMDot); overload;
var
  Bitmap: TMufasaBitmap;
  MMPoints, Dots: TPointArray;
  DotFilters: TRSDotFilterArray;
  Tiles, FloorTiles, RoofTiles: TRectArray;
  PolyArray: TPolyArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  Bitmap := TMufasaBitmap.CreateFromClient;

  MMDot.Find(MMPoints, Dots, DotFilters,
             Tiles, FloorTiles, RoofTiles, PolyArray, ATPA);

  //Minimap drawing
  for I := 0 to High(MMPoints) do
    Bitmap.DrawCrosshairs(MMPoints[I], 4, 2, clBlue);

  for I := 0 to High(Dots) do
    Bitmap.DrawCrosshairs(Dots[I], 2, 1, clTeal);

  for I := 0 to High(DotFilters) do
  begin
    if DotFilters[I].HasTimer and DotFilters[I].Timer.IsFinished then
      Continue;

    if DotFilters[I].TPA <> [] then
    begin
      if DotFilters[I].Inside then
        Bitmap.DrawTPA(DotFilters[I].TPA.Connect, clLime)
      else
        Bitmap.DrawTPA(DotFilters[I].TPA.Connect, clRed);
    end;

    if DotFilters[I].Circle <> [] then
    begin
      if DotFilters[I].Inside then
        Bitmap.DrawCircle(DotFilters[I].Circle.Mean, DotFilters[I].Circle.Radius, clLime)
      else
        Bitmap.DrawCircle(DotFilters[I].Circle.Mean, DotFilters[I].Circle.Radius, clRed);
    end;
  end;

  for I := 0 to High(Tiles) do
    Bitmap.DrawRect(Tiles[I], $00FFFF);

  for I := 0 to High(FloorTiles) do
    Bitmap.DrawRect(FloorTiles[I], $FFFFFF);

  for I := 0 to High(RoofTiles) do
    Bitmap.DrawRect(RoofTiles[I], $FFFFFF);

  for I := 0 to High(PolyArray) do
    Bitmap.DrawTPA(PolyArray[I], $00FFFF);

  Bitmap.DrawATPA(ATPA);
  if ATPA <> [] then
    Bitmap.DrawTPA(ATPA[0], $000000);

  Bitmap.Show(True);
  Bitmap.Free;
end;

procedure Debug(GItem: TRSGroundItem); overload;
var
  Bitmap: TMufasaBitmap;
  MMPoints, Dots: TPointArray;
  DotFilters: TRSDotFilterArray;
  Tiles, FloorTiles, RoofTiles: TRectArray;
  PolyArray: TPolyArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  Bitmap := TMufasaBitmap.CreateFromClient;

  GItem.Find(MMPoints, Dots, DotFilters,
             Tiles, FloorTiles, RoofTiles, PolyArray, ATPA);

  //Minimap drawing
  for I := 0 to High(MMPoints) do
    Bitmap.DrawCrosshairs(MMPoints[I], 4, 2, clBlue);

  for I := 0 to High(Dots) do
    Bitmap.DrawCrosshairs(Dots[I], 2, 1, clTeal);

  for I := 0 to High(DotFilters) do
  begin
    if DotFilters[I].HasTimer and DotFilters[I].Timer.IsFinished then
      Continue;

    if DotFilters[I].TPA <> [] then
    begin
      if DotFilters[I].Inside then
        Bitmap.DrawTPA(DotFilters[I].TPA.Connect, clLime)
      else
        Bitmap.DrawTPA(DotFilters[I].TPA.Connect, clRed);
    end;

    if DotFilters[I].Circle <> [] then
    begin
      if DotFilters[I].Inside then
        Bitmap.DrawCircle(DotFilters[I].Circle.Mean, DotFilters[I].Circle.Radius, clLime)
      else
        Bitmap.DrawCircle(DotFilters[I].Circle.Mean, DotFilters[I].Circle.Radius, clRed);
    end;
  end;

  for I := 0 to High(Tiles) do
    Bitmap.DrawRect(Tiles[I], $00FFFF);

  for I := 0 to High(FloorTiles) do
    Bitmap.DrawRect(FloorTiles[I], $FFFFFF);

  for I := 0 to High(RoofTiles) do
    Bitmap.DrawRect(RoofTiles[I], $FFFFFF);

  for I := 0 to High(PolyArray) do
    Bitmap.DrawTPA(PolyArray[I], $00FFFF);

  Bitmap.DrawATPA(ATPA);
  if ATPA <> [] then
    Bitmap.DrawTPA(ATPA[0], $000000);

  Bitmap.Show(True);
  Bitmap.Free;
end;

//add object to DebugObjectArray and call SRL.Debug to use this below.
//Used to debug several objects at the same time.
procedure TRSObject.Draw(out Bitmap: TMufasaBitmap);
var
  FloorTiles, RoofTiles: TRectArray;
  PolyArray: TPolyArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  Self.Find(FloorTiles, RoofTiles, PolyArray, ATPA);

  Bitmap.DrawATPA(ATPA);
  if ATPA <> [] then
    Bitmap.DrawTPA(ATPA[0], $000000);

  for I := 0 to High(FloorTiles) do
    Bitmap.DrawRect(FloorTiles[I], $FFFFFF);

  for I := 0 to High(RoofTiles) do
    Bitmap.DrawRect(RoofTiles[I], $FFFFFF);

  for I := 0 to High(PolyArray) do
    Bitmap.DrawTPA(PolyArray[I], $00FFFF);
end;

//add object to DebugObjectArray and call SRL.Debug to use this below.
//Used to debug several objects at the same time.
procedure TRSMMDot.Draw(out Bitmap: TMufasaBitmap);
var
  MMPoints, Dots: TPointArray;
  DotFilters: TRSDotFilterArray;
  Tiles, FloorTiles, RoofTiles: TRectArray;
  PolyArray: TPolyArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  Self.Find(MMPoints, Dots, DotFilters,
             Tiles, FloorTiles, RoofTiles, PolyArray, ATPA);

  //Minimap drawing
  for I := 0 to High(MMPoints) do
    Bitmap.DrawCrosshairs(MMPoints[I], 3, 1, $FFFFFF);

  for I := 0 to High(Dots) do
    Bitmap.DrawCrosshairs(Dots[I], 3, 1, $00FFFF);

  for I := 0 to High(DotFilters) do
  begin
    if DotFilters[I].HasTimer and DotFilters[I].Timer.IsFinished then
      Continue;

    if DotFilters[I].TPA <> [] then
    begin
      if DotFilters[I].Inside then
        Bitmap.DrawTPA(DotFilters[I].TPA.Connect, clLime)
      else
        Bitmap.DrawTPA(DotFilters[I].TPA.Connect, clRed);
    end;

    if DotFilters[I].Circle <> [] then
    begin
      if DotFilters[I].Inside then
        Bitmap.DrawCircle(DotFilters[I].Circle.Mean, DotFilters[I].Circle.Radius, clLime)
      else
        Bitmap.DrawCircle(DotFilters[I].Circle.Mean, DotFilters[I].Circle.Radius, clRed);
    end;
  end;

  for I := 0 to High(Tiles) do
    Bitmap.DrawRect(Tiles[I], $00FFFF);

  for I := 0 to High(FloorTiles) do
    Bitmap.DrawRect(FloorTiles[I], $FFFFFF);

  for I := 0 to High(RoofTiles) do
    Bitmap.DrawRect(RoofTiles[I], $FFFFFF);

  for I := 0 to High(PolyArray) do
    Bitmap.DrawTPA(PolyArray[I], $00FFFF);

  Bitmap.DrawATPA(ATPA);
  if ATPA <> [] then
    Bitmap.DrawTPA(ATPA[0], $000000);
end;


// HoverHelper function used by non walking object hovering functions.
function TRSObject._HoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Self.Filter.UpText and MainScreen.IsUpText(Self.UpText) then
    Exit(True);

  for Attempt := 0 to Attempts do
  begin
    if Self.Find(ATPA) then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else if Length(ATPA) > (Attempt - 2) then
        Points := ATPA[Attempt - 2]
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Self.Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if Attempt = (Attempts - 1) then
    begin
      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// AsyncHoverHelper function used by async object hovering functions.
function TRSObject._AsyncHoverHelper: Boolean;
var
  ATPA: T2DPointArray;
begin
  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Self.Find(ATPA) then
  begin
    if ATPA[0] <> [] then
    begin
      ASyncMouse.Move(ATPA[0][Random(0, High(ATPA[0]))]);
      Exit(True);
    end;
  end;
end;


//This walker overloads are a bit messy... I need to find a cleaner way to do this later on but basically makes sure we stop trying to walk when we already
//red clicked the waspobject.
function TRSWalker.Click(MinimapPoint: TPoint; UpText: TStringArray; out RedClicked: Boolean; Randomness: Int32): Boolean; overload;
var
  P: TPoint;
  L: TPointArray;
  i, j: Int32;
  HoveringObject: Boolean;
begin
  Result := True;

  if Self.ScreenWalk then
  begin
    repeat
      i += 1;
      P := MinimapPoint.Random(-Randomness, Randomness);
      if i >= 15 then
      begin
        WriteLn 'Stuck in TRSWalker.Click infinite loop';
        L := TPAFromLine(P, Minimap.Center);
        for j := 0 to High(L) do
          if Minimap.PointInZoomRectangle(L[j]) then
          begin
            P := L[j];
            Break;
          end;
      end;
    until Minimap.PointInZoomRectangle(P);

    Mouse.Move(Minimap.PointToMsRect(P).Mean);

    HoveringObject := MainScreen.IsUpText(UpText);

    if not HoveringObject and not MainScreen.IsUpText('Walk here') then
      Exit(ChooseOption.Select('Walk here'));
  end else
  begin
    repeat
      P := MinimapPoint.Random(-Randomness, Randomness);
    until Minimap.IsPointOn(P);

    Mouse.Move(P);
  end;

  Mouse.Click(MOUSE_LEFT);

  // 15% chance of spam clicking
  if (Randomness > 0) and (Random < Antiban.GetUniqueNumber(0.15, 0.1, 0.2)) then
    for 0 to Round(Antiban.GetUniqueNumber(2, 1, 3)) do
    begin
      Mouse.Click(Mouse.Position, MOUSE_LEFT);

      Wait(20, 150, wdLeft);
    end;

  RedClicked := Self.ScreenWalk and HoveringObject and MainScreen.DidRedClick;
end;

function TRSWalker.WalkFinalStep(PlayerPoint, WorldPoint: TPoint; UpText: TStringArray; out RedClicked: Boolean; WaitUntilDistance: Int32): Boolean; overload;
var
  MinimapPoint: TPoint;
begin
  if (@Self.OnWalkEvent <> nil) then
    Self.OnWalkEvent(@Self, PlayerPoint, WorldPoint);
  if (@Self.OnWalkEventEx <> nil) then
    Self.OnWalkEventEx(@Self, PlayerPoint, WorldPoint);

  if not Self.Enabled then
    Exit(True);

  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(MinimapPoint)) then
    Exit(False);
  if (Minimap.Center.DistanceTo(MinimapPoint) < 5) then
    Exit(True);

  Result := Self.Click(MinimapPoint, UpText, RedClicked, 0);
  if Result then
    Self.WaitMoving(WorldPoint, WaitUntilDistance);
end;

function TRSWalker.WalkStep(PlayerPoint, WorldPoint: TPoint; UpText: TStringArray; out RedClicked: Boolean): Boolean; overload;
var
  MinimapPoint: TPoint;
  WaitUntilDistance: Int32;
begin
  if (@Self.OnWalkEvent <> nil) then
    Self.OnWalkEvent(@Self, PlayerPoint, WorldPoint);
  if (@Self.OnWalkEventEx <> nil) then
    Self.OnWalkEventEx(@Self, PlayerPoint, WorldPoint);

  if not Self.Enabled then
    Exit(True);

  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Minimap.GetCompassAngle(False));
  if (not Minimap.IsPointOn(MinimapPoint)) then
    Exit(False);
  if (Minimap.Center.DistanceTo(MinimapPoint) < 5) then
    Exit(True);

  Result := Self.Click(MinimapPoint, UpText, RedClicked, Self.ClickRandomness);

  if Result then
  begin
    if (Random() < 0.15) then // 15% chance of randomness else mean
      WaitUntilDistance := Random(Distance(Minimap.Center, MinimapPoint))
    else
      WaitUntilDistance := SRL.NormalRange(0, Distance(Minimap.Center, MinimapPoint) + 10);

    Self.WaitMoving(WorldPoint, WaitUntilDistance);
  end
end;

function TRSWalker.WalkPath(Path: TPointArray; UpText: TStringArray; out RedClicked: Boolean; WaitUntilDistance: Int32 = 0): Boolean; overload;

  function BuildPath(TPA: TPointArray): TPointArray;
  var
    I, J: Int32;
    Line: TPointArray;
  begin
    for I := 1 to High(TPA) do
    begin
      Line := TPAFromLine(TPA[I-1], TPA[I]);

      J := 0;
      while J < High(Line) do
      begin
        Result += Line[J];

        // keep the steps low, as mainscreen walking might just have a few tiles visible when NearZoomMode is set True
        if (Self.NearZoomMode) and ((Self.ScreenWalk) or (Self.AdaptiveWalk)) then
          Inc(J, Random(1, 4))
        else
          Inc(J, Random(3, 12));
      end;
    end;

    Result += TPA[High(TPA)];
  end;

  function AdvancePath(var Index: Int32; PlayerPoint: TPoint): Boolean;
  var
    Angle: Double := Minimap.GetCompassAngle(False);
    Previous: Int32 := Index;
    Nearest, Furthest: Int32;
  begin
    Nearest := Self.Path.IndexOf(Self.Path.Sorted(PlayerPoint)[0]);
    Self.PathIndex := Nearest;

    while (Nearest < High(Self.Path)) and (not Self.IsWalkable(Self.Path[Nearest+1], PlayerPoint, Angle)) do
      Inc(Nearest);

    Furthest := Nearest;
    while (Furthest < High(Self.Path)) and Self.IsWalkable(Self.Path[Furthest+1], PlayerPoint, Angle) do
      Inc(Furthest);

    Index := Furthest;

    // do the result check before randomness to avoid false error
    Result := (Index > Previous);

    // 15% chance of randomness else furthest
    if Random() < 0.15 then
      Index := Random(Nearest, Furthest);
  end;

var
  PlayerPoint: TPoint;
  Index, Fails: Int32;
begin
  Self.Enabled := True;
  PlayerPoint := Self.GetMyPos();
  Self.Path := BuildPath([PlayerPoint] + Path);

  if Self.AdaptiveWalk then
  begin
    Self.AdaptiveToggleDistances.X := RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.X + Random(-6,6);
    Self.AdaptiveToggleDistances.Y := RSW_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.Y + Random(-16,16);
    Self.AdaptiveWalkCheck(PlayerPoint);
  end;

  while Self.Enabled and (Fails < 10) do
  begin
    PlayerPoint := Self.GetMyPos();

    if AdvancePath(Index, PlayerPoint) then
      Fails := 0
    else
    begin
      Inc(Fails);

      // Likely haven't moved far enough to advance to next point
      if (Fails < 5) then begin
        Wait(300);
        Continue;
      end else begin
        // screen walking struggles, so disable it
        if Self.AdaptiveWalk then
          Self.ScreenWalk := False
        else if (Fails = 5) then
          case SRL.Dice(50) of
            True:  Minimap.SetCompassAngle(Minimap.GetCompassAngle() - SRL.TruncatedGauss(30, 360, 3));
            False: Minimap.SetCompassAngle(Minimap.GetCompassAngle() + SRL.TruncatedGauss(30, 360, 3));
          end;
      end;

      if (Fails mod 2 = 0) then
        Minimap.WaitFlag();
    end;

    if Index = High(Self.Path) then
    begin
      if Self.WalkFinalStep(PlayerPoint, Self.Path[Index], UpText, RedClicked, WaitUntilDistance) then
        Exit(True);
    end else
      Self.WalkStep(PlayerPoint, Self.Path[Index], UpText, RedClicked);

    if RedClicked then
      Exit(True);
  end;

  if Fails = 10 then
    Self.DebugLn('Failed to advance path');
end;

function TRSWalker.WebWalk(Destination: TPoint; UpText: TStringArray; out RedClicked: Boolean; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
var
  Path: TPointArray;
begin
  if not InRange(PathRandomness, 0, 1) then
    Self.Fatal('TRSWalker.WebWalk `PathRandomness` must be within 0..1');

  Path   := Self.WebGraph.PathBetween(Self.GetMyPos, Destination, PathRandomness);
  Result := Self.WalkPath(Path, UpText, RedClicked, WaitUntilDistance);
end;

function TRSWalker.WebWalk(Destination: TPointArray; UpText: TStringArray; out RedClicked: Boolean; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestTile(Destination), UpText, RedClicked, WaitUntilDistance, PathRandomness);
end;


// WalkHoverHelper function used by walking object hovering functions.
function TRSObject._WalkHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
  StrArray: TStringArray;
begin
  if not Self.Filter.Walker then
    Exit;

  if Self.Filter.UpText then
  begin
    if Self.ActionUpText = [] then
      StrArray := Self.UpText
    else
      StrArray := Self.ActionUpText;
  end;

  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Self.RedClicked or (Self.Filter.UpText and MainScreen.IsUpText(Self.UpText)) then
    Exit(True);

  for Attempt := 0 to Attempts do
  begin
    if Self.Find(ATPA) then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
      begin
        if Length(ATPA) > (Attempt - 2) then
          Points := ATPA[Attempt - 2]
        else
          Points := ATPA[Random(0, High(ATPA))];
      end;

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Self.Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True)
    else if not WalkerArray[Self.WalkerIndex].AtTile(Self.TileArray, 50) then
    begin
      if Self.Filter.UpText then
        WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, StrArray, Self.RedClicked, 30, 0.15)
      else
        WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, 30, 0.15);
    end
    else if Attempt = (Attempts - 1) then
    begin
      if not WalkerArray[Self.WalkerIndex].AtTile(Self.TileArray, 25) then
      begin
        if (Self.Filter.UpText and WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, StrArray, Self.RedClicked, 30, 0.15)) or
          WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, 30, 0.15) then
          Continue;
      end;

      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;


// HoverHelper function used by non walking mmdot hovering functions.
function TRSMMDot._HoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Self.Filter.UpText and MainScreen.IsUpText(Self.UpText) then
    Exit(True);

  if Self.Filter.MinimapDot and (Minimap.GetDots(Self.DotType) = []) then
    Exit;

  for Attempt := 0 to Attempts do
  begin
    if Self.Find(ATPA) then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else if Length(ATPA) > (Attempt - 2) then
        Points := ATPA[Attempt - 2]
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        if Self.DotType = ERSMinimapDot.ITEM then
          Mouse.Move(Points.Mean)
        else
          Mouse.Move(Points[Random(0, High(Points))]);

        if not Self.Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if Attempt = (Attempts - 1) then
    begin
      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// AsyncHoverHelper function used by async mmdot hovering functions.
function TRSMMDot._AsyncHoverHelper: Boolean;
var
  ATPA: T2DPointArray;
begin
  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Self.Find(ATPA) then
  begin
    if ATPA[0] <> [] then
    begin
      AsyncMouse.Move(ATPA[0][Random(0, High(ATPA[0]))]);
      Exit(True);
    end;
  end;
end;

// WalkHoverHelper function used by walking mmdot hovering functions.
function TRSMMDot._WalkHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
  StrArray: TStringArray;
begin
  if not Self.Filter.Walker then
    Exit;

  if Self.Filter.UpText then
  begin
    if Self.ActionUpText = [] then
      StrArray := Self.UpText
    else
      StrArray := Self.ActionUpText;
  end;

  if (RSClient.Mode = ERSClientMode.FIXED) and MainScreen.HasInterface then
    Exit(False);

  if Self.Filter.UpText and MainScreen.IsUpText(Self.UpText) then
    Exit(True);

  for Attempt := 0 to Attempts do
  begin
    if Self.Find(ATPA) then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
      begin
        if Length(ATPA) > (Attempt - 2) then
          Points := ATPA[Attempt - 2]
        else
          Points := ATPA[Random(0, High(ATPA))];
      end;

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Self.Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(Self.UpText) then
      Exit(True)
    else if not WalkerArray[Self.WalkerIndex].AtTile(Self.TileArray, 50) then
    begin
      if Self.Filter.UpText then
        WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, StrArray, Self.RedClicked, 30, 0.2)
      else
        WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, 30, 0.2);
    end
    else if Attempt = (Attempts - 1) then
    begin
      if not WalkerArray[Self.WalkerIndex].AtTile(Self.TileArray, 25) then
      begin
        if (Self.Filter.UpText and WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, StrArray, Self.RedClicked, 30, 0.2)) or
          WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, 30, 0.2) then
          Continue;
      end;

      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;



// ClickHelper function used by object clicking functions.
function TWaspObject._ClickHelper(LeftClick: Boolean): Boolean;
begin
  if Self.RedClicked then
  begin
    Self.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen then
  begin
    if Self.Filter.UpText and ChooseOption.Select(Self.UpText) then
      Exit(True)
    else
    begin
      ChooseOption.Close;
      Exit(False);
    end;
  end;

  if LeftClick then Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and Self.Filter.UpText and ChooseOption.Select(Self.UpText));

  if Result and SRL.Dice(0.5 - (0.5 * BioHash)) then
  begin
    case Random of
      0.000..0.899: Antiban.SmallRandomMouse;
      else Antiban.RandomMouse;
    end;
  end;
end;

// SelectHelper function used by object option selection functions.
function TWaspObject._SelectHelper(Action: TStringArray): Boolean;
begin
  if Self.RedClicked then
  begin
    Self.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen and ChooseOption.Select(Action) then
    Exit(True);

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;




// Searches for an object with TRSObject.Find and hovers it if found.
function TRSObject.Hover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if Self.Filter.Walker and not WalkerArray[Self.WalkerIndex].MakeTileVisible(Self.TileArray) then
    Exit(False);

  Result := Self._HoverHelper(Attempts);
end;

// Searches for an object with TRSObject.Find and hovers it asynchronously if found.
function TRSObject.AsyncHover: Boolean;
begin
  Result := Self._AsyncHoverHelper;
end;

// Searches for an object with TRSObject.Find, hovers and clicks it if found.
function TRSObject.Click(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._ClickHelper(LeftClick);
end;


// Searches for an object with TRSObject.Find, hovers and selects the specified action if found.
function TRSObject.SelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._SelectHelper(Action);
end;


// Searches for an object with TRSObject.Find and walker and hovers it if found.
function TRSObject.WalkHover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Self.Filter.Walker then
    Exit;

  if not WalkerArray[Self.WalkerIndex].MakeTileVisible(Self.TileArray) then
    if not WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, Self.UpText, Self.RedClicked, 30, 0.15) then
      Exit(False);

  Result := Self._WalkHoverHelper(Attempts);
end;

// Searches for an object with TRSObject.Find and walker, hovers and clicks it if found.
function TRSObject.WalkClick(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an object with TRSObject.Find and walker, hovers and selects the specified action if found.
function TRSObject.WalkSelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Self.ActionUpText := Action;
  Result := Self.WalkHover(Attempts) and
            Self._SelectHelper(Action);
end;



function TRSDoor.IsOpen(): Boolean;
begin
  Result := not Self.Closed.Find;
end;

function TRSDoor.OpenDoor(): Boolean;
begin
  if Self.IsOpen then
    Exit(True);

  WriteLn 'Opening door';

  if Self.Closed.SelectOption(['Open']) then
    Minimap.WaitMoving;

  Result := WaitUntil(Self.IsOpen, 100, 2000);
end;




// Searches for an object with TRSMMDot.Find and hovers it if found.
function TRSMMDot.Hover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if Self.Filter.Walker and not WalkerArray[Self.WalkerIndex].MakeTileVisible(Self.TileArray) then
    Exit(False);

  Result := Self._HoverHelper(Attempts);
end;

// Searches for an object with TRSMMDot.Find and hovers it asynchronously if found.
function TRSMMDot.AsyncHover: Boolean;
begin
  Result := Self._AsyncHoverHelper;
end;

// Searches for an object with TRSMMDot.Find, hovers and clicks it if found.
function TRSMMDot.Click(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an object with TRSMMDot.Find, hovers and selects the specified action if found.
function TRSMMDot.SelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._SelectHelper(Action);
end;


// Searches for an object with TRSMMDot.Find and walker and hovers it if found.
function TRSMMDot.WalkHover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Self.Filter.UpText and ChooseOption.HasOption(Self.UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Self.Filter.Walker then
    Exit;

  if not WalkerArray[Self.WalkerIndex].MakeTileVisible(Self.TileArray) then
  begin
    if (Self.Filter.UpText and not WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, Self.UpText, Self.RedClicked, 30, 0.2))or
      not WalkerArray[Self.WalkerIndex].WebWalk(Self.TileArray, 30, 0.2) then
      Exit(False);
  end;

  Result := Self._WalkHoverHelper(Attempts);
end;

// Searches for an object with TRSMMDot.Find and walker, hovers and clicks it if found.
function TRSMMDot.WalkClick(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an object with TRSMMDot.Find and walker, hovers and selects the specified action if found.
function TRSMMDot.WalkSelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Self.ActionUpText := Action;
  Result := Self.WalkHover(Attempts) and
            Self._SelectHelper(Action);
end;

var
  CurrentBank: TRSObject;
  CurrentBanker: TRSNPC;

//Extra bank opening methods using TRSObjects
function TRSBank.Hover(RSObject: TRSObject = CurrentBank): Boolean; overload;
begin
  Result := RSObject.Hover;
end;

function TRSBank.Open(RSObject: TRSObject = CurrentBank): Boolean; overload;
begin
  if MainScreen.HasInterface then
  begin
    if (Self.IsOpen() or BankPin.IsOpen()) then Exit(True)
    else MainScreen.CloseInterface();
  end;

  if RSObject.Click() or
     (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Bank B', 'Bank E'])) then
  begin
    Minimap.WaitMoving();
    Result := WaitUntil((Self.IsOpen() or BankPin.IsOpen()),
                         SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

function TRSBank.WalkHover(RSObject: TRSObject = CurrentBank): Boolean;
begin
  Result := RSObject.WalkHover;
end;

function TRSBank.WalkOpen(RSObject: TRSObject = CurrentBank): Boolean;
begin
  if MainScreen.HasInterface then
  begin
    if (Self.IsOpen or BankPin.IsOpen) then Exit(True)
    else MainScreen.CloseInterface;
  end;

  if RSObject.WalkClick or
     (MainScreen.IsUpText('Banker') and ChooseOption.Select(['Bank B', 'Bank E'])) then
  begin
    Minimap.WaitMoving;
    Result := WaitUntil((Self.IsOpen or BankPin.IsOpen),
                         SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;


//Extra bank opening methods using TRSNPCs
function TRSBank.Hover(RSNPC: TRSNPC = CurrentBanker): Boolean; overload;
begin
  Result := RSNPC.Hover;
end;

function TRSBank.Open(RSNPC: TRSNPC = CurrentBanker): Boolean; overload;
begin
  if MainScreen.HasInterface then
  begin
    if (Self.IsOpen or BankPin.IsOpen) then Exit(True)
    else MainScreen.CloseInterface;
  end;

  if RSNPC.SelectOption(['Bank B', 'Bank E']) then
  begin
    Minimap.WaitMoving;
    Result := WaitUntil((Self.IsOpen or BankPin.IsOpen),
                         SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

function TRSBank.WalkHover(RSNPC: TRSNPC = CurrentBanker): Boolean; overload;
begin
  Result := RSNPC.WalkHover;
end;

function TRSBank.WalkOpen(RSNPC: TRSNPC = CurrentBanker): Boolean; overload;
begin
  if MainScreen.HasInterface then
  begin
    if (Self.IsOpen or BankPin.IsOpen) then Exit(True)
    else MainScreen.CloseInterface;
  end;

  if RSNPC.WalkSelectOption(['Bank B', 'Bank E']) then
  begin
    Minimap.WaitMoving;
    Result := WaitUntil((Self.IsOpen or BankPin.IsOpen),
                         SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

var
  DebugObjectArray: TRSObjectArray;
  DebugNPCArray:    TRSNPCArray;
  DebugGItemArray:  TRSGroundItemArray;
  DebugPlayerArray: TRSPlayerArray;

procedure TSRL.Debug(Bitmap: TMufasaBitmap); override;
var
  DebugObject: TRSObject;
  DebugNPC:    TRSNPC;
  DebugGItem:  TRSGroundItem;
  DebugPlayer: TRSPlayer;
begin
  inherited;

  for DebugObject in DebugObjectArray do
    DebugObject.Draw(Bitmap);

  for DebugNPC in DebugNPCArray do
    DebugNPC.Draw(Bitmap);

  for DebugGItem in DebugGItemArray do
    DebugGItem.Draw(Bitmap);

  for DebugPlayer in DebugPlayerArray do
    DebugPlayer.Draw(Bitmap);
end;
