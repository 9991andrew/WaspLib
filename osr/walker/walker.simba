(*
WaspWalker and Walker extensions
================================
Methods to handle walking around OSRS.
This file expands on SRL's walker file.
*)

{$DEFINE WL_WALKER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

{.$I waspweb.graph}
{.$I agility.graph}

(*
TRSWalker.IsWalkable
~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;

Overriden to change the default behavior of TRSWalker.IsWalkable(), specifically for ScreenWalking since I don't like the default behaviour.
I find that minimap limits is extremely close to the render distance in the mainscreen, so personally I rather not
have the function bother any further if **WorldPoint** is not on the minimap.

This override will affect both TRSWalker and TRSWalker.
*)
function TRSWalker.IsWalkable(WorldPoint: TPoint; PlayerPoint: TPoint; Angle: Double): Boolean; override;
var
  MinimapPoint: TPoint;
  R: TRectangle;
begin
  MinimapPoint := Self.WorldToMM(PlayerPoint, WorldPoint, Angle);

  Result := Minimap.IsPointOn(MinimapPoint, -1);

  if Result and Self.ScreenWalk then
  begin
    R := Minimap.PointToMSRect(MinimapPoint, Angle);
    Result := MainScreen.IsVisible(R.Mean()) and (CountColor($000000, R.Bounds.Expand(0, MainScreen.Bounds)) = 0);
  end;
end;


(*
TRSWalker.AtTile
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.AtTile(WorldPoint: TPoint; Distance: Int32 = 4): Boolean;
.. pascal:: function TRSWalker.AtTile(WorldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;

Method used to quickly check if we are within distance of a certain **WorldPoint**. This distance is measure in pixels and in a radial way.
You can optionally pass in a TPA to check if the closest point is within distance.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.AtTile(WorldPoint: TPoint; Distance: Int32 = 4): Boolean;
begin
  Result := Self.GetMyPos().WithinDistance(WorldPoint, Distance);
end;

function TRSWalker.AtTile(WorldPointArray: TPointArray; Distance: Int32 = 4): Boolean; overload;
begin
  Result := Self.GetMyPos().WithinDistance(WorldPointArray, Distance);
end;



(*
TRSWalker.GetClosestPoint
~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetClosestPoint(WorldPointArray: TPointArray): TPoint;

Method used to get the closest Point to the Player out of a TPA.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.GetClosestPoint(WorldPointArray: TPointArray): TPoint;
begin
  if WorldPointArray <> [] then
    Result := WorldPointArray.Sorted(Self.GetMyPos())[0];
end;

(*
TRSWalker.WebWalk
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;

Method used to webwalk to the closest Point to the player.
An example use case is for example, if you have sevel bank booths you can use, those would be your **Destination** TPA.
You will likely want to use the closest bank booth to you, so you use this.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.WebWalk(Destination: TPointArray; WaitUntilDistance: Int32 = 0; PathRandomness: Extended = 0): Boolean; overload;
begin
  Result := Self.WebWalk(Self.GetClosestPoint(Destination), WaitUntilDistance, PathRandomness);
end;


(*
TRSWalker.WorldToMM
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
.. pascal:: function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;

Overloaded methods required for TRSDotFilter. For more information on TRSDotFilter check their documentation.

This is a TRSWalker method so it will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.WorldToMM(PlayerPoint: TPoint; WorldPoints: TPointArray; Radians: Double): TPointArray; overload;
var
  P: TPoint;
begin
  for P in WorldPoints do
    Result += Self.WorldToMM(PlayerPoint, P, Radians);
end;

function TRSWalker.WorldToMM(WorldPoints: TPointArray): TPointArray; overload;
begin
  Result := Self.WorldToMM(Self.GetMyPos(), WorldPoints, Minimap.GetCompassAngle(False));
end;

function TRSWalker.WorldToMM(DotFilter: TRSDotFilter): TRSDotFilter; overload;
var
  P: TPoint;
begin
  if DotFilter.Circle <> [] then
  begin
    P := Self.WorldToMM(DotFilter.Circle.Mean());
    Result.Circle := [P.X, P.Y, DotFilter.Circle.Radius];
  end;

  Result.TPA      := Self.WorldToMM(DotFilter.TPA);
  Result.Inside   := DotFilter.Inside;
  Result.HasTimer := DotFilter.HasTimer;
  Result.Timer    := DotFilter.Timer;
end;

function TRSWalker.WorldToMM(DotFilterArray: TRSDotFilterArray): TRSDotFilterArray; overload;
var
  DotFilter: TRSDotFilter;
begin
  for DotFilter in DotFilterArray do
    Result += Self.WorldToMM(DotFilter);
end;


(*
TRSWalker.MakePointVisible
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.MakePointVisible(P: TPoint): Boolean;
.. pascal:: function TRSWalker.MakePointVisible(TPA: TPointArray): Boolean; overload;

Wrapper function used to attempt to make a Point visible on the MainScreen.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.MakePointVisible(P: TPoint): Boolean;
begin
  Result := Minimap.MakePointVisible(Self.WorldToMM(P));
end;

function TRSWalker.MakePointVisible(TPA: TPointArray): Boolean; overload;
begin
  Result := Minimap.MakePointVisible(Self.WorldToMM(Self.GetClosestPoint(TPA)));
end;

(*
TRSWalker.GetPolygonMS
~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray;
.. pascal:: function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPointArray; overload;

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

To understand what this does, you should read about **TRSMinimap.GetTileMS()** and **TPointArray.ConvexHull()** and understand what they do.
This calls **TRSMinimap.GetPolygonMS()** internally which in turn will use both methods above.

To put it simply, this will will first calculate a floor rectangle with **TileVector.Z**, or **height** if you prefer
of 0 and then calculate the top rectangle of the **TileVector.Z** you specified.

After this 2 rectangles are calculated a polygon is then made out of the two, resulting in a ConvexHull which is returned.

This is perfect to to get an accurate bounding polygon of objects and NPCs which you can use to accurately color search after.

The example below will show you how it could be used to retrieve an accurate player bounding polygon:

Example
-------
  Debug(RSW.GetPolygonMS([100, 100], [1, 1, 4], Offset));     //This will draw a polygon around the coordinate [100, 100].
*)
function TRSWalker.GetPolygonMS(Me, Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly;
var
  Angle: Double;
begin
  Angle := Minimap.GetCompassAngle(False);
  Loc   := Self.WorldToMM(Me, Loc, Angle);

  Result := Minimap.GetPolygonMS(Loc, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonMS(Loc: TPoint; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPoly; overload;
begin
  Result := Self.GetPolygonMS(Self.GetMyPos(), Loc, TileVector, Offset);
end;


(*
TRSWalker.GetTileArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
.. pascal:: function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;

This are wrapper functions to retrieve multiple tiles. Refer to SRL's TRSWalker.GetTileMSEx() and TRSWalker.GetTileMS() for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.
*)
function TRSWalker.GetTileArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray;
var
  Loc: TPoint;
begin
  for Loc in LocArray.Sorted(Me) do
    Result += Self.GetTileMSEx(Me, Loc, TileVector, Offset);
end;

function TRSWalker.GetTileArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 0]; Offset: Vector2 = [0, 0]): TRectArray; overload;
begin
  Result := Self.GetTileArrayMS(Self.GetMyPos(), LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetPolygonArrayMS
~~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;
.. pascal:: function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): T2DPointArray;

Gives you an array of mainscreen polygons. Read **Minimap.GetPolygonMS** for more information.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

Example
-------

  TPA := Minimap.GetDots(ERSMinimapDot.Player);   //find all player dots and returns their coodinates.
  Debug(Minimap.GetPolygonArrayMS(TPA, [2, 3, 5], [2, 2])); //This will draw a polygon that is 2 by 3 tiles and height 5 in the mainscreen where each NPC is.
*)
function TRSWalker.GetPolygonArrayMS(Me: TPoint; LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray;
var
  Angle: Double;
  i: Int32;
  tmpArray: TPointArray;
begin
  Angle := Minimap.GetCompassAngle(False);
  tmpArray := Copy(LocArray);

  for i := 0 to High(tmpArray) do
    tmpArray[i] := Self.WorldToMM(Me, LocArray[i], Angle);

  Result := Minimap.GetPolygonArrayMS(tmpArray, TileVector, Offset, Angle);
end;

function TRSWalker.GetPolygonArrayMS(LocArray: TPointArray; TileVector: Vector3 = [1, 1, 4]; Offset: Vector2 = [0, 0]): TPolyArray; overload;
begin
  Result := Self.GetPolygonArrayMS(Self.GetMyPos(), LocArray, TileVector, Offset);
end;


(*
TRSWalker.GetMMPoly
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;

This function converts a list of points to their respective points in the minimap.
This is extremely useful if you want to be sure you are within an area.
To make a polygon or a polygon array easily you can use Simba/Includes/WaspLib/tools/walkerpolygon.simba.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

Example
-------
  Debug(RSW.GetMMPoly(TPA).Connect());    //This will draw your TPA on the minimap.
*)
function TRSWalker.GetMMPoly(LocArray: TPointArray): TPointArray;
begin
  Result := Self.WorldToMM(LocArray);
end;

(*
TRSWalker.InPoly
~~~~~~~~~~~~~~~~
.. pascal:: function TRSWalker.InPoly(LocArray: TPointArray): Boolean;

Checks if you are inside a polygon. If you need to debug the polygon check the example in TRSWalker.GetMMPoly.

This are TRSWalker methods so they will exist both on TRSWalker and TRSWalker.

*)
function TRSWalker.InPoly(LocArray: TPointArray): Boolean;
begin
  Result := SRL.PointInPoly(Self.GetMyPos(), LocArray);
end;

(* TODO.....
begin
  TRSMap.Setup(ZEAH_MAP, [0, 0, 3661, 3612]);
  TRSMap.Setup(MAINLAND_MAP, [3661, 33960, 10560, 5534]);

  TRSMap.Setup(SLAYER_TOWER_BASEMENT_AND_UPPERLEVEL_MAP, [4702, 0, 902+4702, 357]);
  TRSMap.Setup(SLAYER_TOWER_GROUNDFLOOR_MAP, [8931, 2044, 8931+354, 2044+358]);
  TRSMap.Setup(CHASM_OF_FIRE_MAP, [0, 0, 397, 906]);
  TRSMap.Setup(CATACOMBS_OF_KOUREND_MAP, [0, 2721, 966, 688+2721]);
  TRSMap.Setup(KARUULM_SLAYER_DUNGEON_MAP, [313, 0, 1119+313, 814]);
  TRSMap.Setup(FREMMENNIK_SLAYER_CAVE_MAP, [2348, 2903, 2348+654, 2903+530]);

  TRSMap.Setup(LUNAR_ISLAND_MAP, [4127, 1027, 4127+620, 1027+622]);
  TRSMap.Setup(ASGARNIA_ICE_DUNGEON_MAP, [5374, 1144, 6000, 1600]);
  TRSMap.Setup(SMOKE_DUNGEON_MAP, [212, 3352, 1100, 4600]);
  TRSMap.Setup(IORWERTH_DUNGEON_MAP, [3002, 2756, 3610, 2756+664]);
  TRSMap.Setup(MOURNER_TUNNELS_MAP, [7090, 5135, 7500, 5550]);

  TRSMap.Setup(CORSAIR_COVE_DUNGEON_MAP, [8923, 5104, 9500, 5550]);
  TRSMap.Setup(MOSLE_HARMLESS_CAVE_MAP, [0, 3332, 652, 648+3332]);
  TRSMap.Setup(GIANTS_DEN_MAP, [2560, 3229, 2560+388, 3229+394]);
  TRSMap.Setup(STRONGHOLD_SLAYER_DUNGEON_MAP, [3066, 5085, 3700, 5650]);
  TRSMap.Setup(KALPHITE_CAVE_MAP, [573, 3356, 1044, 3800]);
  TRSMap.Setup(KALPHITE_LAIR_MAP, [996, 3340, 996+385, 3340+351]);
  TRSMap.Setup(KRAKEN_COVE_MAP, [10147, 1006, 10560, 1414]);
  TRSMap.Setup(GRAND_EXCHANGE_MAP, [7789, 2306, 7789+557, 2306+605]);
  TRSMap.Setup(WEST_VARROCK_MAP, [7789, 2306, 7789+557, 2306+605]);
  TRSMap.Setup(WINTERTODT_MAP, [1750, 270, 2080, 830]);

  TRSMap.Setup(LUMBRIDGE_MAP, [7850, 2950, 8700, 4000]);
  TRSMap.Setup(BARBARIAN_VILLAGE_MAP, [7580, 2516, 8100, 3050]);
  TRSMap.Setup(OTTOS_GROTTO_MAP, [5201, 2030, 5810, 2700]);
  TRSMap.Setup(ZULANDRA_MAP, [3960, 4030, 4500, 4400]);
  TRSMap.Setup(PISCARILIUS_MAP, [2444, 1122, 2950, 1500]);
  TRSMap.Setup(SMOKE_DEVIL_DUNGEON_MAP, [5346, 5184, 5800, 5510]);
  TRSMap.Setup(WC_GUILD_MAP, [1564, 2293, 1564+541, 2293+349]);

  TRSMap.Setup(BRIMHAVEN_DUNGEON_MAP, [1272, 4048, 1930, 4960]);
  TRSMap.Setup(VARROCK_MAP, [7536, 2363, 8702, 3166]);
  TRSMap.Setup(ABYSS_MAP, [9670, 4424, 9670+889, 4424+914]);
  TRSMap.Setup(FALADOR_MAP, [7051, 2796, 7051+661, 2796+445]);
  TRSMap.Setup(CRAFTING_GUILD_MAP, [6990, 3206, 7261, 3465]);
  TRSMap.Setup(CRAFTING_GUILD_UPSTAIRS_MAP, [10298, 5441, 10484, 5631]);

  TRSMap.Setup(GUARDIANS_OF_THE_RIFT_MAP, [7484, 5232, 7878, 5640]);
  TRSMap.Setup(ALTARS_MAP, [6937, 0, 10559, 376]);
  TRSMap.Setup(MOTHERLOAD_MAP, [7423, 4735, 7827, 5133]);
  TRSMap.Setup(KOUREND_RUNECRAFTING_MAP, [1860, 737, 2818, 1259]);
  TRSMap.Setup(ARDOUGNE_MAP, [5608, 3032, 6184, 3476]);
  TRSMap.Setup(PRIFDDINAS_MAP, [3590, 1897, 4238, 2546]);
  TRSMap.Setup(EDGEVILLE_AND_BARBARIAN_VILLAGE_MAP, [7500, 2263, 8058, 2960]);
  TRSMap.Setup(EAST_VARROCK_MAP, [8235, 2362, 8723, 3119]);
  TRSMap.Setup(GIANTS_FOUNDRY_MAP, [4231, 3009, 4473, 3262]);
  TRSMap.Setup(HOSIDIUS_FRUIT_STALL_HOUSE_MAP, [2467, 1907, 2713, 2143]);
  TRSMap.Setup(HOSIDIUS_KITCHEN_MAP, [1988, 1873, 2251, 2118]);
  TRSMap.Setup(ROGUES_DEN_MAP, [10262, 799, 10557, 1079]);
  TRSMap.Setup(BLAST_FURNACE_MAP, [10296, 1404, 10560, 1648]);
  TRSMap.Setup(CASTLE_WARS_MAP, [4676, 3838, 5312, 4342]);
  TRSMap.Setup(AL_KHARID_MAP, [8356, 3096, 9171, 4090]);
  TRSMap.Setup(HESPORI_MAP, [412, 3702, 657, 3946]);
  TRSMap.Setup(CATHERBY_MAP, [6495, 2463, 6910, 2846]);
  TRSMap.Setup(SEERS_VILLAGE_MAP, [6050, 2360, 6536, 2754]);
  TRSMap.Setup(DRAYNOR_VILLAGE_MAP, [7596, 3267, 7976, 3654]);
  TRSMap.Setup(MINING_GUILD_MAP, [6243, 384, 6699, 792]);
  TRSMap.Setup(RIMMINGTON_MAP, [6988, 3362, 7386, 3705]);
  TRSMap.Setup(TZHAAR_MAP, [4349, 332, 5201, 980]);
  TRSMap.Setup(KBD_AND_NMZ_MAP, [5270, 264, 5623, 599]);
  TRSMap.Setup(YANILLE_MAP, [5509, 3879, 5955, 4193]);
  TRSMap.Setup(WOODCUTTING_GUILD_MAP, [1588, 2321, 2093, 2617]);
end;
*)
