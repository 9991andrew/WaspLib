(*
RSMonters
=========
Methods to handle TRSMonters.
TRSMonters are a type or TRSNPC that can be fought.
*)

{$DEFINE WL_RSMONSTER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

var
  ValueThreshold: Int32;

type
  TRSMonster = record(TRSMMDot)
    MonsterName: String;
    Hitpoints: Int32;
    MaxHit: Int32;
    AttackTypes: array of ERSMonsterAttackType;
    Drops: array of TRSMonsterDrop;
    GoodDrops: TRSItemArray;
    LootGItem: TRSGroundItem;
  end;

  TRSMonsterArray = array of TRSMonster;
  PRSMonster = ^TRSMonster;
  PRSMonsterArray = array of PRSMonster;



procedure TRSMonster.SetupCommon(Name: String); overload;
var
  Size: Int32;
begin
  MonsterName := Name;

  Self.SetupCommon;

  DotType := ERSMinimapDot.NPC;

  Name := Name.Lower;
  Name[1] := UpperCase(Name[1])[1];

  UpText += Name;

  Hitpoints := MonsterData.GetInt(Name, 'hitpoints');
  MaxHit := MonsterData.GetInt(Name, 'max_hit');
  Size := MonsterData.GetInt(Name, 'size');
  if Size = 1 then
    ShapeArray := [[[], [1, 1, 0]]]
  else
    ShapeArray := [[[], [Size/2, Size/2, 0]]];
  AttackTypes := MonsterData.GetAttackTypes(Name);
end;

procedure TRSMonster.SetupDrops;
var
  i: Int32;
begin
  GoodDrops := [];
  LootGItem := [];

  LootGItem.SetupCommon;
  LootGItem.Filter.Finder := False;

  Drops := MonsterData.GetDrops(MonsterName);

  for i := 0 to High(Drops) do
  begin
    if Drops[i].Noted and
      ((ItemData.GetAverage(Drops[i].ID) * Drops[i].Quantity) >= (ValueThreshold/5)) then
    begin
      GoodDrops += Drops[i].Item;
      LootGItem.Item +=  'noted ' + Drops[i].Item;
      LootGItem.UpText += Drops[i].Item;
    end
    else if Drops[i].Stackable and
      ((ItemData.GetAverage(Drops[i].ID) * Drops[i].Quantity) >= (ValueThreshold/5)) or
      (ItemData.GetHighAlch(Drops[i].ID) > 500) or
      (ItemData.GetAverage(Drops[i].ID) >= ValueThreshold) then
    begin
      GoodDrops += Drops[i].Item;
      LootGItem.Item += Drops[i].Item;
      LootGItem.UpText += Drops[i].Item;
    end;
  end;
end;


function TRSMonster.Attack: Boolean;
begin
  if Self.SelectOption(['Attack']) then
  begin
    Minimap.WaitMoving;
    Result := MainScreen.InCombat;
  end;
end;

function TRSMonster.WalkAttack: Boolean;
begin
  if Self.WalkSelectOption(['Attack']) then
  begin
    Minimap.WaitMoving;
    Result := MainScreen.InCombat;
  end;
end;


function TRSMonster._HandleLooting: Boolean;
var
  i: Int32;
  ItemStr: String;

begin
  if not MainScreen.IsUpText('Take') then
    Exit;

  ChooseOption.Open;

  if not ChooseOption.HasOption(LootGItem.UpText) then Exit;
  Result := ChooseOption.Select(LootGItem.UpText);
  (*
  for i := 0 to High(LootGItem.UpText) do
  begin
    ItemStr := LootGItem.UpText[i];

    if not ChooseOption.HasOption(ItemStr, True, False) then
      Continue;

    if Inventory.IsFull then
    begin
      WriteLn ItemStr;
      if Drops[i].Stackable then
      begin
        if Drops[i].Noted then
          ItemStr := 'noted ' + ItemStr;

        if Inventory.FindItem(ItemStr) then
          Exit(ChooseOption.Select(LootGItem.UpText[i], MOUSE_LEFT, False));
      end

      //ELSE IF ALCH! TODO!

      else if Inventory.FindConsumable(ERSConsumable.HEALTH_CONSUMABLE) then
      begin
        Inventory.Consume(ERSConsumable.HEALTH_CONSUMABLE);
        Exit;
      end;
    end;

    Exit(ChooseOption.Select(ItemStr, MOUSE_LEFT, False));
  end;
  *)
end;

function TRSMonster.CheckLoot(P: TPoint): Boolean;
begin
  Mouse.Move(P);

  Result := Self._HandleLooting;
end;

function TRSMonster.CheckLoot(B: TBox): Boolean; overload;
begin
  Mouse.Move(B);

  Result := Self._HandleLooting;
end;

//Debug TRSMonster
procedure Debug(Monster: TRSMonster); overload;
var
  Bitmap: TMufasaBitmap;
  MMPoints, Dots: TPointArray;
  Radiuses: TCircleArray;
  Tiles, FloorTiles, RoofTiles: TRectArray;
  PolyArray: TPolyArray;
  ATPA: T2DPointArray;
  I: Int32;
begin
  Bitmap.FromClient;

  Monster.Find(MMPoints, Dots, Radiuses,
             Tiles, FloorTiles, RoofTiles, PolyArray, ATPA);

  //Minimap drawing
  for I := 0 to High(MMPoints) do
    Bitmap.DrawCrosshairs(MMPoints[I], 4, clBlue);

  for I := 0 to High(Dots) do
    Bitmap.DrawCrosshairs(Dots[I], 2, clTeal);

  for I := 0 to High(Radiuses) do
    Bitmap.DrawCircle(Radiuses[I].Mean, Radiuses[I].Radius, clLime);

  for I := 0 to High(Tiles) do
    Bitmap.DrawRect(Tiles[I], $00FFFF);

  for I := 0 to High(FloorTiles) do
    Bitmap.DrawRect(FloorTiles[I], $FFFFFF);

  for I := 0 to High(RoofTiles) do
    Bitmap.DrawRect(RoofTiles[I], $FFFFFF);

  for I := 0 to High(PolyArray) do
    Bitmap.DrawPoly(PolyArray[I], $00FFFF);

  for I := 0 to High(ATPA) do
  begin
    if I = 0 then
      Bitmap.DrawTPA(ATPA[0], $0A0A0A) //Closest object will be painted black.
    else
      Bitmap.DrawTPA(ATPA[I], DEBUG_COLORS[I mod Length(DEBUG_COLORS)]);
  end;

  Bitmap.Debug;
  Bitmap.Free;
end;

