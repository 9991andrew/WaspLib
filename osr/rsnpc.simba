{$DEFINE WL_RSNPC_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

type
  PRSNPC = ^TRSNPC;

  TRSNPC = record
    Map: PRSWalker;
    Tiles: TPointArray;
    WanderRadius: Int32;
    Height: Int32;
    Finder: TRSObjectFinder;
    UpText: TStringArray;
    Filter: record
      Walker: Boolean;
      Minimap: Boolean;
      Finder: Boolean;
      UpText: Boolean;
    end;
  end;

  TRSNPCArray = array of TRSNPC;

procedure TRSNPC.SetupCommon(Radius: Int32 = 1; NPCHeight: Int32 = 6);
begin
  WanderRadius := Radius;
  Height := NPCHeight;
  Finder.ClusterDistance := 3;
  Finder.Erode := 2;
  Finder.Grow := 4;

  Filter.Minimap := True;
  Filter.Finder  := True;
  Filter.UpText  := True;
end;



function TRSNPC.Find: T2DPointArray;
  function GetWalkerTilesRects: TRectArray;
  var
    Tile: TPoint;
    MMTiles: TPointArray;
    FilteredMMTiles: TPointArray;
    Dot: TPoint;
    Dots: TPointArray;
    FilteredDots: TPointArray;
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    for Tile in Tiles do
    begin
      if not Map^.TileVisible(Tile) then
        Continue; //Skips tiles out of view)
      MMTiles += Map^.WorldToMM(Tile);
    end;

    for Tile in MMTiles do
      if Minimap.IsPointOn(Tile, WanderRadius) then
        FilteredMMTiles += Tile;

    if FilteredMMTiles = [] then
      Exit;

    Dots := Minimap.GetDots(ERSMinimapDot.NPC);

    for Dot in Dots do
      for Tile in FilteredMMTiles do
        if SRL.PointInCircle(Dot, Tile, WanderRadius * 5) then
          FilteredDots += Dot;

    if FilteredDots = [] then
      Exit;

    FilteredDots.ClearDuplicates;

    for Dot in FilteredDots do
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Result += Rect;
    end;
  end;

  function GetTilesRects: TRectArray;
  var
    Dot: TPoint;
    Dots: TPointArray;
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    Dots := Minimap.GetDots(ERSMinimapDot.NPC);

    if Dots = [] then
      Exit;

    for Dot in Dots do
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Result += Rect;
    end;
  end;

var
  Rect: TRectangle;
  Rects: TRectArray;
  B: TBox;
  TPA: TPointArray;
  NPCFinder: TRSObjectFinder;
begin

  if Filter.Walker then
  begin
    Rects := GetWalkerTilesRects;
    if Filter.Finder then
    begin
      NPCFinder := Finder;
      NPCFinder.MinLongSide := 0;
      NPCFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(NPCFinder, B).Merge;
          if TPA <> [] then
            Result += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          Result += TPA;
        end;
      end;
    end;
  end

  else if Filter.Minimap then
  begin
    Rects := GetTilesRects;
    if Filter.Finder then
    begin
      NPCFinder := Finder;
      NPCFinder.MinLongSide := 0;
      NPCFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(NPCFinder, B).Merge;
          if TPA <> [] then
            Result += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          Result += TPA;
        end;
      end;
    end;
  end

  else if Filter.Finder then
    Result := MainScreen.FindObject(Finder);

  if Result = [] then
    Exit;

  Result.SortByMiddle(MainScreen.GetPlayerBox.Middle);
end;

procedure TRSNPC.Debug;
  function GetWalkerTilesRects(out Bitmap: TMufasaBitmap): TRectArray;
  var
    Tile: TPoint;
    MMTiles: TPointArray;
    FilteredMMTiles: TPointArray;
    Dot: TPoint;
    Dots: TPointArray;
    FilteredDots: TPointArray;
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    for Tile in Tiles do
    begin
      if not Map^.TileVisible(Tile) then
        Continue; //Skips tiles out of view)
      MMTiles += Map^.WorldToMM(Tile);
    end;

    for Tile in MMTiles do
      if Minimap.IsPointOn(Tile, WanderRadius) then
        FilteredMMTiles += Tile;

    if FilteredMMTiles = [] then
      Exit;

    Dots := Minimap.GetDots(ERSMinimapDot.NPC);

    for Dot in Dots do
      for Tile in FilteredMMTiles do
        if SRL.PointInCircle(Dot, Tile, WanderRadius * 5) then
          FilteredDots += Dot;

    if FilteredDots = [] then
      Exit;

    FilteredDots.ClearDuplicates;

    for Dot in FilteredDots do
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
      Bitmap.DrawRect(Rect, $ffffff);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
        Bitmap.DrawRect(Rect, $ffffff);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Bitmap.DrawRect(Rect, $0000ff);
      Result += Rect;
    end;
  end;

  function GetTilesRects(out Bitmap: TMufasaBitmap): TRectArray;
  var
    Dot: TPoint;
    Dots: TPointArray;
    Rect: TRectangle;
    HighTPA: TPointArray;
    LowTPA: TPointArray;
    TPA: TPointArray;
  begin
    Dots := Minimap.GetDots(ERSMinimapDot.NPC);

    if Dots = [] then
      Exit;

    for Dot in Dots do
    begin
      Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, Height]);
      Bitmap.DrawRect(Rect, $ffffff);
      HighTPA := Rect.ToTPA;

      if Height > 0 then
      begin
        Rect := Minimap.VecToMSRect([Dot.X+2, Dot.Y+2, 0]);
        Bitmap.DrawRect(Rect, $ffffff);
        LowTPA := Rect.ToTPA;
        TPA := HighTPA.Combine(LowTPA);
        TPA.ClearDuplicates;
      end
      else
        TPA := HighTPA;

      Rect := TPA.MinAreaRect;
      Bitmap.DrawRect(Rect, $0000ff);
      Result += Rect;
    end;
  end;

var
  Bitmap: TMufasaBitmap;
  Rect: TRectangle;
  Rects: TRectArray;
  B: TBox;
  TPA: TPointArray;
  NPCFinder: TRSObjectFinder;
  NPC: T2DPointArray;
begin
  Bitmap.FromClient(MainScreen.Bounds);

  if Filter.Walker then
  begin
    Rects := GetWalkerTilesRects(Bitmap);
    if Filter.Finder then
    begin
      NPCFinder := Finder;
      NPCFinder.MinLongSide := 0;
      NPCFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(NPCFinder, B).Merge;
          if TPA <> [] then
            NPC += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          NPC += TPA;
        end;
      end;
    end;
  end

  else if Filter.Minimap then
  begin
    Rects := GetTilesRects(Bitmap);
    if Filter.Finder then
    begin
      NPCFinder := Finder;
      NPCFinder.MinLongSide := 0;
      NPCFinder.MinShortSide := 0;
    end;

    for Rect in Rects do
    begin
      B := Rect.Bounds;

      if InterfaceArea.Bounds.Contains(Rect) then
      begin
        if Filter.Finder then
        begin
          TPA := MainScreen.FindObject(NPCFinder, B).Merge;
          if TPA <> [] then
            NPC += Rect.Filter(TPA);
        end
        else
        begin
          TPA := Rect.ToTPA.Connect;
          TPA.Fill;
          NPC += TPA;
        end;
      end;
    end;
  end


  else if Filter.Finder then
    NPC := MainScreen.FindObject(Finder);

  if NPC = [] then
  begin
    Bitmap.Free;
    Exit;
  end;

  NPC.SortByMiddle(MainScreen.GetPlayerBox.Middle);

  Bitmap.DrawATPA(NPC);
  Bitmap.DrawTPA(NPC[0], $000000);

  ShowBitmap(Bitmap);
  Bitmap.Free;
end;


// HoverHelper function used by non walking NPC hovering functions.
function TRSNPC._HoverHelper(Attempts: Int32): Boolean; overload;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  for Attempt := 0 to Attempts do
  begin
    if Filter.UpText and MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True);

    //will rotate the screen for the last attempt if hasn't hovered properly yet
    if Attempt = (Attempts - 1) then
    begin
      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// WalkHoverHelper function used by walking NPC hovering functions.
function TRSNPC._WalkHoverHelper(Attempts: Int32): Boolean;
var
  Attempt: Int32;
  ATPA: T2DPointArray;
  Points: TPointArray;
  CompassAngle: Double;
begin
  if not Filter.Walker then
    Exit;

  for Attempt := 0 to Attempts do
  begin
    if InterfaceArea.HasInterface() then
      Exit(False);

    if Filter.UpText and MainScreen.IsUpText(UpText) then
      Exit(True);

    if (ATPA := Self.Find) <> [] then
    begin
      if Attempt < 2 then
        Points := ATPA[0] // 0 for the closest one.
      else
        Points := ATPA[Random(0, High(ATPA))];

      if Points <> [] then
      begin
        Mouse.Move(Points[Random(0, High(Points))]);
        if not Filter.UpText then
          Exit(True);
      end;
    end;

    if MainScreen.IsUpText(UpText) then
      Exit(True)
    else if not Map^.AtTile(Tiles, 50) then
      Map^.WebWalk(Map^.GetClosestTile(Tiles), 10, 0.2)
    else if Attempt = (Attempts - 1) then
    begin
      if not Map^.AtTile(Tiles, 30) and Map^.WebWalk(Map^.GetClosestTile(Tiles), 10, 0.2) then
        Continue;

      CompassAngle := Minimap.GetCompassAngle;
      CompassAngle += Random(-50, 50);
      Minimap.SetCompassAngle(CompassAngle, 10);
    end;
  end;
end;

// ClickHelper function used by NPC clicking functions.
function TRSNPC._ClickHelper(LeftClick: Boolean): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.Select(UpText) then
      Exit(True)
    else
    begin
      ChooseOption.Close;
      Exit;
    end;
  end;

  if LeftClick then
    Mouse.Click(MOUSE_LEFT);

  Result := MainScreen.DidRedClick or
            (not LeftClick and Filter.UpText and ChooseOption.Select(UpText));
end;

// SelectHelper function used by NPC option selection functions.
function TRSNPC._SelectHelper(Action: TStringArray): Boolean;
begin
  if ChooseOption.IsOpen and ChooseOption.Select(Action) then
    Exit(True);

  if MainScreen.IsUpText(Action) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Result := MainScreen.DidRedClick;
  end
  else
    Result := ChooseOption.Select(Action);
end;




// Searches for an NPC with TRSNPC.Find.
function TRSNPC.Hover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if Filter.Walker and not Map^.MakeTileVisible(Tiles) then
    Exit(False);

  Result := Self._HoverHelper(Attempts);
end;

// Searches for an NPC with TRSNPC.Find, hovers and clicks it if found.
function TRSNPC.Click(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an NPC with TRSNPC.Find, hovers and selects the specified action if found.
function TRSNPC.SelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.Hover(Attempts) and
            Self._SelectHelper(Action);
end;




// Searches for an NPC with TRSNPC.Find and walker.
function TRSNPC.WalkHover(Attempts: Int32 = 2): Boolean;
begin
  if ChooseOption.IsOpen then
  begin
    if Filter.UpText and ChooseOption.HasOption(UpText) then
      Exit(True);
    ChooseOption.Close;
  end;

  if not Filter.Walker then
    Exit;

  if not Map^.MakeTileVisible(Tiles) then
    if not Map^.WebWalk(Map^.GetClosestTile(Tiles), 30, 0.2) then
      Exit(False);

  Result := Self._WalkHoverHelper(Attempts);
end;

// Searches for an NPC with TRSNPC.Find and walker, hovers and clicks it if found.
function TRSNPC.WalkClick(LeftClick: Boolean = True; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._ClickHelper(LeftClick);
end;

// Searches for an NPC with TRSNPC.Find and walker, hovers and selects the specified action if found.
function TRSNPC.WalkSelectOption(Action: TStringArray; Attempts: Int32 = 2): Boolean;
begin
  Result := Self.WalkHover(Attempts) and
            Self._SelectHelper(Action);
end;
