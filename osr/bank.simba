{$DEFINE WL_BANK_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

//SHOULD ADD TO SRL
function TRSBank.GetTabBox(Tab: Int32): TBox;
var
  Tabs: TBoxArray := Self.GetTabBoxes();
begin
  if (Tab >= 0) and (Tab <= Length(Tabs)) then
    Result := Tabs[Tab];
end;

//SHOULD ADD TO SRL
function TRSBank.CountTabs: Int32;
var
  i: Integer;
  TPA: TPointArray;
begin
  Result := 0;

  for i := 9 downto 1 do
    if SRL.FindColors(TPA, CTS0(65536), Self.GetTabBox(i)) > 0 then
      Exit(i);
end;

//SHOULD ADD TO SRL
function TRSBank.GetCurrentTab: Int32;
var
  Tabs: TBoxArray := Self.GetTabBoxes;
  Tab: TBox;
  i: Int32;
begin
  for i := 0 to High(Tabs) do
  begin
    Tab := Tabs[i];
    Tab.Y2 +=1;
    if SRL.CountColor(CTS1(5334129, 0), Tab) = 0 then
      Exit(i);
  end;
end;

//SHOULD ADD TO SRL
function TRSBank.OpenTab(Tab: Int32): Boolean;
var
  TabBox: TBox;
begin
  if not Self.IsOpen then
    Exit;

  if Tab = Self.GetCurrentTab then
    Exit(True);

  TabBox := Self.GetTabBox(Tab);
  if TabBox <> [] then
  begin
    Mouse.Click(TabBox, MOUSE_LEFT);
    Result := WaitUntil((Tab = Self.GetCurrentTab), 100, 2000);
  end;
end;

//SHOULD ADD TO SRL
function TRSBank._FindWintertodt: T2DPointArray;
var
  Finder: TRSObjectFinder;
begin
  Finder.ColorClusters += [
    CTS2(3289384, 4, 0.51, 0.37),  //Dark hole
    CTS2(13025214, 17, 0.13, 0.11), //Snow color
    10
  ];

  Finder.ClusterDistance := 2;
  Finder.Grow := 3;
  Finder.Erode := 2;

  Result := MainScreen.FindObject(Finder);
  if Length(Result) = 0 then
    Exit;
  Result.SortByLongSide();
  Result := Result[0].Cluster(3);
  Result.SortByMiddle(Result.Merge.Mean());
end;


//NORMAL CODE FROM HERE -----------------------------------------

function TRSBank.HasItem(Item: TRSItem): Boolean;
var
  Box: TBox;
begin
  Result := Bank.FindItem(Item, Box);
end;

function TRSBank.HasItem(Item: TRSBankWithdrawItem): Boolean; overload;
begin
  Result := Self.HasItem(Item.Item);
end;

function TRSBank.HasItem(BankTab: Int32; Item: TRSItem): Boolean; overload;
begin
  if Self.OpenTab(BankTab) then
    Result := Self.HasItem(Item);
end;

function TRSBank.HasItem(BankTab: Int32; Item: TRSBankWithdrawItem): Boolean; overload;
begin
  if Self.OpenTab(BankTab) then
    Result := Self.HasItem(Item);
end;


function TRSBank._SimplifyItemName(Item: TRSItem): String;
var
  ItemStr: String := ToStr(Item);
  MaxLength, MinLength: Int32;
begin
  ItemStr := ItemStr.Before('(');
  ItemStr := ItemStr.Lower;
  MaxLength := ItemStr.Len;
  MinLength := MaxLength - Round(MaxLength/3);

  Result := Copy(ItemStr, 0, Random(MinLength, MaxLength));
end;

(*
 Possibly too custom to belong in SRL?

 Searches for an item "simplified name" and if found
 returns the tab it's on.

 Assuming someone as all the items a script needs in one tab
 this can be used to find it and it can be stored in a variable.

 SearchBox is a TBox of where the Tab text shows up.
*)
function TRSBank.FindItemTab(Item: TRSItem; OpenTab: Boolean = True): Int32;
var
  Box, SearchBox: TBox;
  TPA: TPointArray;
  TabsText: T2DPointArray;
begin
  if Self.FindItem(Item, Box) then
    Exit(Self.GetCurrentTab);

  if not Self.Search(Self._SimplifyItemName(Item)) or not Self.FindItem(Item, Box) then
    Exit(-1);

  SearchBox := [
    Self.X1 + 40,
    Self.Y1,
    Self.X1 + 90,
    Box.Y1
  ];

  if SRL.FindColors(TPA, CTS0(10672356, 0), SearchBox) > 0 then
    TabsText += TPA;
  if SRL.FindColors(TPA, CTS0(16777215, 0), SearchBox) > 0 then
    TabsText += TPA;

  if TabsText = [] then //if we can see the item at this point
  begin                 //and there's no tab text, it's in tab0
    if OpenTab then
      Self.OpenTab(0);
    Exit(0);
  end;

  TPA := TabsText.Merge();
  TPA.SortByY(False);

  TPA := TPA.Cluster(15)[0];
  TPA.SortByX(False);

  TPA := TPA.Cluster(1)[0];

  Result := OCR.RecognizeNumber(TPA.Bounds, [10672356], RS_FONT_PLAIN_11);
  if Result = 0 then
    Result := OCR.RecognizeNumber(TPA.Bounds, [16777215], RS_FONT_PLAIN_11);

  if (Result > 0) and OpenTab then
    Self.OpenTab(Result);
end;


function TRSBank.WithdrawItem(Tab: Int32; Item: TRSBankWithdrawItem; UseQuantityButtons: Boolean): Boolean; overload;
var
  ItemCount: Int32;
begin
  if not Self.IsOpen then
    Exit;
  if Inventory.IsFull and not Inventory.ItemIsStackable(Item.Item) then
    Exit;

  if not Self.HasItem(Item) then
  begin
    if Tab = -1 then
      Self.FindItemTab(Item.Item)
    else
      Self.OpenTab(Tab);

    if not Self.HasItem(Item) then
      Exit(False);
  end;

  ItemCount := Self.CountItemStack(Item.Item);
  if Self.WithdrawItem(Item, UseQuantityButtons) then
    Result := WaitUntil((Self.CountItemStack(Item.Item) < ItemCount), 50, 2000);
end;

function TRSBank.DepositItem(Tab: Int32; Item: TRSBankDepositItem; UseQuantityButtons: Boolean): Boolean; overload;
var
  IsStackable: Boolean;
  ItemCount: Int32;
begin
  if not Bank.IsOpen then
    Exit;

  if IsStackable := Inventory.ItemIsStackable(Item.Item) then
    ItemCount := Inventory.CountItemStack(Item.Item)
  else
    ItemCount := Inventory.CountItem(Item.Item);

  if Tab > -1 then
    Bank.OpenTab(Tab);

  if Bank.DepositItem(Item, UseQuantityButtons) then
  begin
    if IsStackable then
      Result := WaitUntil((Inventory.CountItemStack(Item.Item) <> ItemCount), 50, 2000)
    else
      Result := WaitUntil((Inventory.CountItem(Item.Item) <> ItemCount), 50, 2000);
  end;
end;



//WALKER BASED INTERACTION WITH BANK-----------------------------------

// Tries to open a bank with the specified Color at the specified Tile.
// Returns true if bank or bankpin is open.
function TRSWalker.OpenBank(Tile: TPoint; Color: TCTS2Color): Boolean;
begin
  if Self.ClickRSObject(Tile, Color, ['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((Bank.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 3000);
  end;
end;

// Same as above for multiple tiles.
function TRSWalker.OpenBank(Tiles: TPointArray; Color: TCTS2Color): Boolean; overload;
begin
  if Self.ClickRSObject(Tiles, Color, ['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((Bank.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Walks to the object, and tries to do the same as above while walking.
function TRSWalker.WalkOpenBank(Tile: TPoint; Color: TCTS2Color): Boolean;
begin
  if Self.WalkClickRSObject(Tile, Color, ['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((Bank.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Same as above for multiple tiles.
function TRSWalker.WalkOpenBank(Tiles: TPointArray; Color: TCTS2Color): Boolean; overload
begin
  if Self.WalkClickRSObject(Tiles, Color, ['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((Bank.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;


// Tries to open the collect box at bank with the specified Color at the specified Tile.
// Returns true if collect box is open.
function TRSWalker.OpenCollectBox(Tile: TPoint; Color: TCTS2Color): Boolean;
begin
  if Self.SelectRSObjectOption(Tile, Color, ['Collect'],['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((CollectBox.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Same as above for multiple tiles.
function TRSWalker.OpenCollectBox(Tiles: TPointArray; Color: TCTS2Color): Boolean; overload;
begin
  if Self.SelectRSObjectOption(Tiles, Color, ['Collect'],['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((CollectBox.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Walks to the object, and tries to do the same as above while walking.
function TRSWalker.WalkOpenCollectBox(Tile: TPoint; Color: TCTS2Color): Boolean;
begin
  if Self.WalkSelectRSObjectOption(Tile, Color, ['Collect'],['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((CollectBox.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Same as above for multiple tiles.
function TRSWalker.WalkOpenCollectBox(Tiles: TPointArray; Color: TCTS2Color): Boolean; overload;
begin
  if Self.WalkSelectRSObjectOption(Tiles, Color, ['Collect'],['Bank', 'booth', 'chest']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((CollectBox.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;


// Tries to open GE
function TRSWalker.OpenGE(South: Boolean): Boolean;
var
  Tiles: TPointArray;
begin
  if South then
    Tiles := WorldObjects.Tiles.GESouth
  else
    Tiles := WorldObjects.Tiles.GENorth;

  if Self.ClickRSObject(Tiles, WorldObjects.Colors.GEStructure, ['Exchange', 'Grand', 'booth']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((GrandExchange.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Tries to open GE with less info
function TRSWalker.OpenGE: Boolean; overload;
begin
  if Self.ClickRSObject(Self.GetClosestTile(WorldObjects.Tiles.GEExchange), WorldObjects.Colors.GEStructure, ['Exchange', 'Grand', 'booth']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((GrandExchange.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Walks to GE and attempts to open it while walking.
function TRSWalker.WalkOpenGE(South: Boolean): Boolean;
var
  Tiles: TPointArray;
begin
  if South then
    Tiles := WorldObjects.Tiles.GESouth
  else
    Tiles := WorldObjects.Tiles.GENorth;

  if Self.WalkClickRSObject(Tiles, WorldObjects.Colors.GEStructure, ['Exchange', 'Grand', 'booth']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((GrandExchange.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;

// Walks to GE and attempts to open it while walking with less info.
function TRSWalker.WalkOpenGE: Boolean; overload;
begin
  if Self.WalkClickRSObject(Self.GetClosestTile(WorldObjects.Tiles.GEExchange), WorldObjects.Colors.GEStructure, ['Exchange', 'Grand', 'booth']) then
  begin
    Minimap.WaitPlayerMoving(300, 5000);
    Result := WaitUntil((GrandExchange.IsOpen or BankPin.IsOpen), SRL.TruncatedGauss(50, 1500), 1000);
  end;
end;



