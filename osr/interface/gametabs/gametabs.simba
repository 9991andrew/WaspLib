(*
Keybindings
===========
Methods to interact with gametabs via FKeys.
*)

{$DEFINE WL_GAMETABS_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
const DEFAULT_FKEYS
~~~~~~~~~~~~~~~~~~~
  Global DEFAULT_FKEYS constant.

*)
const
  DEFAULT_FKEYS = [
    VK_ESCAPE,
    VK_F1,
    VK_F2,
    VK_F3,
    VK_F4,
    VK_F5,
    VK_F6,
    VK_F7,
    VK_F8,
    VK_F9,
    VK_F10,
    VK_F11,
    VK_F12
  ];

type
(*
type TRSKeyTabPair
~~~~~~~~~~~~~~~~~~

TRSKeyTabPair is a record to represent a single pair of gametab/FKey.
*)

  TRSKeyTabPair = record
    IsSetup: Boolean;
    Tab: ERSGameTab;
    Key: UInt32;
  end;

(*
type TRSKeybindings
~~~~~~~~~~~~~~~~~~~

TRSKeybindings is a record used to:
  - enable/disable the use of keybinds.
  - store our already setup KeyTabPair.
  - figure out which keybinds we have setup if we don't preset them.
  - manage keys we don't know their match yet.
*)
  TRSKeybindings = record
    UseKeybinds: Boolean;
    KeyTabPairs: array of TRSKeyTabPair;
    UncheckedKeyArray: TIntegerArray;
  end;

(*
KeyTabPair.Setup
~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSKeyTabPair.Setup(Gametab: ERSGameTab);

Sets up a single FKey/Gametab pair.

Example
-------

  var
    KeyTabPair: TRSKeyTabPair;

  begin
    KeyTabPair.Setup(ERSGameTab.COMBAT);
  end;
*)
procedure TRSKeyTabPair.Setup(Gametab: ERSGameTab);
begin
  if IsSetup then Exit;
  Tab := Gametab;
  IsSetup := True;
end;

(*
Keybindings.Setup
~~~~~~~~~~~~~~~~~
.. pascal:: procedure TRSKeybindings.Setup(Keys: TIntegerArray = DEFAULT_FKEYS);

**Keybindings.Setup** is a procedure that is used to setup it's internal variables so it's ready to use.
By default it's called with **SRL.Setup** but can be called again with a TIntegerArray argument as a preset.

Note: This array of ints should be the **VK_** constants built into Simba that represent FKeys.

Example
-------

  Keybindings.Setup([
    VK_F1, VK_ESCAPE, VK_F2, VK_F10, VK_F4, VK_F9, VK_F6,
    VK_F7, VK_F8, VK_F5, VK_F3
  ]);
*)
procedure TRSKeybindings.Setup(Keys: TIntegerArray = DEFAULT_FKEYS);
var
  i: Int32;
begin
  Self := []; //Reset itself in case setup is called again.
  UncheckedKeyArray := Keys;

  SetLength(KeyTabPairs, Length(UncheckedKeyArray));

  for i := 0 to High(UncheckedKeyArray) do
  begin
    KeyTabPairs[i].Key := UncheckedKeyArray[i];
    KeyTabPairs[i].Tab := ERSGameTab.UNKNOWN;
  end;
end;

(*
Keybindings.GetKeyIndex
~~~~~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSKeybindings.GetKeyIndex(Key: Int32): Int32;
.. pascal:: function TRSKeybindings.GetKeyIndex(Gametab: ERSGameTab): Int32; overload;

Internal function used to find the index of a **Key** or **Gametab** of an already setup **KeyTabPair** if it already exists otherwise we return **-1** to know the pair does not exist yet.

*)
function TRSKeybindings.GetKeyIndex(Key: Int32): Int32;
var
  i: Int32;
begin
  for i := 0 to High(KeyTabPairs) do
    if KeyTabPairs[i].Key = Key then
      Exit(i);

  Result := -1;
end;

function TRSKeybindings.GetKeyIndex(Gametab: ERSGameTab): Int32; overload;
var
  i: Int32;
begin
  for i := 0 to High(KeyTabPairs) do
    if KeyTabPairs[i].Tab = Gametab then
      Exit(i);

  Result := -1;
end;

(*
var Keybindings
~~~~~~~~~~~~~~~
  Global Keybindings variable.

*)
var
  Keybindings: TRSKeybindings;

(*
GameTabs.FKeyOpen
~~~~~~~~~~~~~~~~~
.. pascal:: function TRSGameTabs.FKeyOpen(Tab: ERSGameTab): Boolean;

Attempts to open the **Tab** gametab with FKeys.
If the Gametab is already stored in **Keybindings.KeyTabPairs** the corresponding Fkey will simply be pressed.
Otherwise we will fetch a random yet unchecked key from **Keybindings.UncheckedKeyArray** and press it.
The following then happens:
  - If a gametab opens we store it this pair in **Keybindings.KeyTabPairs** and then:
    - If the gametab that was open was the one we wanted the result of the function will be true, otherwise false.
  - If a gametab doesn't open:

  TODO.....
*)
function TRSGameTabs.FKeyOpen(Tab: ERSGameTab): Boolean;
var
  CurrentTab: ERSGameTab;
  NewTab: ERSGameTab;
  Idx: Int32;
  Idx2: Int32;
  Key: UInt32;
  TabSwitched: Boolean;
begin
  Idx := Keybindings.GetKeyIndex(Tab);

  if Idx > -1 then
  begin
    Keyboard.PressKey(Keybindings.KeyTabPairs[Idx].Key);
    Exit(WaitUntil(Self.GetCurrentTab = Tab,
                   SRL.TruncatedGauss(50, 2000),
                   SRL.TruncatedGauss(2000, 3000)));
  end;

  if Keybindings.UncheckedKeyArray = [] then
    Exit(False); //all keys are already setup and there's no match

  Key := Keybindings.UncheckedKeyArray[Random(0, High(Keybindings.UncheckedKeyArray))];

  CurrentTab := Self.GetCurrentTab;

  Idx := Keybindings.GetKeyIndex(Key);

  if Idx = -1 then
    Exit;

  Keyboard.PressKey(Keybindings.KeyTabPairs[Idx].Key);

  TabSwitched := WaitUntil(CurrentTab <> (NewTab := Self.GetCurrentTab),
                           SRL.TruncatedGauss(50, 2000),
                           SRL.TruncatedGauss(2000, 3000));

  if TabSwitched then //if tab switched we are sure of this key-gametab pair
  begin
    Keybindings.KeyTabPairs[Idx].Setup(NewTab);
    Keybindings.UncheckedKeyArray.Del(
                Keybindings.UncheckedKeyArray.Find(Key));
  end
  else   //if the tab didn't switch the key is either paired to the current tab
  begin  //or has no pair. We only decide it has no pair if we are sure by setting it to UNKNOWN
    Idx2 := Keybindings.GetKeyIndex(CurrentTab);
    if (Idx2 > -1) and Keybindings.KeyTabPairs[Idx2].IsSetup then
    begin
      Keybindings.KeyTabPairs[Idx].Setup(ERSGameTab.UNKNOWN);
      Keybindings.UncheckedKeyArray.Del(
                  Keybindings.UncheckedKeyArray.Find(Key));
    end;
  end;

  Result := NewTab = Tab;
end;


function TRSGameTabs.GetCurrentTab: ERSGametab; override;
begin
  Result := inherited;

  if (Result = ERSGameTab.UNKNOWN) and (Bank.IsOpen or DepositBox.IsOpen) then
    Result := ERSGameTab.INVENTORY;
end;

function TRSGameTabs.Open(Tab: ERSGameTab): Boolean; override;
begin
  if Self.GetCurrentTab = Tab then
    Exit(True);

  if MainScreen.HasInterface and (Bank.IsOpen(False) or DepositBox.IsOpen) then
    MainScreen.CloseInterface;

  if Keybindings.UseKeybinds and Antiban.BioDice(EBioBehavior.FKEY_CHANCE) then
    Result := Self.FKeyOpen(Tab);

  if not Result then
    Result := inherited(Tab);
end;

// SHOULD ADD TO SRL.
function TRSGameTabs.GetTabBox(Tab: ERSGameTab): TBox; override;
var
  Tabs: TBoxArray := Self.GetTabBoxes;
begin
  if (Tabs = []) or (Tab = ERSGameTab.UNKNOWN) then
    Exit;
  Result := Tabs[Tab];
end;


procedure TSRL.Setup; override;
begin
  inherited;

  Keybindings.Setup;
end;

procedure TAntiban.Setup; override;
begin
  inherited;

  Keybindings.UseKeybinds := Self.GetChance(EBioBehavior.FKEY_CHANCE) >= 0.2;
end;
