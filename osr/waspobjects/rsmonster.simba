(*
RSMonters
=========
Methods to handle TRSMonters.
TRSMonters are a type or TRSNPC that can be fought.
*)

{$DEFINE WL_RSMONSTER_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

var
  ValueThreshold: Int32;

type
  TRSMonster = record(TRSMMDot)
    MonsterName: String;
    Hitpoints: Int32;
    MaxHit: Int32;
    AttackTypes: array of ERSMonsterAttackType;
    Drops: array of TRSMonsterDrop;
    GoodDrops: TRSItemArray;
    LootGItem: TRSGroundItem;
  end;

  TRSMonsterArray = array of TRSMonster;
  PRSMonster = ^TRSMonster;
  PRSMonsterArray = array of PRSMonster;



procedure TRSMonster.SetupCommon(Name: String); overload;
var
  Size: Int32;
begin
  MonsterName := Name;

  Self.SetupCommon;

  Name := Name.Lower;
  Name[1] := UpperCase(Name[1])[1];

  UpText += Name;

  Hitpoints := MonsterData.GetInt(Name, 'hitpoints');
  MaxHit := MonsterData.GetInt(Name, 'max_hit');
  Size := MonsterData.GetInt(Name, 'size');
  if Size = 1 then
    ShapeArray := [[[], [1, 1, 0]]]
  else
    ShapeArray := [[[], [Size/2, Size/2, 0]]];
  AttackTypes := MonsterData.GetAttackTypes(Name);
end;

procedure TRSMonster.SetupDrops;
var
  i: Int32;
begin
  GoodDrops := [];
  LootGItem := [];

  LootGItem.SetupCommon;
  LootGItem.Filter.Finder := False;

  Drops := MonsterData.GetDrops(MonsterName);

  for i := 0 to High(Drops) do
  begin
    if Drops[i].Noted and
      ((ItemData.GetAverage(Drops[i].ID) * Drops[i].Quantity) >= (ValueThreshold/5)) then
    begin
      GoodDrops += Drops[i].Item;
      LootGItem.Item +=  'noted ' + Drops[i].Item;
      LootGItem.UpText += Drops[i].Item;
    end
    else if Drops[i].Stackable and
      ((ItemData.GetAverage(Drops[i].ID) * Drops[i].Quantity) >= (ValueThreshold/5)) or
      (ItemData.GetHighAlch(Drops[i].ID) > 500) or
      (ItemData.GetAverage(Drops[i].ID) >= ValueThreshold) then
    begin
      GoodDrops += Drops[i].Item;
      LootGItem.Item += Drops[i].Item;
      LootGItem.UpText += Drops[i].Item;
    end;
  end;
end;


function TRSMonster.Attack: Boolean;
begin
  if Self.SelectOption(['Attack']) then
  begin
    Minimap.WaitMoving;
    Result := MainScreen.InCombat;
  end;
end;

function TRSMonster.WalkAttack: Boolean;
begin
  if Self.WalkSelectOption(['Attack']) then
  begin
    Minimap.WaitMoving;
    Result := MainScreen.InCombat;
  end;
end;


function TRSMonster._HandleLooting: Boolean;
begin
  if not MainScreen.IsUpText('Take') then
    Exit;

  ChooseOption.Open;

  if not ChooseOption.HasOption(LootGItem.UpText) then
    Exit;

  Result := ChooseOption.Select(LootGItem.UpText);
  (*
  for Str in LootGItem.UpText do
  begin
    WriteLn Str;
    if Inventory.IsFull then
    begin
      if (not Str.Contains('noted') or not Inventory.FindItem(Str)) then
        Continue;
      //TODO! EAT OR DROP SOMETHING!
    end;

    ChooseOption.Select(Str.After('noted '), MOUSE_LEFT, False);
  end;
  *)
end;

function TRSMonster.CheckLoot(P: TPoint): Boolean;
begin
  Mouse.Move(P);

  Result := Self._HandleLooting;
end;

function TRSMonster.CheckLoot(B: TBox): Boolean; overload;
begin
  Mouse.Move(B);

  Result := Self._HandleLooting;
end;
