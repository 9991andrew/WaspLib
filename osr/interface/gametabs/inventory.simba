{$DEFINE WL_INVENTORY_INCLUDED}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}

(*
InventoryExtra
==============
Methods to interact with the inventory.
This file expands on SRL's inventory file.
*)

const
  //Vertical 2 by 2 columns pattern. Normal and "reversed"
  DROP_PATTERN_TWO_ROW: TIntegerArray = [0,4,1,5,2,6,3,7,8,12,9,13,10,14,11,15,16,20,17,21,18,22,19,23,20,24,25,26,27,28];
  DROP_PATTERN_TWO_ROW_R: TIntegerArray = [0,4,1,5,2,6,3,7,11,15,10,14,9,13,8,12,16,20,17,21,18,22,19,23,20,24,28,27,26,25];

(*
TRSItem.Reorder
~~~~~~~~~~~~~~~
.. pascal:: function TRSItem.Reorder(LowToHi: Boolean = True): TRSItem;

Used to retrieve reordered items.
Items that have several "doses" or "portions" like a Saradomin brew (1..4) might need to be reordered sometimes.

When we want to consume them, we usually want to prioritize lower dosage items to get inventory space.
However when we are withdrawing it from the bank, we want to prioritize the highest dosage items to maximize trips length.

This function reorders depending on what you set in **LowToHi**. By default it reorders items from low to high.
*)
function TRSItem.Reorder(LowToHi: Boolean = True): TRSItem;
var
  str, first, last: String;
  i, j: Int32;
begin
  str := ToStr(Self);

  if not str.Contains('..') then
    Exit(Self);

  i := StrToInt(str.Before('..')[High(str.Before('..'))]);
  j := StrToInt(str.After('..')[Low(str.Before('..'))]);

  if (LowToHi and (i > j)) or (not LowToHi and (i < j)) then
  begin
    first := ToStr(j);
    last  := ToStr(i);
  end
  else
  begin
    first := ToStr(i);
    last  := ToStr(j);
  end;

  Result := str.Replace('(' + ToStr(i) + '..' + ToStr(j) + ')', '(' + first + '..' + last + ')');
end;

(*
TRSItem.GetPortions
~~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSItem.GetPortions(): Int32;

Get the amount of portions in the multi dose item (an item with "(x..z)").
*)
function TRSItem.GetPortions(): Int32;
var
  str: String;
  i, j: Int32;
begin
  str := ToStr(Self);

  if not str.Contains('..') then
    Exit(1);

  i := StrToInt(str.Before('..')[High(str.Before('..'))]);
  j := StrToInt(str.After('..')[Low(str.Before('..'))]);

  if i > j then
    Result := i
  else
    Result := j
end;

(*
TRSItem.GetPortion
~~~~~~~~~~~~~~~~~~
.. pascal:: function TRSItem.GetPortion(): Int32;

Get the portion number of one specific Item.

Example
-------
  Item := 'Saradomin brew(4)';

  WriteLn Item.GetPortion; //This will print 4.
*)
function TRSItem.GetPortion(): Int32;
var
  Str: String;
begin
  Str := ToStr(Self);

  if not Str.Contains('(') then
    Exit(1);

  Result := StrToInt(Str.Before(')')[High(Str.Before(')'))]);
end;

(*
Item.GetArray
~~~~~~~~~~~~~
.. pascal:: function TRSItem.GetArray(): TRSItemArray;

Used to retrieve an item array of our multi dose/portion item.

Example
-------
  var
    Item: TRSItem;
  begin
    Item := 'Saradomin brew(1..4)';

    WriteLn Item.GetArray();
    //This will print: ['Saradomin brew(1)', 'Saradomin brew(2)', 'Saradomin brew(3)', 'Saradomin brew(4)']
  end;
*)
function TRSItem.GetArray(): TRSItemArray;
var
  Str: String;
  i, first, last: Int32;
begin
  Str := ToStr(Self);

  if not Str.Contains('..') then
    Exit([Self]);

  first := StrToInt(Str.Before('..')[High(Str.Before('..'))]);
  last :=  StrToInt(Str.After('..')[Low(Str.Before('..'))]);
  if first < last then
  begin
    for i := first to last do
      Result += Str.Replace(ToStr(first) + '..' + ToStr(last), ToStr(i));
  end
  else if first > last then
  begin
    for i := first downto last do
      Result += Str.Replace(ToStr(first) + '..' + ToStr(last), ToStr(i));
  end;
end;

(*
Item.GetSingle
~~~~~~~~~~~~~~
.. pascal:: function TRSItem.GetSingle(Lo: Boolean = True): TRSItem;

Used to retrieve the lowest or highest dose of our multi dose/portion item.

Example
-------
  var
    Item: TRSItem;
  begin
    Item := 'Saradomin brew(1..4)';

    WriteLn Item.GetSingle(True); //This will print: 'Saradomin brew(1)'
  end;
*)
function TRSItem.GetSingle(lo: Boolean = True): TRSItem;
var
  Str: String;
  i, j: Int32;
begin
  Str := ToStr(Self);

  if not Str.Contains('..') then
    Exit(Self);

  i := StrToInt(Str.Before('..')[High(Str.Before('..'))]);
  j :=  StrToInt(Str.After('..')[Low(Str.Before('..'))]);

  if (lo and (i > j)) or (not lo and (i < j)) then
    Result := Str.Replace(ToStr(i) + '..' + ToStr(j), ToStr(j))
  else
    Result := Str.Replace(ToStr(i) + '..' + ToStr(j), ToStr(i));
end;


function TRSInventory.FindItems(items: TRSItemArray): TIntegerArray; override;
var
  item, singleItem: TRSItem;
begin
  if not Self.Open() then
    Exit;

  for item in items do
    for singleItem in item.GetArray() do
      Result += Self.ItemFinder.IndicesOf([singleItem]);

  Result := Result.Unique();
end;

function TRSInventory.FindItem(item: TRSItem): Integer; override;
var
  tempItem: TRSItem;
begin
  for tempItem in item.GetArray() do
  begin
    Result := inherited(tempItem);

    if Result > -1 then
      Exit;
  end;
end;


function TRSInventory.Contains(item: TRSItem): Boolean; override;
begin
  Result := Self.ItemFinder.ContainsAny(item.GetArray());
end;

function TRSInventory.ContainsAny(items: TRSItemArray): Boolean; override;
var
  item: TRSItem;
  itemArray: TRSItemArray;
begin
  for item in Items do
    itemArray += item.GetArray();

  Result := inherited(itemArray);
end;

function TRSInventory.ContainsAll(items: TRSItemArray): Boolean; override;
var
  item: TRSItem;
  itemArray: TRSItemArray;
begin
  for item in Items do
    itemArray += item.GetArray();

  Result := inherited(itemArray);
end;


function TRSInventory.FindItem(item: TRSItem): Integer; override;
var
  tempItem: TRSItem;
begin
  for tempItem in item.GetArray() do
  begin
    Result := inherited(tempItem);

    if Result > -1 then
      Exit;
  end;
end;



function TRSInventory.IsStackable(item: TRSItem): Boolean;
begin
  Result := Self.CountStack(item) > 0;
end;



function TRSInventory.Drag(initialIndex, finalIndex: Integer): Boolean;
begin
  if initialIndex = finalIndex then
    Exit(True);

  if (initialIndex < 0) or (finalIndex < 0) or not Self.IsIndexUsed(initialIndex) then
    Exit(False);

  Result := Self.HoverIndex(initialIndex);
  Mouse.DragTo(SRL.RandomPoint(Self.GetItemBox(finalIndex)));
end;

function TRSInventory.Drag(item: TRSItem; finalIndex: Integer): Boolean; overload;
begin
  Result := Self.Drag(Self.FindItem(item), finalIndex);
end;


function TRSInventory.WaitItemFade(Index: Int32): Boolean;
begin
  if WaitUntil(not Inventory.IsIndexUsed(Index), 10, 300) then
    Result := WaitUntil(Inventory.IsIndexUsed(Index), 50, 300);
end;


function TRSInventory.InteractIndex(Index: Int32; option: String = ''): Boolean;
begin
  if not Self.HoverIndex(Index) then
    Exit;

  if (option = '') or MainScreen.IsUpText(option) then
  begin
    Mouse.Click(MOUSE_LEFT);

    if (Random() < Antiban.GetUniqueNumber(0.07, 0.05, 0.1)) then
    for 0 to Round(Antiban.GetUniqueNumber(2, 1, 3)) do
    begin
      Mouse.Click(Mouse.Position, MOUSE_LEFT);

      Wait(0, 100, wdLeft);
    end;

    Exit(True);
  end;

  Result := ChooseOption.Select(option);
end;

function TRSInventory.InteractIndex(Index: Int32; option: TStringArray): Boolean; overload;
begin
  if not Self.HoverIndex(Index) then
    Exit;

  if (option = []) or MainScreen.IsUpText(option) then
  begin
    Mouse.Click(MOUSE_LEFT);
    if (Random() < Antiban.GetUniqueNumber(0.07, 0.05, 0.1)) then
    for 0 to Round(Antiban.GetUniqueNumber(2, 1, 3)) do
    begin
      Mouse.Click(Mouse.Position, MOUSE_LEFT);

      Wait(0, 100, wdLeft);
    end;

    Exit(True);
  end;

  Result := ChooseOption.Select(option);
end;


function TRSInventory.Click(item: TRSItem): Boolean; override;
begin
  if Result := inherited then
  begin
    if (Random < Antiban.GetUniqueNumber(0.07, 0.05, 0.1)) then
      for 0 to Round(Antiban.GetUniqueNumber(2, 1, 3)) do
      begin
        Mouse.Click(MOUSE_LEFT);
        Wait(0, 100, wdLeft);
      end;
  end;
end;

function TRSInventory.GetUsedIndexs(): TIntegerArray;
var
  i: Integer;
begin
  for i := Self.LOW_SLOT to Self.HIGH_SLOT do
    if Self.IsIndexUsed(i) then
      Result += i;
end;

function TRSInventory.GetEmptyIndexs(): TIntegerArray;
var
  i: Integer;
begin
  for i := Self.LOW_SLOT to Self.HIGH_SLOT do
    if not Self.IsIndexUsed(i) then
      Result += i;
end;


function TRSInventory.CountEmpty(): Int32;
begin
  Result := 28 - Self.Count();
end;

function TRSInventory.EnoughSpace(spaces: Int32): Boolean;
begin
  Result := Self.CountEmpty() <= spaces;
end;


function TRSInventory.ContainsRandomItem(items: TRSItemArray): Boolean;
begin
  Result := Self.GetUsedIndexs().Difference(Self.FindItems(items)).Length() > 0;
end;
